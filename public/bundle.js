// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

var P, d, V, C, O, N = {}, z = [], te = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function k(e, t) {
    for(var _ in t)e[_] = t[_];
    return e;
}
function G(e) {
    var t = e.parentNode;
    t && t.removeChild(e);
}
function _e(e, t, _) {
    var r, l, o, s = {};
    for(o in t)o == "key" ? r = t[o] : o == "ref" ? l = t[o] : s[o] = t[o];
    if (arguments.length > 2 && (s.children = arguments.length > 3 ? P.call(arguments, 2) : _), typeof e == "function" && e.defaultProps != null) for(o in e.defaultProps)s[o] === void 0 && (s[o] = e.defaultProps[o]);
    return S(e, s, r, l, null);
}
function S(e, t, _, r, l) {
    var o = {
        type: e,
        props: t,
        key: _,
        ref: r,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: l ?? ++V
    };
    return l == null && d.vnode != null && d.vnode(o), o;
}
function W(e) {
    return e.children;
}
function D(e, t) {
    this.props = e, this.context = t;
}
function w(e, t) {
    if (t == null) return e.__ ? w(e.__, e.__.__k.indexOf(e) + 1) : null;
    for(var _; t < e.__k.length; t++)if ((_ = e.__k[t]) != null && _.__e != null) return _.__e;
    return typeof e.type == "function" ? w(e) : null;
}
function q(e) {
    var t, _;
    if ((e = e.__) != null && e.__c != null) {
        for(e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)if ((_ = e.__k[t]) != null && _.__e != null) {
            e.__e = e.__c.base = _.__e;
            break;
        }
        return q(e);
    }
}
function H(e) {
    (!e.__d && (e.__d = !0) && C.push(e) && !L.__r++ || O !== d.debounceRendering) && ((O = d.debounceRendering) || setTimeout)(L);
}
function L() {
    for(var e; L.__r = C.length;)e = C.sort(function(t, _) {
        return t.__v.__b - _.__v.__b;
    }), C = [], e.some(function(t) {
        var _, r, l, o, s, f;
        t.__d && (s = (o = (_ = t).__v).__e, (f = _.__P) && (r = [], (l = k({}, o)).__v = o.__v + 1, F(f, o, l, _.__n, f.ownerSVGElement !== void 0, o.__h != null ? [
            s
        ] : null, r, s ?? w(o), o.__h), X(r, o), o.__e != s && q(o)));
    });
}
function J(e, t, _, r, l, o, s, f, p, a) {
    var n, h, u, i, c, b, v, y = r && r.__k || z, g = y.length;
    for(_.__k = [], n = 0; n < t.length; n++)if ((i = _.__k[n] = (i = t[n]) == null || typeof i == "boolean" ? null : typeof i == "string" || typeof i == "number" || typeof i == "bigint" ? S(null, i, null, null, i) : Array.isArray(i) ? S(W, {
        children: i
    }, null, null, null) : i.__b > 0 ? S(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) != null) {
        if (i.__ = _, i.__b = _.__b + 1, (u = y[n]) === null || u && i.key == u.key && i.type === u.type) y[n] = void 0;
        else for(h = 0; h < g; h++){
            if ((u = y[h]) && i.key == u.key && i.type === u.type) {
                y[h] = void 0;
                break;
            }
            u = null;
        }
        F(e, i, u = u || N, l, o, s, f, p, a), c = i.__e, (h = i.ref) && u.ref != h && (v || (v = []), u.ref && v.push(u.ref, null, i), v.push(h, i.__c || c, i)), c != null ? (b == null && (b = c), typeof i.type == "function" && i.__k === u.__k ? i.__d = p = K(i, p, e) : p = Q(e, i, u, y, c, p), typeof _.type == "function" && (_.__d = p)) : p && u.__e == p && p.parentNode != e && (p = w(u));
    }
    for(_.__e = b, n = g; n--;)y[n] != null && Z(y[n], y[n]);
    if (v) for(n = 0; n < v.length; n++)Y(v[n], v[++n], v[++n]);
}
function K(e, t, _) {
    for(var r, l = e.__k, o = 0; l && o < l.length; o++)(r = l[o]) && (r.__ = e, t = typeof r.type == "function" ? K(r, t, _) : Q(_, r, r, l, r.__e, t));
    return t;
}
function Q(e, t, _, r, l, o) {
    var s, f, p;
    if (t.__d !== void 0) s = t.__d, t.__d = void 0;
    else if (_ == null || l != o || l.parentNode == null) e: if (o == null || o.parentNode !== e) e.appendChild(l), s = null;
    else {
        for(f = o, p = 0; (f = f.nextSibling) && p < r.length; p += 2)if (f == l) break e;
        e.insertBefore(l, o), s = o;
    }
    return s !== void 0 ? s : l.nextSibling;
}
function oe(e, t, _, r, l) {
    var o;
    for(o in _)o === "children" || o === "key" || o in t || M(e, o, null, _[o], r);
    for(o in t)l && typeof t[o] != "function" || o === "children" || o === "key" || o === "value" || o === "checked" || _[o] === t[o] || M(e, o, t[o], _[o], r);
}
function R(e, t, _) {
    t[0] === "-" ? e.setProperty(t, _) : e[t] = _ == null ? "" : typeof _ != "number" || te.test(t) ? _ : _ + "px";
}
function M(e, t, _, r, l) {
    var o;
    e: if (t === "style") if (typeof _ == "string") e.style.cssText = _;
    else {
        if (typeof r == "string" && (e.style.cssText = r = ""), r) for(t in r)_ && t in _ || R(e.style, t, "");
        if (_) for(t in _)r && _[t] === r[t] || R(e.style, t, _[t]);
    }
    else if (t[0] === "o" && t[1] === "n") o = t !== (t = t.replace(/Capture$/, "")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + o] = _, _ ? r || e.addEventListener(t, o ? B : $, o) : e.removeEventListener(t, o ? B : $, o);
    else if (t !== "dangerouslySetInnerHTML") {
        if (l) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if (t !== "href" && t !== "list" && t !== "form" && t !== "tabIndex" && t !== "download" && t in e) try {
            e[t] = _ ?? "";
            break e;
        } catch  {}
        typeof _ == "function" || (_ == null || _ === !1 && t.indexOf("-") == -1 ? e.removeAttribute(t) : e.setAttribute(t, _));
    }
}
function $(e) {
    this.l[e.type + !1](d.event ? d.event(e) : e);
}
function B(e) {
    this.l[e.type + !0](d.event ? d.event(e) : e);
}
function F(e, t, _, r, l, o, s, f, p) {
    var a, n, h, u, i, c, b, v, y, g, E, x, I, A, T, m = t.type;
    if (t.constructor !== void 0) return null;
    _.__h != null && (p = _.__h, f = t.__e = _.__e, t.__h = null, o = [
        f
    ]), (a = d.__b) && a(t);
    try {
        e: if (typeof m == "function") {
            if (v = t.props, y = (a = m.contextType) && r[a.__c], g = a ? y ? y.props.value : a.__ : r, _.__c ? b = (n = t.__c = _.__c).__ = n.__E : ("prototype" in m && m.prototype.render ? t.__c = n = new m(v, g) : (t.__c = n = new D(v, g), n.constructor = m, n.render = le), y && y.sub(n), n.props = v, n.state || (n.state = {}), n.context = g, n.__n = r, h = n.__d = !0, n.__h = [], n._sb = []), n.__s == null && (n.__s = n.state), m.getDerivedStateFromProps != null && (n.__s == n.state && (n.__s = k({}, n.__s)), k(n.__s, m.getDerivedStateFromProps(v, n.__s))), u = n.props, i = n.state, h) m.getDerivedStateFromProps == null && n.componentWillMount != null && n.componentWillMount(), n.componentDidMount != null && n.__h.push(n.componentDidMount);
            else {
                if (m.getDerivedStateFromProps == null && v !== u && n.componentWillReceiveProps != null && n.componentWillReceiveProps(v, g), !n.__e && n.shouldComponentUpdate != null && n.shouldComponentUpdate(v, n.__s, g) === !1 || t.__v === _.__v) {
                    for(n.props = v, n.state = n.__s, t.__v !== _.__v && (n.__d = !1), n.__v = t, t.__e = _.__e, t.__k = _.__k, t.__k.forEach(function(U) {
                        U && (U.__ = t);
                    }), E = 0; E < n._sb.length; E++)n.__h.push(n._sb[E]);
                    n._sb = [], n.__h.length && s.push(n);
                    break e;
                }
                n.componentWillUpdate != null && n.componentWillUpdate(v, n.__s, g), n.componentDidUpdate != null && n.__h.push(function() {
                    n.componentDidUpdate(u, i, c);
                });
            }
            if (n.context = g, n.props = v, n.__v = t, n.__P = e, x = d.__r, I = 0, "prototype" in m && m.prototype.render) {
                for(n.state = n.__s, n.__d = !1, x && x(t), a = n.render(n.props, n.state, n.context), A = 0; A < n._sb.length; A++)n.__h.push(n._sb[A]);
                n._sb = [];
            } else do n.__d = !1, x && x(t), a = n.render(n.props, n.state, n.context), n.state = n.__s;
            while (n.__d && ++I < 25)
            n.state = n.__s, n.getChildContext != null && (r = k(k({}, r), n.getChildContext())), h || n.getSnapshotBeforeUpdate == null || (c = n.getSnapshotBeforeUpdate(u, i)), T = a != null && a.type === W && a.key == null ? a.props.children : a, J(e, Array.isArray(T) ? T : [
                T
            ], t, _, r, l, o, s, f, p), n.base = t.__e, t.__h = null, n.__h.length && s.push(n), b && (n.__E = n.__ = null), n.__e = !1;
        } else o == null && t.__v === _.__v ? (t.__k = _.__k, t.__e = _.__e) : t.__e = re(_.__e, t, _, r, l, o, s, p);
        (a = d.diffed) && a(t);
    } catch (U) {
        t.__v = null, (p || o != null) && (t.__e = f, t.__h = !!p, o[o.indexOf(f)] = null), d.__e(U, t, _);
    }
}
function X(e, t) {
    d.__c && d.__c(t, e), e.some(function(_) {
        try {
            e = _.__h, _.__h = [], e.some(function(r) {
                r.call(_);
            });
        } catch (r) {
            d.__e(r, _.__v);
        }
    });
}
function re(e, t, _, r, l, o, s, f) {
    var p, a, n, h = _.props, u = t.props, i = t.type, c = 0;
    if (i === "svg" && (l = !0), o != null) {
        for(; c < o.length; c++)if ((p = o[c]) && "setAttribute" in p == !!i && (i ? p.localName === i : p.nodeType === 3)) {
            e = p, o[c] = null;
            break;
        }
    }
    if (e == null) {
        if (i === null) return document.createTextNode(u);
        e = l ? document.createElementNS("http://www.w3.org/2000/svg", i) : document.createElement(i, u.is && u), o = null, f = !1;
    }
    if (i === null) h === u || f && e.data === u || (e.data = u);
    else {
        if (o = o && P.call(e.childNodes), a = (h = _.props || N).dangerouslySetInnerHTML, n = u.dangerouslySetInnerHTML, !f) {
            if (o != null) for(h = {}, c = 0; c < e.attributes.length; c++)h[e.attributes[c].name] = e.attributes[c].value;
            (n || a) && (n && (a && n.__html == a.__html || n.__html === e.innerHTML) || (e.innerHTML = n && n.__html || ""));
        }
        if (oe(e, u, h, l, f), n) t.__k = [];
        else if (c = t.props.children, J(e, Array.isArray(c) ? c : [
            c
        ], t, _, r, l && i !== "foreignObject", o, s, o ? o[0] : _.__k && w(_, 0), f), o != null) for(c = o.length; c--;)o[c] != null && G(o[c]);
        f || ("value" in u && (c = u.value) !== void 0 && (c !== e.value || i === "progress" && !c || i === "option" && c !== h.value) && M(e, "value", c, h.value, !1), "checked" in u && (c = u.checked) !== void 0 && c !== e.checked && M(e, "checked", c, h.checked, !1));
    }
    return e;
}
function Y(e, t, _) {
    try {
        typeof e == "function" ? e(t) : e.current = t;
    } catch (r) {
        d.__e(r, _);
    }
}
function Z(e, t, _) {
    var r, l;
    if (d.unmount && d.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || Y(r, null, t)), (r = e.__c) != null) {
        if (r.componentWillUnmount) try {
            r.componentWillUnmount();
        } catch (o) {
            d.__e(o, t);
        }
        r.base = r.__P = null, e.__c = void 0;
    }
    if (r = e.__k) for(l = 0; l < r.length; l++)r[l] && Z(r[l], t, _ || typeof e.type != "function");
    _ || e.__e == null || G(e.__e), e.__ = e.__e = e.__d = void 0;
}
function le(e, t, _) {
    return this.constructor(e, _);
}
function ie(e, t, _) {
    var r, l, o;
    d.__ && d.__(e, t), l = (r = typeof _ == "function") ? null : _ && _.__k || t.__k, o = [], F(t, e = (!r && _ || t).__k = _e(W, null, [
        e
    ]), l || N, N, t.ownerSVGElement !== void 0, !r && _ ? [
        _
    ] : l ? null : t.firstChild ? P.call(t.childNodes) : null, o, !r && _ ? _ : l ? l.__e : t.firstChild, r), X(o, e);
}
P = z.slice, d = {
    __e: function(e, t, _, r) {
        for(var l, o, s; t = t.__;)if ((l = t.__c) && !l.__) try {
            if ((o = l.constructor) && o.getDerivedStateFromError != null && (l.setState(o.getDerivedStateFromError(e)), s = l.__d), l.componentDidCatch != null && (l.componentDidCatch(e, r || {}), s = l.__d), s) return l.__E = l;
        } catch (f) {
            e = f;
        }
        throw e;
    }
}, V = 0, D.prototype.setState = function(e, t) {
    var _;
    _ = this.__s != null && this.__s !== this.state ? this.__s : this.__s = k({}, this.state), typeof e == "function" && (e = e(k({}, _), this.props)), e && k(_, e), e != null && this.__v && (t && this._sb.push(t), H(this));
}, D.prototype.forceUpdate = function(e) {
    this.__v && (this.__e = !0, e && this.__h.push(e), H(this));
}, D.prototype.render = W, C = [], L.__r = 0, 0;
var O1 = Object.create;
var c = Object.defineProperty;
var m = Object.getOwnPropertyDescriptor;
var j = Object.getOwnPropertyNames;
var g = Object.getPrototypeOf, v = Object.prototype.hasOwnProperty;
var y = (r)=>c(r, "__esModule", {
        value: !0
    });
var d1 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var h = (r, e, t, a)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of j(e))!v.call(r, n) && (t || n !== "default") && c(r, n, {
        get: ()=>e[n],
        enumerable: !(a = m(e, n)) || a.enumerable
    });
    return r;
}, i = (r, e)=>h(y(c(r != null ? O1(g(r)) : {}, "default", !e && r && r.__esModule ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var u = d1((q, p)=>{
    "use strict";
    var l = Object.getOwnPropertySymbols, w = Object.prototype.hasOwnProperty, P = Object.prototype.propertyIsEnumerable;
    function _(r) {
        if (r == null) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(r);
    }
    function E() {
        try {
            if (!Object.assign) return !1;
            var r = new String("abc");
            if (r[5] = "de", Object.getOwnPropertyNames(r)[0] === "5") return !1;
            for(var e = {}, t = 0; t < 10; t++)e["_" + String.fromCharCode(t)] = t;
            var a = Object.getOwnPropertyNames(e).map(function(o) {
                return e[o];
            });
            if (a.join("") !== "0123456789") return !1;
            var n = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(o) {
                n[o] = o;
            }), Object.keys(Object.assign({}, n)).join("") === "abcdefghijklmnopqrst";
        } catch  {
            return !1;
        }
    }
    p.exports = E() ? Object.assign : function(r, e) {
        for(var t, a = _(r), n, o = 1; o < arguments.length; o++){
            t = Object(arguments[o]);
            for(var s in t)w.call(t, s) && (a[s] = t[s]);
            if (l) {
                n = l(t);
                for(var f = 0; f < n.length; f++)P.call(t, n[f]) && (a[n[f]] = t[n[f]]);
            }
        }
        return a;
    };
});
var b = i(u()), S1 = i(u()), x = b.default || S1;
var G1 = Object.create;
var h1 = Object.defineProperty;
var J1 = Object.getOwnPropertyDescriptor;
var K1 = Object.getOwnPropertyNames;
var Q1 = Object.getPrototypeOf, X1 = Object.prototype.hasOwnProperty;
var Z1 = (e)=>h1(e, "__esModule", {
        value: !0
    });
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (t, r)=>(typeof require != "undefined" ? require : t)[r]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var O2 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var ee = (e, t, r, u)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let o of K1(t))!X1.call(e, o) && (r || o !== "default") && h1(e, o, {
        get: ()=>t[o],
        enumerable: !(u = J1(t, o)) || u.enumerable
    });
    return e;
}, P1 = (e, t)=>ee(Z1(h1(e != null ? G1(Q1(e)) : {}, "default", !t && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var z1 = O2((n)=>{
    "use strict";
    var E = x, y = 60103, j = 60106;
    n.Fragment = 60107;
    n.StrictMode = 60108;
    n.Profiler = 60114;
    var x1 = 60109, I = 60110, w = 60112;
    n.Suspense = 60113;
    var A = 60115, F = 60116;
    typeof Symbol == "function" && Symbol.for && (l = Symbol.for, y = l("react.element"), j = l("react.portal"), n.Fragment = l("react.fragment"), n.StrictMode = l("react.strict_mode"), n.Profiler = l("react.profiler"), x1 = l("react.provider"), I = l("react.context"), w = l("react.forward_ref"), n.Suspense = l("react.suspense"), A = l("react.memo"), F = l("react.lazy"));
    var l, L = typeof Symbol == "function" && Symbol.iterator;
    function te(e) {
        return e === null || typeof e != "object" ? null : (e = L && e[L] || e["@@iterator"], typeof e == "function" ? e : null);
    }
    function _(e) {
        for(var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++)t += "&args[]=" + encodeURIComponent(arguments[r]);
        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var q = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }, D = {};
    function d(e, t, r) {
        this.props = e, this.context = t, this.refs = D, this.updater = r || q;
    }
    d.prototype.isReactComponent = {};
    d.prototype.setState = function(e, t) {
        if (typeof e != "object" && typeof e != "function" && e != null) throw Error(_(85));
        this.updater.enqueueSetState(this, e, t, "setState");
    };
    d.prototype.forceUpdate = function(e) {
        this.updater.enqueueForceUpdate(this, e, "forceUpdate");
    };
    function M() {}
    M.prototype = d.prototype;
    function S(e, t, r) {
        this.props = e, this.context = t, this.refs = D, this.updater = r || q;
    }
    var C = S.prototype = new M;
    C.constructor = S;
    E(C, d.prototype);
    C.isPureReactComponent = !0;
    var R = {
        current: null
    }, N = Object.prototype.hasOwnProperty, U = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function T(e, t, r) {
        var u, o = {}, f = null, s = null;
        if (t != null) for(u in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (f = "" + t.key), t)N.call(t, u) && !U.hasOwnProperty(u) && (o[u] = t[u]);
        var c = arguments.length - 2;
        if (c === 1) o.children = r;
        else if (1 < c) {
            for(var i = Array(c), p = 0; p < c; p++)i[p] = arguments[p + 2];
            o.children = i;
        }
        if (e && e.defaultProps) for(u in c = e.defaultProps, c)o[u] === void 0 && (o[u] = c[u]);
        return {
            $$typeof: y,
            type: e,
            key: f,
            ref: s,
            props: o,
            _owner: R.current
        };
    }
    function re(e, t) {
        return {
            $$typeof: y,
            type: e.type,
            key: t,
            ref: e.ref,
            props: e.props,
            _owner: e._owner
        };
    }
    function k(e) {
        return typeof e == "object" && e !== null && e.$$typeof === y;
    }
    function ne(e) {
        var t = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + e.replace(/[=:]/g, function(r) {
            return t[r];
        });
    }
    var V = /\/+/g;
    function $(e, t) {
        return typeof e == "object" && e !== null && e.key != null ? ne("" + e.key) : t.toString(36);
    }
    function v(e, t, r, u, o) {
        var f = typeof e;
        (f === "undefined" || f === "boolean") && (e = null);
        var s = !1;
        if (e === null) s = !0;
        else switch(f){
            case "string":
            case "number":
                s = !0;
                break;
            case "object":
                switch(e.$$typeof){
                    case y:
                    case j:
                        s = !0;
                }
        }
        if (s) return s = e, o = o(s), e = u === "" ? "." + $(s, 0) : u, Array.isArray(o) ? (r = "", e != null && (r = e.replace(V, "$&/") + "/"), v(o, t, r, "", function(p) {
            return p;
        })) : o != null && (k(o) && (o = re(o, r + (!o.key || s && s.key === o.key ? "" : ("" + o.key).replace(V, "$&/") + "/") + e)), t.push(o)), 1;
        if (s = 0, u = u === "" ? "." : u + ":", Array.isArray(e)) for(var c = 0; c < e.length; c++){
            f = e[c];
            var i = u + $(f, c);
            s += v(f, t, r, i, o);
        }
        else if (i = te(e), typeof i == "function") for(e = i.call(e), c = 0; !(f = e.next()).done;)f = f.value, i = u + $(f, c++), s += v(f, t, r, i, o);
        else if (f === "object") throw t = "" + e, Error(_(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
        return s;
    }
    function m(e, t, r) {
        if (e == null) return e;
        var u = [], o = 0;
        return v(e, u, "", "", function(f) {
            return t.call(r, f, o++);
        }), u;
    }
    function oe(e) {
        if (e._status === -1) {
            var t = e._result;
            t = t(), e._status = 0, e._result = t, t.then(function(r) {
                e._status === 0 && (r = r.default, e._status = 1, e._result = r);
            }, function(r) {
                e._status === 0 && (e._status = 2, e._result = r);
            });
        }
        if (e._status === 1) return e._result;
        throw e._result;
    }
    var B = {
        current: null
    };
    function a() {
        var e = B.current;
        if (e === null) throw Error(_(321));
        return e;
    }
    var ue = {
        ReactCurrentDispatcher: B,
        ReactCurrentBatchConfig: {
            transition: 0
        },
        ReactCurrentOwner: R,
        IsSomeRendererActing: {
            current: !1
        },
        assign: E
    };
    n.Children = {
        map: m,
        forEach: function(e, t, r) {
            m(e, function() {
                t.apply(this, arguments);
            }, r);
        },
        count: function(e) {
            var t = 0;
            return m(e, function() {
                t++;
            }), t;
        },
        toArray: function(e) {
            return m(e, function(t) {
                return t;
            }) || [];
        },
        only: function(e) {
            if (!k(e)) throw Error(_(143));
            return e;
        }
    };
    n.Component = d;
    n.PureComponent = S;
    n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ue;
    n.cloneElement = function(e, t, r) {
        if (e == null) throw Error(_(267, e));
        var u = E({}, e.props), o = e.key, f = e.ref, s = e._owner;
        if (t != null) {
            if (t.ref !== void 0 && (f = t.ref, s = R.current), t.key !== void 0 && (o = "" + t.key), e.type && e.type.defaultProps) var c = e.type.defaultProps;
            for(i in t)N.call(t, i) && !U.hasOwnProperty(i) && (u[i] = t[i] === void 0 && c !== void 0 ? c[i] : t[i]);
        }
        var i = arguments.length - 2;
        if (i === 1) u.children = r;
        else if (1 < i) {
            c = Array(i);
            for(var p = 0; p < i; p++)c[p] = arguments[p + 2];
            u.children = c;
        }
        return {
            $$typeof: y,
            type: e.type,
            key: o,
            ref: f,
            props: u,
            _owner: s
        };
    };
    n.createContext = function(e, t) {
        return t === void 0 && (t = null), e = {
            $$typeof: I,
            _calculateChangedBits: t,
            _currentValue: e,
            _currentValue2: e,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        }, e.Provider = {
            $$typeof: x1,
            _context: e
        }, e.Consumer = e;
    };
    n.createElement = T;
    n.createFactory = function(e) {
        var t = T.bind(null, e);
        return t.type = e, t;
    };
    n.createRef = function() {
        return {
            current: null
        };
    };
    n.forwardRef = function(e) {
        return {
            $$typeof: w,
            render: e
        };
    };
    n.isValidElement = k;
    n.lazy = function(e) {
        return {
            $$typeof: F,
            _payload: {
                _status: -1,
                _result: e
            },
            _init: oe
        };
    };
    n.memo = function(e, t) {
        return {
            $$typeof: A,
            type: e,
            compare: t === void 0 ? null : t
        };
    };
    n.useCallback = function(e, t) {
        return a().useCallback(e, t);
    };
    n.useContext = function(e, t) {
        return a().useContext(e, t);
    };
    n.useDebugValue = function() {};
    n.useEffect = function(e, t) {
        return a().useEffect(e, t);
    };
    n.useImperativeHandle = function(e, t, r) {
        return a().useImperativeHandle(e, t, r);
    };
    n.useLayoutEffect = function(e, t) {
        return a().useLayoutEffect(e, t);
    };
    n.useMemo = function(e, t) {
        return a().useMemo(e, t);
    };
    n.useReducer = function(e, t, r) {
        return a().useReducer(e, t, r);
    };
    n.useRef = function(e) {
        return a().useRef(e);
    };
    n.useState = function(e) {
        return a().useState(e);
    };
    n.version = "17.0.2";
});
var g1 = O2((ce, H)=>{
    "use strict";
    H.exports = z1();
});
var W1 = P1(g1()), Y1 = P1(g1()), { Fragment: se , StrictMode: le1 , Profiler: pe , Suspense: ae , Children: ye , Component: de , PureComponent: _e1 , __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ve , cloneElement: me , createContext: he , createElement: Ee , createFactory: Se , createRef: Ce , forwardRef: Re , isValidElement: ke , lazy: $e , memo: ge , useCallback: Oe , useContext: Pe , useDebugValue: je , useEffect: xe , useImperativeHandle: Ie , useLayoutEffect: we , useMemo: Ae , useReducer: Fe , useRef: Le , useState: qe , version: De  } = Y1, Me = W1.default || Y1;
var d2 = Object.create;
var p = Object.defineProperty;
var P2 = Object.getOwnPropertyDescriptor;
var R1 = Object.getOwnPropertyNames;
var g2 = Object.getPrototypeOf, v1 = Object.prototype.hasOwnProperty;
var x1 = (e)=>p(e, "__esModule", {
        value: !0
    });
var a = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var E = (e, r, o, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of R1(r))!v1.call(e, t) && (o || t !== "default") && p(e, t, {
        get: ()=>r[t],
        enumerable: !(n = P2(r, t)) || n.enumerable
    });
    return e;
}, i1 = (e, r)=>E(x1(p(e != null ? d2(g2(e)) : {}, "default", !r && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var u1 = a((q, y)=>{
    "use strict";
    var S = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    y.exports = S;
});
var h2 = a((D, l)=>{
    "use strict";
    var k = u1();
    function m() {}
    function f() {}
    f.resetWarningCache = m;
    l.exports = function() {
        function e(n, t, C, I, N, _) {
            if (_ !== k) {
                var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw c.name = "Invariant Violation", c;
            }
        }
        e.isRequired = e;
        function r() {
            return e;
        }
        var o = {
            array: e,
            bigint: e,
            bool: e,
            func: e,
            number: e,
            object: e,
            string: e,
            symbol: e,
            any: e,
            arrayOf: r,
            element: e,
            elementType: e,
            instanceOf: r,
            node: e,
            objectOf: r,
            oneOf: r,
            oneOfType: r,
            shape: r,
            exact: r,
            checkPropTypes: f,
            resetWarningCache: m
        };
        return o.PropTypes = o, o;
    };
});
var s = a((F, T)=>{
    T.exports = h2()();
});
var O3 = i1(s()), b1 = i1(s()), { array: A , bigint: L1 , bool: U , func: V1 , number: B1 , object: H1 , string: Y2 , symbol: z2 , any: G2 , arrayOf: J2 , element: K2 , elementType: M1 , instanceOf: Q2 , node: X2 , objectOf: Z2 , oneOf: $1 , oneOfType: ee1 , shape: re1 , exact: te1 , checkPropTypes: oe1 , resetWarningCache: ne , PropTypes: pe1  } = b1, ae1 = O3.default || b1;
function a1() {
    return a1 = Object.assign || function(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = arguments[t];
            for(var r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
    }, a1.apply(this, arguments);
}
function f(r, o) {
    if (r == null) return {};
    var n = {}, i = Object.keys(r), e, t;
    for(t = 0; t < i.length; t++)e = i[t], !(o.indexOf(e) >= 0) && (n[e] = r[e]);
    return n;
}
var j1 = Object.create;
var S2 = Object.defineProperty;
var A1 = Object.getOwnPropertyDescriptor;
var h3 = Object.getOwnPropertyNames;
var L2 = Object.getPrototypeOf, R2 = Object.prototype.hasOwnProperty;
var q1 = (e)=>S2(e, "__esModule", {
        value: !0
    });
var P3 = (e, o)=>()=>(o || e((o = {
            exports: {}
        }).exports, o), o.exports);
var O4 = (e, o, z, x)=>{
    if (o && typeof o == "object" || typeof o == "function") for (let s of h3(o))!R2.call(e, s) && (z || s !== "default") && S2(e, s, {
        get: ()=>o[s],
        enumerable: !(x = A1(o, s)) || x.enumerable
    });
    return e;
}, v2 = (e, o)=>O4(q1(S2(e != null ? j1(L2(e)) : {}, "default", !o && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var w1 = P3((r)=>{
    "use strict";
    var t = typeof Symbol == "function" && Symbol.for, b = t ? Symbol.for("react.element") : 60103, $ = t ? Symbol.for("react.portal") : 60106, c = t ? Symbol.for("react.fragment") : 60107, f = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, u = t ? Symbol.for("react.provider") : 60109, l = t ? Symbol.for("react.context") : 60110, C = t ? Symbol.for("react.async_mode") : 60111, y = t ? Symbol.for("react.concurrent_mode") : 60111, m = t ? Symbol.for("react.forward_ref") : 60112, p = t ? Symbol.for("react.suspense") : 60113, V = t ? Symbol.for("react.suspense_list") : 60120, d = t ? Symbol.for("react.memo") : 60115, a = t ? Symbol.for("react.lazy") : 60116, k = t ? Symbol.for("react.block") : 60121, N = t ? Symbol.for("react.fundamental") : 60117, T = t ? Symbol.for("react.responder") : 60118, D = t ? Symbol.for("react.scope") : 60119;
    function n(e) {
        if (typeof e == "object" && e !== null) {
            var o = e.$$typeof;
            switch(o){
                case b:
                    switch(e = e.type, e){
                        case C:
                        case y:
                        case c:
                        case i:
                        case f:
                        case p:
                            return e;
                        default:
                            switch(e = e && e.$$typeof, e){
                                case l:
                                case m:
                                case a:
                                case d:
                                case u:
                                    return e;
                                default:
                                    return o;
                            }
                    }
                case $:
                    return o;
            }
        }
    }
    function _(e) {
        return n(e) === y;
    }
    r.AsyncMode = C;
    r.ConcurrentMode = y;
    r.ContextConsumer = l;
    r.ContextProvider = u;
    r.Element = b;
    r.ForwardRef = m;
    r.Fragment = c;
    r.Lazy = a;
    r.Memo = d;
    r.Portal = $;
    r.Profiler = i;
    r.StrictMode = f;
    r.Suspense = p;
    r.isAsyncMode = function(e) {
        return _(e) || n(e) === C;
    };
    r.isConcurrentMode = _;
    r.isContextConsumer = function(e) {
        return n(e) === l;
    };
    r.isContextProvider = function(e) {
        return n(e) === u;
    };
    r.isElement = function(e) {
        return typeof e == "object" && e !== null && e.$$typeof === b;
    };
    r.isForwardRef = function(e) {
        return n(e) === m;
    };
    r.isFragment = function(e) {
        return n(e) === c;
    };
    r.isLazy = function(e) {
        return n(e) === a;
    };
    r.isMemo = function(e) {
        return n(e) === d;
    };
    r.isPortal = function(e) {
        return n(e) === $;
    };
    r.isProfiler = function(e) {
        return n(e) === i;
    };
    r.isStrictMode = function(e) {
        return n(e) === f;
    };
    r.isSuspense = function(e) {
        return n(e) === p;
    };
    r.isValidElementType = function(e) {
        return typeof e == "string" || typeof e == "function" || e === c || e === y || e === i || e === f || e === p || e === V || typeof e == "object" && e !== null && (e.$$typeof === a || e.$$typeof === d || e.$$typeof === u || e.$$typeof === l || e.$$typeof === m || e.$$typeof === N || e.$$typeof === T || e.$$typeof === D || e.$$typeof === k);
    };
    r.typeOf = n;
});
var M2 = P3((H, E)=>{
    "use strict";
    E.exports = w1();
});
var F1 = v2(M2()), g3 = v2(M2()), { AsyncMode: I , ConcurrentMode: J3 , ContextConsumer: K3 , ContextProvider: Q3 , Element: U1 , ForwardRef: W2 , Fragment: X3 , Lazy: Y3 , Memo: Z3 , Portal: ee2 , Profiler: re2 , StrictMode: te2 , Suspense: oe2 , isAsyncMode: ne1 , isConcurrentMode: se1 , isContextConsumer: ce , isContextProvider: fe , isElement: ie1 , isForwardRef: ue , isFragment: le2 , isLazy: ye1 , isMemo: me1 , isPortal: pe2 , isProfiler: de1 , isStrictMode: ae2 , isSuspense: Se1 , isValidElementType: be , typeOf: $e1  } = g3, Ce1 = F1.default || g3;
var N1 = Object.create;
var f1 = Object.defineProperty;
var b2 = Object.getOwnPropertyDescriptor;
var j2 = Object.getOwnPropertyNames;
var w2 = Object.getPrototypeOf, A2 = Object.prototype.hasOwnProperty;
var x2 = (r)=>f1(r, "__esModule", {
        value: !0
    });
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, a)=>(typeof require != "undefined" ? require : e)[a]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var I1 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var R3 = (r, e, a, p)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of j2(e))!A2.call(r, t) && (a || t !== "default") && f1(r, t, {
        get: ()=>e[t],
        enumerable: !(p = b2(e, t)) || p.enumerable
    });
    return r;
}, O5 = (r, e)=>R3(x2(f1(r != null ? N1(w2(r)) : {}, "default", !e && r && r.__esModule ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var i2 = I1((z, g)=>{
    "use strict";
    var y = Ce1, $ = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    }, E = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    }, F = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    }, P = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    }, v = {};
    v[y.ForwardRef] = F;
    v[y.Memo] = P;
    function c(r) {
        return y.isMemo(r) ? P : v[r.$$typeof] || $;
    }
    var M = Object.defineProperty, h = Object.getOwnPropertyNames, l = Object.getOwnPropertySymbols, n = Object.getOwnPropertyDescriptor, W = Object.getPrototypeOf, S = Object.prototype;
    function d(r, e, a) {
        if (typeof e != "string") {
            if (S) {
                var p = W(e);
                p && p !== S && d(r, p, a);
            }
            var t = h(e);
            l && (t = t.concat(l(e)));
            for(var s = c(r), T = c(e), o = 0; o < t.length; ++o){
                var u = t[o];
                if (!E[u] && !(a && a[u]) && !(T && T[u]) && !(s && s[u])) {
                    var m = n(e, u);
                    try {
                        M(r, u, m);
                    } catch  {}
                }
            }
        }
        return r;
    }
    g.exports = d;
});
var _ = O5(i2()), q2 = O5(i2()), B2 = _.default || q2;
var B3 = Object.create;
var C1 = Object.defineProperty;
var G3 = Object.getOwnPropertyDescriptor;
var ee3 = Object.getOwnPropertyNames;
var ne2 = Object.getPrototypeOf, te3 = Object.prototype.hasOwnProperty;
var re3 = (e)=>C1(e, "__esModule", {
        value: !0
    });
var H2 = (e, n)=>()=>(n || e((n = {
            exports: {}
        }).exports, n), n.exports);
var le3 = (e, n, t, l)=>{
    if (n && typeof n == "object" || typeof n == "function") for (let o of ee3(n))!te3.call(e, o) && (t || o !== "default") && C1(e, o, {
        get: ()=>n[o],
        enumerable: !(l = G3(n, o)) || l.enumerable
    });
    return e;
}, J4 = (e, n)=>le3(re3(C1(e != null ? B3(ne2(e)) : {}, "default", !n && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var $2 = H2((r)=>{
    "use strict";
    var d, m, g, L;
    typeof performance == "object" && typeof performance.now == "function" ? (K = performance, r.unstable_now = function() {
        return K.now();
    }) : (N = Date, Q = N.now(), r.unstable_now = function() {
        return N.now() - Q;
    });
    var K, N, Q;
    typeof window == "undefined" || typeof MessageChannel != "function" ? (y = null, j = null, E = function() {
        if (y !== null) try {
            var e = r.unstable_now();
            y(!0, e), y = null;
        } catch (n) {
            throw setTimeout(E, 0), n;
        }
    }, d = function(e) {
        y !== null ? setTimeout(d, 0, e) : (y = e, setTimeout(E, 0));
    }, m = function(e, n) {
        j = setTimeout(e, n);
    }, g = function() {
        clearTimeout(j);
    }, r.unstable_shouldYield = function() {
        return !1;
    }, L = r.unstable_forceFrameRate = function() {}) : (S = window.setTimeout, X = window.clearTimeout, typeof console != "undefined" && (Z = window.cancelAnimationFrame, typeof window.requestAnimationFrame != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof Z != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")), w = !1, h = null, P = -1, F = 5, q = 0, r.unstable_shouldYield = function() {
        return r.unstable_now() >= q;
    }, L = function() {}, r.unstable_forceFrameRate = function(e) {
        0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < e ? Math.floor(1e3 / e) : 5;
    }, R = new MessageChannel, x = R.port2, R.port1.onmessage = function() {
        if (h !== null) {
            var e = r.unstable_now();
            q = e + F;
            try {
                h(!0, e) ? x.postMessage(null) : (w = !1, h = null);
            } catch (n) {
                throw x.postMessage(null), n;
            }
        } else w = !1;
    }, d = function(e) {
        h = e, w || (w = !0, x.postMessage(null));
    }, m = function(e, n) {
        P = S(function() {
            e(r.unstable_now());
        }, n);
    }, g = function() {
        X(P), P = -1;
    });
    var y, j, E, S, X, Z, w, h, P, F, q, R, x;
    function Y(e, n) {
        var t = e.length;
        e.push(n);
        e: for(;;){
            var l = t - 1 >>> 1, o = e[l];
            if (o !== void 0 && 0 < I(o, n)) e[l] = n, e[t] = o, t = l;
            else break e;
        }
    }
    function u(e) {
        return e = e[0], e === void 0 ? null : e;
    }
    function T(e) {
        var n = e[0];
        if (n !== void 0) {
            var t = e.pop();
            if (t !== n) {
                e[0] = t;
                e: for(var l = 0, o = e.length; l < o;){
                    var f = 2 * (l + 1) - 1, b = e[f], v = f + 1, _ = e[v];
                    if (b !== void 0 && 0 > I(b, t)) _ !== void 0 && 0 > I(_, b) ? (e[l] = _, e[v] = t, l = v) : (e[l] = b, e[f] = t, l = f);
                    else if (_ !== void 0 && 0 > I(_, t)) e[l] = _, e[v] = t, l = v;
                    else break e;
                }
            }
            return n;
        }
        return null;
    }
    function I(e, n) {
        var t = e.sortIndex - n.sortIndex;
        return t !== 0 ? t : e.id - n.id;
    }
    var s = [], c = [], oe = 1, a = null, i = 3, M = !1, p = !1, k = !1;
    function U(e) {
        for(var n = u(c); n !== null;){
            if (n.callback === null) T(c);
            else if (n.startTime <= e) T(c), n.sortIndex = n.expirationTime, Y(s, n);
            else break;
            n = u(c);
        }
    }
    function W(e) {
        if (k = !1, U(e), !p) if (u(s) !== null) p = !0, d(O);
        else {
            var n = u(c);
            n !== null && m(W, n.startTime - e);
        }
    }
    function O(e, n) {
        p = !1, k && (k = !1, g()), M = !0;
        var t = i;
        try {
            for(U(n), a = u(s); a !== null && (!(a.expirationTime > n) || e && !r.unstable_shouldYield());){
                var l = a.callback;
                if (typeof l == "function") {
                    a.callback = null, i = a.priorityLevel;
                    var o = l(a.expirationTime <= n);
                    n = r.unstable_now(), typeof o == "function" ? a.callback = o : a === u(s) && T(s), U(n);
                } else T(s);
                a = u(s);
            }
            if (a !== null) var f = !0;
            else {
                var b = u(c);
                b !== null && m(W, b.startTime - n), f = !1;
            }
            return f;
        } finally{
            a = null, i = t, M = !1;
        }
    }
    var ie = L;
    r.unstable_IdlePriority = 5;
    r.unstable_ImmediatePriority = 1;
    r.unstable_LowPriority = 4;
    r.unstable_NormalPriority = 3;
    r.unstable_Profiling = null;
    r.unstable_UserBlockingPriority = 2;
    r.unstable_cancelCallback = function(e) {
        e.callback = null;
    };
    r.unstable_continueExecution = function() {
        p || M || (p = !0, d(O));
    };
    r.unstable_getCurrentPriorityLevel = function() {
        return i;
    };
    r.unstable_getFirstCallbackNode = function() {
        return u(s);
    };
    r.unstable_next = function(e) {
        switch(i){
            case 1:
            case 2:
            case 3:
                var n = 3;
                break;
            default:
                n = i;
        }
        var t = i;
        i = n;
        try {
            return e();
        } finally{
            i = t;
        }
    };
    r.unstable_pauseExecution = function() {};
    r.unstable_requestPaint = ie;
    r.unstable_runWithPriority = function(e, n) {
        switch(e){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                e = 3;
        }
        var t = i;
        i = e;
        try {
            return n();
        } finally{
            i = t;
        }
    };
    r.unstable_scheduleCallback = function(e, n, t) {
        var l = r.unstable_now();
        switch(typeof t == "object" && t !== null ? (t = t.delay, t = typeof t == "number" && 0 < t ? l + t : l) : t = l, e){
            case 1:
                var o = -1;
                break;
            case 2:
                o = 250;
                break;
            case 5:
                o = 1073741823;
                break;
            case 4:
                o = 1e4;
                break;
            default:
                o = 5e3;
        }
        return o = t + o, e = {
            id: oe++,
            callback: n,
            priorityLevel: e,
            startTime: t,
            expirationTime: o,
            sortIndex: -1
        }, t > l ? (e.sortIndex = t, Y(c, e), u(s) === null && e === u(c) && (k ? g() : k = !0, m(W, t - l))) : (e.sortIndex = o, Y(s, e), p || M || (p = !0, d(O))), e;
    };
    r.unstable_wrapCallback = function(e) {
        var n = i;
        return function() {
            var t = i;
            i = n;
            try {
                return e.apply(this, arguments);
            } finally{
                i = t;
            }
        };
    };
});
var V2 = H2((se, A)=>{
    "use strict";
    A.exports = $2();
});
var D1 = J4(V2()), z3 = J4(V2()), { unstable_now: ce1 , unstable_shouldYield: fe1 , unstable_IdlePriority: be1 , unstable_ImmediatePriority: pe3 , unstable_LowPriority: _e2 , unstable_NormalPriority: de2 , unstable_Profiling: ye2 , unstable_UserBlockingPriority: ve1 , unstable_cancelCallback: me2 , unstable_continueExecution: we1 , unstable_getCurrentPriorityLevel: he1 , unstable_getFirstCallbackNode: ke1 , unstable_next: ge1 , unstable_pauseExecution: Pe1 , unstable_requestPaint: xe1 , unstable_runWithPriority: Te , unstable_scheduleCallback: Ie1 , unstable_wrapCallback: Me1  } = z3, Ce2 = D1.default || z3;
var Ps = Object.create;
var Or = Object.defineProperty;
var Ts = Object.getOwnPropertyDescriptor;
var Ls = Object.getOwnPropertyNames;
var zs = Object.getPrototypeOf, Os = Object.prototype.hasOwnProperty;
var Ms = (e)=>Or(e, "__esModule", {
        value: !0
    });
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (n, t)=>(typeof require != "undefined" ? require : n)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var Ri = (e, n)=>()=>(n || e((n = {
            exports: {}
        }).exports, n), n.exports);
var Rs = (e, n, t, r)=>{
    if (n && typeof n == "object" || typeof n == "function") for (let l of Ls(n))!Os.call(e, l) && (t || l !== "default") && Or(e, l, {
        get: ()=>n[l],
        enumerable: !(r = Ts(n, l)) || r.enumerable
    });
    return e;
}, Di = (e, n)=>Rs(Ms(Or(e != null ? Ps(zs(e)) : {}, "default", !n && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var Es = Ri((ie)=>{
    "use strict";
    var _t = Me, M = x, U = Ce2;
    function v(e) {
        for(var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, t = 1; t < arguments.length; t++)n += "&args[]=" + encodeURIComponent(arguments[t]);
        return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!_t) throw Error(v(227));
    var Ii = new Set, On = {};
    function He(e, n) {
        nn(e, n), nn(e + "Capture", n);
    }
    function nn(e, n) {
        for(On[e] = n, e = 0; e < n.length; e++)Ii.add(n[e]);
    }
    var me = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined"), Ds = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Fi = Object.prototype.hasOwnProperty, ji = {}, Ui = {};
    function Is(e) {
        return Fi.call(Ui, e) ? !0 : Fi.call(ji, e) ? !1 : Ds.test(e) ? Ui[e] = !0 : (ji[e] = !0, !1);
    }
    function Fs(e, n, t, r) {
        if (t !== null && t.type === 0) return !1;
        switch(typeof n){
            case "function":
            case "symbol":
                return !0;
            case "boolean":
                return r ? !1 : t !== null ? !t.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
            default:
                return !1;
        }
    }
    function js(e, n, t, r) {
        if (n === null || typeof n == "undefined" || Fs(e, n, t, r)) return !0;
        if (r) return !1;
        if (t !== null) switch(t.type){
            case 3:
                return !n;
            case 4:
                return n === !1;
            case 5:
                return isNaN(n);
            case 6:
                return isNaN(n) || 1 > n;
        }
        return !1;
    }
    function Y(e, n, t, r, l, i, o) {
        this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = r, this.attributeNamespace = l, this.mustUseProperty = t, this.propertyName = e, this.type = n, this.sanitizeURL = i, this.removeEmptyString = o;
    }
    var V = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
        V[e] = new Y(e, 0, !1, e, null, !1, !1);
    });
    [
        [
            "acceptCharset",
            "accept-charset"
        ],
        [
            "className",
            "class"
        ],
        [
            "htmlFor",
            "for"
        ],
        [
            "httpEquiv",
            "http-equiv"
        ]
    ].forEach(function(e) {
        var n = e[0];
        V[n] = new Y(n, 1, !1, e[1], null, !1, !1);
    });
    [
        "contentEditable",
        "draggable",
        "spellCheck",
        "value"
    ].forEach(function(e) {
        V[e] = new Y(e, 2, !1, e.toLowerCase(), null, !1, !1);
    });
    [
        "autoReverse",
        "externalResourcesRequired",
        "focusable",
        "preserveAlpha"
    ].forEach(function(e) {
        V[e] = new Y(e, 2, !1, e, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
        V[e] = new Y(e, 3, !1, e.toLowerCase(), null, !1, !1);
    });
    [
        "checked",
        "multiple",
        "muted",
        "selected"
    ].forEach(function(e) {
        V[e] = new Y(e, 3, !0, e, null, !1, !1);
    });
    [
        "capture",
        "download"
    ].forEach(function(e) {
        V[e] = new Y(e, 4, !1, e, null, !1, !1);
    });
    [
        "cols",
        "rows",
        "size",
        "span"
    ].forEach(function(e) {
        V[e] = new Y(e, 6, !1, e, null, !1, !1);
    });
    [
        "rowSpan",
        "start"
    ].forEach(function(e) {
        V[e] = new Y(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
    var Rr = /[\-:]([a-z])/g;
    function Dr(e) {
        return e[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
        var n = e.replace(Rr, Dr);
        V[n] = new Y(n, 1, !1, e, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
        var n = e.replace(Rr, Dr);
        V[n] = new Y(n, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
    });
    [
        "xml:base",
        "xml:lang",
        "xml:space"
    ].forEach(function(e) {
        var n = e.replace(Rr, Dr);
        V[n] = new Y(n, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    [
        "tabIndex",
        "crossOrigin"
    ].forEach(function(e) {
        V[e] = new Y(e, 1, !1, e.toLowerCase(), null, !1, !1);
    });
    V.xlinkHref = new Y("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    [
        "src",
        "href",
        "action",
        "formAction"
    ].forEach(function(e) {
        V[e] = new Y(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
    function Ir(e, n, t, r) {
        var l = V.hasOwnProperty(n) ? V[n] : null, i = l !== null ? l.type === 0 : r ? !1 : !(!(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N");
        i || (js(n, t, l, r) && (t = null), r || l === null ? Is(n) && (t === null ? e.removeAttribute(n) : e.setAttribute(n, "" + t)) : l.mustUseProperty ? e[l.propertyName] = t === null ? l.type === 3 ? !1 : "" : t : (n = l.attributeName, r = l.attributeNamespace, t === null ? e.removeAttribute(n) : (l = l.type, t = l === 3 || l === 4 && t === !0 ? "" : "" + t, r ? e.setAttributeNS(r, n, t) : e.setAttribute(n, t))));
    }
    var We = _t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Mn = 60103, Ae = 60106, Ee = 60107, Fr = 60108, Rn = 60114, jr = 60109, Ur = 60110, Nt = 60112, Dn = 60113, Pt = 60120, Tt = 60115, Vr = 60116, Br = 60121, Hr = 60128, Vi = 60129, Wr = 60130, Ar = 60131;
    typeof Symbol == "function" && Symbol.for && (F = Symbol.for, Mn = F("react.element"), Ae = F("react.portal"), Ee = F("react.fragment"), Fr = F("react.strict_mode"), Rn = F("react.profiler"), jr = F("react.provider"), Ur = F("react.context"), Nt = F("react.forward_ref"), Dn = F("react.suspense"), Pt = F("react.suspense_list"), Tt = F("react.memo"), Vr = F("react.lazy"), Br = F("react.block"), F("react.scope"), Hr = F("react.opaque.id"), Vi = F("react.debug_trace_mode"), Wr = F("react.offscreen"), Ar = F("react.legacy_hidden"));
    var F, Bi = typeof Symbol == "function" && Symbol.iterator;
    function In(e) {
        return e === null || typeof e != "object" ? null : (e = Bi && e[Bi] || e["@@iterator"], typeof e == "function" ? e : null);
    }
    var Qr;
    function Fn(e) {
        if (Qr === void 0) try {
            throw Error();
        } catch (t) {
            var n = t.stack.trim().match(/\n( *(at )?)/);
            Qr = n && n[1] || "";
        }
        return `
` + Qr + e;
    }
    var $r = !1;
    function Lt(e, n) {
        if (!e || $r) return "";
        $r = !0;
        var t = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (n) if (n = function() {
                throw Error();
            }, Object.defineProperty(n.prototype, "props", {
                set: function() {
                    throw Error();
                }
            }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(n, []);
                } catch (s) {
                    var r = s;
                }
                Reflect.construct(e, [], n);
            } else {
                try {
                    n.call();
                } catch (s1) {
                    r = s1;
                }
                e.call(n.prototype);
            }
            else {
                try {
                    throw Error();
                } catch (s2) {
                    r = s2;
                }
                e();
            }
        } catch (s3) {
            if (s3 && r && typeof s3.stack == "string") {
                for(var l = s3.stack.split(`
`), i = r.stack.split(`
`), o = l.length - 1, u = i.length - 1; 1 <= o && 0 <= u && l[o] !== i[u];)u--;
                for(; 1 <= o && 0 <= u; o--, u--)if (l[o] !== i[u]) {
                    if (o !== 1 || u !== 1) do if (o--, u--, 0 > u || l[o] !== i[u]) return `
` + l[o].replace(" at new ", " at ");
                    while (1 <= o && 0 <= u)
                    break;
                }
            }
        } finally{
            $r = !1, Error.prepareStackTrace = t;
        }
        return (e = e ? e.displayName || e.name : "") ? Fn(e) : "";
    }
    function Us(e) {
        switch(e.tag){
            case 5:
                return Fn(e.type);
            case 16:
                return Fn("Lazy");
            case 13:
                return Fn("Suspense");
            case 19:
                return Fn("SuspenseList");
            case 0:
            case 2:
            case 15:
                return e = Lt(e.type, !1), e;
            case 11:
                return e = Lt(e.type.render, !1), e;
            case 22:
                return e = Lt(e.type._render, !1), e;
            case 1:
                return e = Lt(e.type, !0), e;
            default:
                return "";
        }
    }
    function tn(e) {
        if (e == null) return null;
        if (typeof e == "function") return e.displayName || e.name || null;
        if (typeof e == "string") return e;
        switch(e){
            case Ee:
                return "Fragment";
            case Ae:
                return "Portal";
            case Rn:
                return "Profiler";
            case Fr:
                return "StrictMode";
            case Dn:
                return "Suspense";
            case Pt:
                return "SuspenseList";
        }
        if (typeof e == "object") switch(e.$$typeof){
            case Ur:
                return (e.displayName || "Context") + ".Consumer";
            case jr:
                return (e._context.displayName || "Context") + ".Provider";
            case Nt:
                var n = e.render;
                return n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
            case Tt:
                return tn(e.type);
            case Br:
                return tn(e._render);
            case Vr:
                n = e._payload, e = e._init;
                try {
                    return tn(e(n));
                } catch  {}
        }
        return null;
    }
    function ke(e) {
        switch(typeof e){
            case "boolean":
            case "number":
            case "object":
            case "string":
            case "undefined":
                return e;
            default:
                return "";
        }
    }
    function Hi(e) {
        var n = e.type;
        return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio");
    }
    function Vs(e) {
        var n = Hi(e) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), r = "" + e[n];
        if (!e.hasOwnProperty(n) && typeof t != "undefined" && typeof t.get == "function" && typeof t.set == "function") {
            var l = t.get, i = t.set;
            return Object.defineProperty(e, n, {
                configurable: !0,
                get: function() {
                    return l.call(this);
                },
                set: function(o) {
                    r = "" + o, i.call(this, o);
                }
            }), Object.defineProperty(e, n, {
                enumerable: t.enumerable
            }), {
                getValue: function() {
                    return r;
                },
                setValue: function(o) {
                    r = "" + o;
                },
                stopTracking: function() {
                    e._valueTracker = null, delete e[n];
                }
            };
        }
    }
    function zt(e) {
        e._valueTracker || (e._valueTracker = Vs(e));
    }
    function Wi(e) {
        if (!e) return !1;
        var n = e._valueTracker;
        if (!n) return !0;
        var t = n.getValue(), r = "";
        return e && (r = Hi(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== t ? (n.setValue(e), !0) : !1;
    }
    function Ot(e) {
        if (e = e || (typeof document != "undefined" ? document : void 0), typeof e == "undefined") return null;
        try {
            return e.activeElement || e.body;
        } catch  {
            return e.body;
        }
    }
    function Yr(e, n) {
        var t = n.checked;
        return M({}, n, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: t ?? e._wrapperState.initialChecked
        });
    }
    function Ai(e, n) {
        var t = n.defaultValue == null ? "" : n.defaultValue, r = n.checked != null ? n.checked : n.defaultChecked;
        t = ke(n.value != null ? n.value : t), e._wrapperState = {
            initialChecked: r,
            initialValue: t,
            controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null
        };
    }
    function Qi(e, n) {
        n = n.checked, n != null && Ir(e, "checked", n, !1);
    }
    function Xr(e, n) {
        Qi(e, n);
        var t = ke(n.value), r = n.type;
        if (t != null) r === "number" ? (t === 0 && e.value === "" || e.value != t) && (e.value = "" + t) : e.value !== "" + t && (e.value = "" + t);
        else if (r === "submit" || r === "reset") {
            e.removeAttribute("value");
            return;
        }
        n.hasOwnProperty("value") ? Kr(e, n.type, t) : n.hasOwnProperty("defaultValue") && Kr(e, n.type, ke(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked);
    }
    function $i(e, n, t) {
        if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) {
            var r = n.type;
            if (!(r !== "submit" && r !== "reset" || n.value !== void 0 && n.value !== null)) return;
            n = "" + e._wrapperState.initialValue, t || n === e.value || (e.value = n), e.defaultValue = n;
        }
        t = e.name, t !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, t !== "" && (e.name = t);
    }
    function Kr(e, n, t) {
        (n !== "number" || Ot(e.ownerDocument) !== e) && (t == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + t && (e.defaultValue = "" + t));
    }
    function Bs(e) {
        var n = "";
        return _t.Children.forEach(e, function(t) {
            t != null && (n += t);
        }), n;
    }
    function Gr(e, n) {
        return e = M({
            children: void 0
        }, n), (n = Bs(n.children)) && (e.children = n), e;
    }
    function rn(e, n, t, r) {
        if (e = e.options, n) {
            n = {};
            for(var l = 0; l < t.length; l++)n["$" + t[l]] = !0;
            for(t = 0; t < e.length; t++)l = n.hasOwnProperty("$" + e[t].value), e[t].selected !== l && (e[t].selected = l), l && r && (e[t].defaultSelected = !0);
        } else {
            for(t = "" + ke(t), n = null, l = 0; l < e.length; l++){
                if (e[l].value === t) {
                    e[l].selected = !0, r && (e[l].defaultSelected = !0);
                    return;
                }
                n !== null || e[l].disabled || (n = e[l]);
            }
            n !== null && (n.selected = !0);
        }
    }
    function Zr(e, n) {
        if (n.dangerouslySetInnerHTML != null) throw Error(v(91));
        return M({}, n, {
            value: void 0,
            defaultValue: void 0,
            children: "" + e._wrapperState.initialValue
        });
    }
    function Yi(e, n) {
        var t = n.value;
        if (t == null) {
            if (t = n.children, n = n.defaultValue, t != null) {
                if (n != null) throw Error(v(92));
                if (Array.isArray(t)) {
                    if (!(1 >= t.length)) throw Error(v(93));
                    t = t[0];
                }
                n = t;
            }
            n == null && (n = ""), t = n;
        }
        e._wrapperState = {
            initialValue: ke(t)
        };
    }
    function Xi(e, n) {
        var t = ke(n.value), r = ke(n.defaultValue);
        t != null && (t = "" + t, t !== e.value && (e.value = t), n.defaultValue == null && e.defaultValue !== t && (e.defaultValue = t)), r != null && (e.defaultValue = "" + r);
    }
    function Ki(e) {
        var n = e.textContent;
        n === e._wrapperState.initialValue && n !== "" && n !== null && (e.value = n);
    }
    var Jr = {
        html: "http://www.w3.org/1999/xhtml",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg"
    };
    function Gi(e) {
        switch(e){
            case "svg":
                return "http://www.w3.org/2000/svg";
            case "math":
                return "http://www.w3.org/1998/Math/MathML";
            default:
                return "http://www.w3.org/1999/xhtml";
        }
    }
    function qr(e, n) {
        return e == null || e === "http://www.w3.org/1999/xhtml" ? Gi(n) : e === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e;
    }
    var Mt, Zi = function(e) {
        return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function(n, t, r, l) {
            MSApp.execUnsafeLocalFunction(function() {
                return e(n, t, r, l);
            });
        } : e;
    }(function(e, n) {
        if (e.namespaceURI !== Jr.svg || "innerHTML" in e) e.innerHTML = n;
        else {
            for(Mt = Mt || document.createElement("div"), Mt.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = Mt.firstChild; e.firstChild;)e.removeChild(e.firstChild);
            for(; n.firstChild;)e.appendChild(n.firstChild);
        }
    });
    function jn(e, n) {
        if (n) {
            var t = e.firstChild;
            if (t && t === e.lastChild && t.nodeType === 3) {
                t.nodeValue = n;
                return;
            }
        }
        e.textContent = n;
    }
    var Un = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }, Hs = [
        "Webkit",
        "ms",
        "Moz",
        "O"
    ];
    Object.keys(Un).forEach(function(e) {
        Hs.forEach(function(n) {
            n = n + e.charAt(0).toUpperCase() + e.substring(1), Un[n] = Un[e];
        });
    });
    function Ji(e, n, t) {
        return n == null || typeof n == "boolean" || n === "" ? "" : t || typeof n != "number" || n === 0 || Un.hasOwnProperty(e) && Un[e] ? ("" + n).trim() : n + "px";
    }
    function qi(e, n) {
        e = e.style;
        for(var t in n)if (n.hasOwnProperty(t)) {
            var r = t.indexOf("--") === 0, l = Ji(t, n[t], r);
            t === "float" && (t = "cssFloat"), r ? e.setProperty(t, l) : e[t] = l;
        }
    }
    var Ws = M({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function br(e, n) {
        if (n) {
            if (Ws[e] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(v(137, e));
            if (n.dangerouslySetInnerHTML != null) {
                if (n.children != null) throw Error(v(60));
                if (!(typeof n.dangerouslySetInnerHTML == "object" && "__html" in n.dangerouslySetInnerHTML)) throw Error(v(61));
            }
            if (n.style != null && typeof n.style != "object") throw Error(v(62));
        }
    }
    function el(e, n) {
        if (e.indexOf("-") === -1) return typeof n.is == "string";
        switch(e){
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
                return !1;
            default:
                return !0;
        }
    }
    function nl(e) {
        return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
    }
    var tl = null, ln = null, on = null;
    function bi(e) {
        if (e = tt(e)) {
            if (typeof tl != "function") throw Error(v(280));
            var n = e.stateNode;
            n && (n = bt(n), tl(e.stateNode, e.type, n));
        }
    }
    function eo(e) {
        ln ? on ? on.push(e) : on = [
            e
        ] : ln = e;
    }
    function no() {
        if (ln) {
            var e = ln, n = on;
            if (on = ln = null, bi(e), n) for(e = 0; e < n.length; e++)bi(n[e]);
        }
    }
    function rl(e, n) {
        return e(n);
    }
    function to(e, n, t, r, l) {
        return e(n, t, r, l);
    }
    function ll() {}
    var ro = rl, Qe = !1, il = !1;
    function ol() {
        (ln !== null || on !== null) && (ll(), no());
    }
    function As(e, n, t) {
        if (il) return e(n, t);
        il = !0;
        try {
            return ro(e, n, t);
        } finally{
            il = !1, ol();
        }
    }
    function Vn(e, n) {
        var t = e.stateNode;
        if (t === null) return null;
        var r = bt(t);
        if (r === null) return null;
        t = r[n];
        e: switch(n){
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
                (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
                break e;
            default:
                e = !1;
        }
        if (e) return null;
        if (t && typeof t != "function") throw Error(v(231, n, typeof t));
        return t;
    }
    var ul = !1;
    if (me) try {
        un = {}, Object.defineProperty(un, "passive", {
            get: function() {
                ul = !0;
            }
        }), window.addEventListener("test", un, un), window.removeEventListener("test", un, un);
    } catch  {
        ul = !1;
    }
    var un;
    function Qs(e, n, t, r, l, i, o, u, s) {
        var d = Array.prototype.slice.call(arguments, 3);
        try {
            n.apply(t, d);
        } catch (y) {
            this.onError(y);
        }
    }
    var Bn = !1, Rt = null, Dt = !1, sl = null, $s = {
        onError: function(e) {
            Bn = !0, Rt = e;
        }
    };
    function Ys(e, n, t, r, l, i, o, u, s) {
        Bn = !1, Rt = null, Qs.apply($s, arguments);
    }
    function Xs(e, n, t, r, l, i, o, u, s) {
        if (Ys.apply(this, arguments), Bn) {
            if (Bn) {
                var d = Rt;
                Bn = !1, Rt = null;
            } else throw Error(v(198));
            Dt || (Dt = !0, sl = d);
        }
    }
    function $e(e) {
        var n = e, t = e;
        if (e.alternate) for(; n.return;)n = n.return;
        else {
            e = n;
            do n = e, (n.flags & 1026) !== 0 && (t = n.return), e = n.return;
            while (e)
        }
        return n.tag === 3 ? t : null;
    }
    function lo(e) {
        if (e.tag === 13) {
            var n = e.memoizedState;
            if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated;
        }
        return null;
    }
    function io(e) {
        if ($e(e) !== e) throw Error(v(188));
    }
    function Ks(e) {
        var n = e.alternate;
        if (!n) {
            if (n = $e(e), n === null) throw Error(v(188));
            return n !== e ? null : e;
        }
        for(var t = e, r = n;;){
            var l = t.return;
            if (l === null) break;
            var i = l.alternate;
            if (i === null) {
                if (r = l.return, r !== null) {
                    t = r;
                    continue;
                }
                break;
            }
            if (l.child === i.child) {
                for(i = l.child; i;){
                    if (i === t) return io(l), e;
                    if (i === r) return io(l), n;
                    i = i.sibling;
                }
                throw Error(v(188));
            }
            if (t.return !== r.return) t = l, r = i;
            else {
                for(var o = !1, u = l.child; u;){
                    if (u === t) {
                        o = !0, t = l, r = i;
                        break;
                    }
                    if (u === r) {
                        o = !0, r = l, t = i;
                        break;
                    }
                    u = u.sibling;
                }
                if (!o) {
                    for(u = i.child; u;){
                        if (u === t) {
                            o = !0, t = i, r = l;
                            break;
                        }
                        if (u === r) {
                            o = !0, r = i, t = l;
                            break;
                        }
                        u = u.sibling;
                    }
                    if (!o) throw Error(v(189));
                }
            }
            if (t.alternate !== r) throw Error(v(190));
        }
        if (t.tag !== 3) throw Error(v(188));
        return t.stateNode.current === t ? e : n;
    }
    function oo(e) {
        if (e = Ks(e), !e) return null;
        for(var n = e;;){
            if (n.tag === 5 || n.tag === 6) return n;
            if (n.child) n.child.return = n, n = n.child;
            else {
                if (n === e) break;
                for(; !n.sibling;){
                    if (!n.return || n.return === e) return null;
                    n = n.return;
                }
                n.sibling.return = n.return, n = n.sibling;
            }
        }
        return null;
    }
    function uo(e, n) {
        for(var t = e.alternate; n !== null;){
            if (n === e || n === t) return !0;
            n = n.return;
        }
        return !1;
    }
    var so, al, ao, fo, fl = !1, se = [], xe = null, Ce = null, _e = null, Hn = new Map, Wn = new Map, An = [], co = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function cl(e, n, t, r, l) {
        return {
            blockedOn: e,
            domEventName: n,
            eventSystemFlags: t | 16,
            nativeEvent: l,
            targetContainers: [
                r
            ]
        };
    }
    function po(e, n) {
        switch(e){
            case "focusin":
            case "focusout":
                xe = null;
                break;
            case "dragenter":
            case "dragleave":
                Ce = null;
                break;
            case "mouseover":
            case "mouseout":
                _e = null;
                break;
            case "pointerover":
            case "pointerout":
                Hn.delete(n.pointerId);
                break;
            case "gotpointercapture":
            case "lostpointercapture":
                Wn.delete(n.pointerId);
        }
    }
    function Qn(e, n, t, r, l, i) {
        return e === null || e.nativeEvent !== i ? (e = cl(n, t, r, l, i), n !== null && (n = tt(n), n !== null && al(n)), e) : (e.eventSystemFlags |= r, n = e.targetContainers, l !== null && n.indexOf(l) === -1 && n.push(l), e);
    }
    function Gs(e, n, t, r, l) {
        switch(n){
            case "focusin":
                return xe = Qn(xe, e, n, t, r, l), !0;
            case "dragenter":
                return Ce = Qn(Ce, e, n, t, r, l), !0;
            case "mouseover":
                return _e = Qn(_e, e, n, t, r, l), !0;
            case "pointerover":
                var i = l.pointerId;
                return Hn.set(i, Qn(Hn.get(i) || null, e, n, t, r, l)), !0;
            case "gotpointercapture":
                return i = l.pointerId, Wn.set(i, Qn(Wn.get(i) || null, e, n, t, r, l)), !0;
        }
        return !1;
    }
    function Zs(e) {
        var n = Ye(e.target);
        if (n !== null) {
            var t = $e(n);
            if (t !== null) {
                if (n = t.tag, n === 13) {
                    if (n = lo(t), n !== null) {
                        e.blockedOn = n, fo(e.lanePriority, function() {
                            U.unstable_runWithPriority(e.priority, function() {
                                ao(t);
                            });
                        });
                        return;
                    }
                } else if (n === 3 && t.stateNode.hydrate) {
                    e.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                    return;
                }
            }
        }
        e.blockedOn = null;
    }
    function It(e) {
        if (e.blockedOn !== null) return !1;
        for(var n = e.targetContainers; 0 < n.length;){
            var t = yl(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent);
            if (t !== null) return n = tt(t), n !== null && al(n), e.blockedOn = t, !1;
            n.shift();
        }
        return !0;
    }
    function mo(e, n, t) {
        It(e) && t.delete(n);
    }
    function Js() {
        for(fl = !1; 0 < se.length;){
            var e = se[0];
            if (e.blockedOn !== null) {
                e = tt(e.blockedOn), e !== null && so(e);
                break;
            }
            for(var n = e.targetContainers; 0 < n.length;){
                var t = yl(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent);
                if (t !== null) {
                    e.blockedOn = t;
                    break;
                }
                n.shift();
            }
            e.blockedOn === null && se.shift();
        }
        xe !== null && It(xe) && (xe = null), Ce !== null && It(Ce) && (Ce = null), _e !== null && It(_e) && (_e = null), Hn.forEach(mo), Wn.forEach(mo);
    }
    function $n(e, n) {
        e.blockedOn === n && (e.blockedOn = null, fl || (fl = !0, U.unstable_scheduleCallback(U.unstable_NormalPriority, Js)));
    }
    function ho(e) {
        function n(l) {
            return $n(l, e);
        }
        if (0 < se.length) {
            $n(se[0], e);
            for(var t = 1; t < se.length; t++){
                var r = se[t];
                r.blockedOn === e && (r.blockedOn = null);
            }
        }
        for(xe !== null && $n(xe, e), Ce !== null && $n(Ce, e), _e !== null && $n(_e, e), Hn.forEach(n), Wn.forEach(n), t = 0; t < An.length; t++)r = An[t], r.blockedOn === e && (r.blockedOn = null);
        for(; 0 < An.length && (t = An[0], t.blockedOn === null);)Zs(t), t.blockedOn === null && An.shift();
    }
    function Ft(e, n) {
        var t = {};
        return t[e.toLowerCase()] = n.toLowerCase(), t["Webkit" + e] = "webkit" + n, t["Moz" + e] = "moz" + n, t;
    }
    var sn = {
        animationend: Ft("Animation", "AnimationEnd"),
        animationiteration: Ft("Animation", "AnimationIteration"),
        animationstart: Ft("Animation", "AnimationStart"),
        transitionend: Ft("Transition", "TransitionEnd")
    }, dl = {}, vo = {};
    me && (vo = document.createElement("div").style, "AnimationEvent" in window || (delete sn.animationend.animation, delete sn.animationiteration.animation, delete sn.animationstart.animation), "TransitionEvent" in window || delete sn.transitionend.transition);
    function jt(e) {
        if (dl[e]) return dl[e];
        if (!sn[e]) return e;
        var n = sn[e], t;
        for(t in n)if (n.hasOwnProperty(t) && t in vo) return dl[e] = n[t];
        return e;
    }
    var yo = jt("animationend"), go = jt("animationiteration"), wo = jt("animationstart"), So = jt("transitionend"), Eo = new Map, pl = new Map, qs = [
        "abort",
        "abort",
        yo,
        "animationEnd",
        go,
        "animationIteration",
        wo,
        "animationStart",
        "canplay",
        "canPlay",
        "canplaythrough",
        "canPlayThrough",
        "durationchange",
        "durationChange",
        "emptied",
        "emptied",
        "encrypted",
        "encrypted",
        "ended",
        "ended",
        "error",
        "error",
        "gotpointercapture",
        "gotPointerCapture",
        "load",
        "load",
        "loadeddata",
        "loadedData",
        "loadedmetadata",
        "loadedMetadata",
        "loadstart",
        "loadStart",
        "lostpointercapture",
        "lostPointerCapture",
        "playing",
        "playing",
        "progress",
        "progress",
        "seeking",
        "seeking",
        "stalled",
        "stalled",
        "suspend",
        "suspend",
        "timeupdate",
        "timeUpdate",
        So,
        "transitionEnd",
        "waiting",
        "waiting"
    ];
    function ml(e, n) {
        for(var t = 0; t < e.length; t += 2){
            var r = e[t], l = e[t + 1];
            l = "on" + (l[0].toUpperCase() + l.slice(1)), pl.set(r, n), Eo.set(r, l), He(l, [
                r
            ]);
        }
    }
    var bs = U.unstable_now;
    bs();
    var L = 8;
    function an(e) {
        if ((1 & e) !== 0) return L = 15, 1;
        if ((2 & e) !== 0) return L = 14, 2;
        if ((4 & e) !== 0) return L = 13, 4;
        var n = 24 & e;
        return n !== 0 ? (L = 12, n) : (e & 32) !== 0 ? (L = 11, 32) : (n = 192 & e, n !== 0 ? (L = 10, n) : (e & 256) !== 0 ? (L = 9, 256) : (n = 3584 & e, n !== 0 ? (L = 8, n) : (e & 4096) !== 0 ? (L = 7, 4096) : (n = 4186112 & e, n !== 0 ? (L = 6, n) : (n = 62914560 & e, n !== 0 ? (L = 5, n) : e & 67108864 ? (L = 4, 67108864) : (e & 134217728) !== 0 ? (L = 3, 134217728) : (n = 805306368 & e, n !== 0 ? (L = 2, n) : (1073741824 & e) !== 0 ? (L = 1, 1073741824) : (L = 8, e))))));
    }
    function ea(e) {
        switch(e){
            case 99:
                return 15;
            case 98:
                return 10;
            case 97:
            case 96:
                return 8;
            case 95:
                return 2;
            default:
                return 0;
        }
    }
    function na(e) {
        switch(e){
            case 15:
            case 14:
                return 99;
            case 13:
            case 12:
            case 11:
            case 10:
                return 98;
            case 9:
            case 8:
            case 7:
            case 6:
            case 4:
            case 5:
                return 97;
            case 3:
            case 2:
            case 1:
                return 95;
            case 0:
                return 90;
            default:
                throw Error(v(358, e));
        }
    }
    function Yn(e, n) {
        var t = e.pendingLanes;
        if (t === 0) return L = 0;
        var r = 0, l = 0, i = e.expiredLanes, o = e.suspendedLanes, u = e.pingedLanes;
        if (i !== 0) r = i, l = L = 15;
        else if (i = t & 134217727, i !== 0) {
            var s = i & ~o;
            s !== 0 ? (r = an(s), l = L) : (u &= i, u !== 0 && (r = an(u), l = L));
        } else i = t & ~o, i !== 0 ? (r = an(i), l = L) : u !== 0 && (r = an(u), l = L);
        if (r === 0) return 0;
        if (r = 31 - Ne(r), r = t & ((0 > r ? 0 : 1 << r) << 1) - 1, n !== 0 && n !== r && (n & o) === 0) {
            if (an(n), l <= L) return n;
            L = l;
        }
        if (n = e.entangledLanes, n !== 0) for(e = e.entanglements, n &= r; 0 < n;)t = 31 - Ne(n), l = 1 << t, r |= e[t], n &= ~l;
        return r;
    }
    function ko(e) {
        return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0;
    }
    function Ut(e, n) {
        switch(e){
            case 15:
                return 1;
            case 14:
                return 2;
            case 12:
                return e = fn(24 & ~n), e === 0 ? Ut(10, n) : e;
            case 10:
                return e = fn(192 & ~n), e === 0 ? Ut(8, n) : e;
            case 8:
                return e = fn(3584 & ~n), e === 0 && (e = fn(4186112 & ~n), e === 0 && (e = 512)), e;
            case 2:
                return n = fn(805306368 & ~n), n === 0 && (n = 268435456), n;
        }
        throw Error(v(358, e));
    }
    function fn(e) {
        return e & -e;
    }
    function hl(e) {
        for(var n = [], t = 0; 31 > t; t++)n.push(e);
        return n;
    }
    function Vt(e, n, t) {
        e.pendingLanes |= n;
        var r = n - 1;
        e.suspendedLanes &= r, e.pingedLanes &= r, e = e.eventTimes, n = 31 - Ne(n), e[n] = t;
    }
    var Ne = Math.clz32 ? Math.clz32 : la, ta = Math.log, ra = Math.LN2;
    function la(e) {
        return e === 0 ? 32 : 31 - (ta(e) / ra | 0) | 0;
    }
    var ia = U.unstable_UserBlockingPriority, oa = U.unstable_runWithPriority, Bt = !0;
    function ua(e, n, t, r) {
        Qe || ll();
        var l = vl, i = Qe;
        Qe = !0;
        try {
            to(l, e, n, t, r);
        } finally{
            (Qe = i) || ol();
        }
    }
    function sa(e, n, t, r) {
        oa(ia, vl.bind(null, e, n, t, r));
    }
    function vl(e, n, t, r) {
        if (Bt) {
            var l;
            if ((l = (n & 4) === 0) && 0 < se.length && -1 < co.indexOf(e)) e = cl(null, e, n, t, r), se.push(e);
            else {
                var i = yl(e, n, t, r);
                if (i === null) l && po(e, r);
                else {
                    if (l) {
                        if (-1 < co.indexOf(e)) {
                            e = cl(i, e, n, t, r), se.push(e);
                            return;
                        }
                        if (Gs(i, e, n, t, r)) return;
                        po(e, r);
                    }
                    Zo(e, n, r, null, t);
                }
            }
        }
    }
    function yl(e, n, t, r) {
        var l = nl(r);
        if (l = Ye(l), l !== null) {
            var i = $e(l);
            if (i === null) l = null;
            else {
                var o = i.tag;
                if (o === 13) {
                    if (l = lo(i), l !== null) return l;
                    l = null;
                } else if (o === 3) {
                    if (i.stateNode.hydrate) return i.tag === 3 ? i.stateNode.containerInfo : null;
                    l = null;
                } else i !== l && (l = null);
            }
        }
        return Zo(e, n, r, l, t), null;
    }
    var Pe = null, gl = null, Ht = null;
    function xo() {
        if (Ht) return Ht;
        var e, n = gl, t = n.length, r, l = "value" in Pe ? Pe.value : Pe.textContent, i = l.length;
        for(e = 0; e < t && n[e] === l[e]; e++);
        var o = t - e;
        for(r = 1; r <= o && n[t - r] === l[i - r]; r++);
        return Ht = l.slice(e, 1 < r ? 1 - r : void 0);
    }
    function Wt(e) {
        var n = e.keyCode;
        return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
    }
    function At() {
        return !0;
    }
    function Co() {
        return !1;
    }
    function q(e) {
        function n(t, r, l, i, o) {
            this._reactName = t, this._targetInst = l, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null;
            for(var u in e)e.hasOwnProperty(u) && (t = e[u], this[u] = t ? t(i) : i[u]);
            return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? At : Co, this.isPropagationStopped = Co, this;
        }
        return M(n.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var t = this.nativeEvent;
                t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = At);
            },
            stopPropagation: function() {
                var t = this.nativeEvent;
                t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = At);
            },
            persist: function() {},
            isPersistent: At
        }), n;
    }
    var cn = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(e) {
            return e.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, wl = q(cn), Xn = M({}, cn, {
        view: 0,
        detail: 0
    }), aa = q(Xn), Sl, El, Kn, Qt = M({}, Xn, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: xl,
        button: 0,
        buttons: 0,
        relatedTarget: function(e) {
            return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
        },
        movementX: function(e) {
            return "movementX" in e ? e.movementX : (e !== Kn && (Kn && e.type === "mousemove" ? (Sl = e.screenX - Kn.screenX, El = e.screenY - Kn.screenY) : El = Sl = 0, Kn = e), Sl);
        },
        movementY: function(e) {
            return "movementY" in e ? e.movementY : El;
        }
    }), _o = q(Qt), fa = M({}, Qt, {
        dataTransfer: 0
    }), ca = q(fa), da = M({}, Xn, {
        relatedTarget: 0
    }), kl = q(da), pa = M({}, cn, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), ma = q(pa), ha = M({}, cn, {
        clipboardData: function(e) {
            return "clipboardData" in e ? e.clipboardData : window.clipboardData;
        }
    }), va = q(ha), ya = M({}, cn, {
        data: 0
    }), No = q(ya), ga = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, wa = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, Sa = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function Ea(e) {
        var n = this.nativeEvent;
        return n.getModifierState ? n.getModifierState(e) : (e = Sa[e]) ? !!n[e] : !1;
    }
    function xl() {
        return Ea;
    }
    var ka = M({}, Xn, {
        key: function(e) {
            if (e.key) {
                var n = ga[e.key] || e.key;
                if (n !== "Unidentified") return n;
            }
            return e.type === "keypress" ? (e = Wt(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? wa[e.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: xl,
        charCode: function(e) {
            return e.type === "keypress" ? Wt(e) : 0;
        },
        keyCode: function(e) {
            return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
        },
        which: function(e) {
            return e.type === "keypress" ? Wt(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
        }
    }), xa = q(ka), Ca = M({}, Qt, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }), Po = q(Ca), _a = M({}, Xn, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: xl
    }), Na = q(_a), Pa = M({}, cn, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), Ta = q(Pa), La = M({}, Qt, {
        deltaX: function(e) {
            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
        },
        deltaY: function(e) {
            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
    }), za = q(La), Oa = [
        9,
        13,
        27,
        32
    ], Cl = me && "CompositionEvent" in window, Gn = null;
    me && "documentMode" in document && (Gn = document.documentMode);
    var Ma = me && "TextEvent" in window && !Gn, To = me && (!Cl || Gn && 8 < Gn && 11 >= Gn), Lo = String.fromCharCode(32), zo = !1;
    function Oo(e, n) {
        switch(e){
            case "keyup":
                return Oa.indexOf(n.keyCode) !== -1;
            case "keydown":
                return n.keyCode !== 229;
            case "keypress":
            case "mousedown":
            case "focusout":
                return !0;
            default:
                return !1;
        }
    }
    function Mo(e) {
        return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
    }
    var dn = !1;
    function Ra(e, n) {
        switch(e){
            case "compositionend":
                return Mo(n);
            case "keypress":
                return n.which !== 32 ? null : (zo = !0, Lo);
            case "textInput":
                return e = n.data, e === Lo && zo ? null : e;
            default:
                return null;
        }
    }
    function Da(e, n) {
        if (dn) return e === "compositionend" || !Cl && Oo(e, n) ? (e = xo(), Ht = gl = Pe = null, dn = !1, e) : null;
        switch(e){
            case "paste":
                return null;
            case "keypress":
                if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) {
                    if (n.char && 1 < n.char.length) return n.char;
                    if (n.which) return String.fromCharCode(n.which);
                }
                return null;
            case "compositionend":
                return To && n.locale !== "ko" ? null : n.data;
            default:
                return null;
        }
    }
    var Ia = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function Ro(e) {
        var n = e && e.nodeName && e.nodeName.toLowerCase();
        return n === "input" ? !!Ia[e.type] : n === "textarea";
    }
    function Do(e, n, t, r) {
        eo(r), n = Gt(n, "onChange"), 0 < n.length && (t = new wl("onChange", "change", null, t, r), e.push({
            event: t,
            listeners: n
        }));
    }
    var Zn = null, Jn = null;
    function Fa(e) {
        $o(e, 0);
    }
    function $t(e) {
        var n = yn(e);
        if (Wi(n)) return e;
    }
    function ja(e, n) {
        if (e === "change") return n;
    }
    var Io = !1;
    me && (me ? (Xt = "oninput" in document, Xt || (_l = document.createElement("div"), _l.setAttribute("oninput", "return;"), Xt = typeof _l.oninput == "function"), Yt = Xt) : Yt = !1, Io = Yt && (!document.documentMode || 9 < document.documentMode));
    var Yt, Xt, _l;
    function Fo() {
        Zn && (Zn.detachEvent("onpropertychange", jo), Jn = Zn = null);
    }
    function jo(e) {
        if (e.propertyName === "value" && $t(Jn)) {
            var n = [];
            if (Do(n, Jn, e, nl(e)), e = Fa, Qe) e(n);
            else {
                Qe = !0;
                try {
                    rl(e, n);
                } finally{
                    Qe = !1, ol();
                }
            }
        }
    }
    function Ua(e, n, t) {
        e === "focusin" ? (Fo(), Zn = n, Jn = t, Zn.attachEvent("onpropertychange", jo)) : e === "focusout" && Fo();
    }
    function Va(e) {
        if (e === "selectionchange" || e === "keyup" || e === "keydown") return $t(Jn);
    }
    function Ba(e, n) {
        if (e === "click") return $t(n);
    }
    function Ha(e, n) {
        if (e === "input" || e === "change") return $t(n);
    }
    function Wa(e, n) {
        return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n;
    }
    var ee = typeof Object.is == "function" ? Object.is : Wa, Aa = Object.prototype.hasOwnProperty;
    function qn(e, n) {
        if (ee(e, n)) return !0;
        if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1;
        var t = Object.keys(e), r = Object.keys(n);
        if (t.length !== r.length) return !1;
        for(r = 0; r < t.length; r++)if (!Aa.call(n, t[r]) || !ee(e[t[r]], n[t[r]])) return !1;
        return !0;
    }
    function Uo(e) {
        for(; e && e.firstChild;)e = e.firstChild;
        return e;
    }
    function Vo(e, n) {
        var t = Uo(e);
        e = 0;
        for(var r; t;){
            if (t.nodeType === 3) {
                if (r = e + t.textContent.length, e <= n && r >= n) return {
                    node: t,
                    offset: n - e
                };
                e = r;
            }
            e: {
                for(; t;){
                    if (t.nextSibling) {
                        t = t.nextSibling;
                        break e;
                    }
                    t = t.parentNode;
                }
                t = void 0;
            }
            t = Uo(t);
        }
    }
    function Bo(e, n) {
        return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? Bo(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1;
    }
    function Ho() {
        for(var e = window, n = Ot(); n instanceof e.HTMLIFrameElement;){
            try {
                var t = typeof n.contentWindow.location.href == "string";
            } catch  {
                t = !1;
            }
            if (t) e = n.contentWindow;
            else break;
            n = Ot(e.document);
        }
        return n;
    }
    function Nl(e) {
        var n = e && e.nodeName && e.nodeName.toLowerCase();
        return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true");
    }
    var Qa = me && "documentMode" in document && 11 >= document.documentMode, pn = null, Pl = null, bn = null, Tl = !1;
    function Wo(e, n, t) {
        var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
        Tl || pn == null || pn !== Ot(r) || (r = pn, "selectionStart" in r && Nl(r) ? r = {
            start: r.selectionStart,
            end: r.selectionEnd
        } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
            anchorNode: r.anchorNode,
            anchorOffset: r.anchorOffset,
            focusNode: r.focusNode,
            focusOffset: r.focusOffset
        }), bn && qn(bn, r) || (bn = r, r = Gt(Pl, "onSelect"), 0 < r.length && (n = new wl("onSelect", "select", null, n, t), e.push({
            event: n,
            listeners: r
        }), n.target = pn)));
    }
    ml("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
    ml("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    ml(qs, 2);
    for(Ll = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), Kt = 0; Kt < Ll.length; Kt++)pl.set(Ll[Kt], 0);
    var Ll, Kt;
    nn("onMouseEnter", [
        "mouseout",
        "mouseover"
    ]);
    nn("onMouseLeave", [
        "mouseout",
        "mouseover"
    ]);
    nn("onPointerEnter", [
        "pointerout",
        "pointerover"
    ]);
    nn("onPointerLeave", [
        "pointerout",
        "pointerover"
    ]);
    He("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    He("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    He("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
    ]);
    He("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    He("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    He("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var et = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ao = new Set("cancel close invalid load scroll toggle".split(" ").concat(et));
    function Qo(e, n, t) {
        var r = e.type || "unknown-event";
        e.currentTarget = t, Xs(r, n, void 0, e), e.currentTarget = null;
    }
    function $o(e, n) {
        n = (n & 4) !== 0;
        for(var t = 0; t < e.length; t++){
            var r = e[t], l = r.event;
            r = r.listeners;
            e: {
                var i = void 0;
                if (n) for(var o = r.length - 1; 0 <= o; o--){
                    var u = r[o], s = u.instance, d = u.currentTarget;
                    if (u = u.listener, s !== i && l.isPropagationStopped()) break e;
                    Qo(l, u, d), i = s;
                }
                else for(o = 0; o < r.length; o++){
                    if (u = r[o], s = u.instance, d = u.currentTarget, u = u.listener, s !== i && l.isPropagationStopped()) break e;
                    Qo(l, u, d), i = s;
                }
            }
        }
        if (Dt) throw e = sl, Dt = !1, sl = null, e;
    }
    function z(e, n) {
        var t = tu(n), r = e + "__bubble";
        t.has(r) || (Go(n, e, 2, !1), t.add(r));
    }
    var Yo = "_reactListening" + Math.random().toString(36).slice(2);
    function Xo(e) {
        e[Yo] || (e[Yo] = !0, Ii.forEach(function(n) {
            Ao.has(n) || Ko(n, !1, e, null), Ko(n, !0, e, null);
        }));
    }
    function Ko(e, n, t, r) {
        var l = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, i = t;
        if (e === "selectionchange" && t.nodeType !== 9 && (i = t.ownerDocument), r !== null && !n && Ao.has(e)) {
            if (e !== "scroll") return;
            l |= 2, i = r;
        }
        var o = tu(i), u = e + "__" + (n ? "capture" : "bubble");
        o.has(u) || (n && (l |= 4), Go(i, e, l, n), o.add(u));
    }
    function Go(e, n, t, r) {
        var l = pl.get(n);
        switch(l === void 0 ? 2 : l){
            case 0:
                l = ua;
                break;
            case 1:
                l = sa;
                break;
            default:
                l = vl;
        }
        t = l.bind(null, n, t, e), l = void 0, !ul || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (l = !0), r ? l !== void 0 ? e.addEventListener(n, t, {
            capture: !0,
            passive: l
        }) : e.addEventListener(n, t, !0) : l !== void 0 ? e.addEventListener(n, t, {
            passive: l
        }) : e.addEventListener(n, t, !1);
    }
    function Zo(e, n, t, r, l) {
        var i = r;
        if ((n & 1) === 0 && (n & 2) === 0 && r !== null) e: for(;;){
            if (r === null) return;
            var o = r.tag;
            if (o === 3 || o === 4) {
                var u = r.stateNode.containerInfo;
                if (u === l || u.nodeType === 8 && u.parentNode === l) break;
                if (o === 4) for(o = r.return; o !== null;){
                    var s = o.tag;
                    if ((s === 3 || s === 4) && (s = o.stateNode.containerInfo, s === l || s.nodeType === 8 && s.parentNode === l)) return;
                    o = o.return;
                }
                for(; u !== null;){
                    if (o = Ye(u), o === null) return;
                    if (s = o.tag, s === 5 || s === 6) {
                        r = i = o;
                        continue e;
                    }
                    u = u.parentNode;
                }
            }
            r = r.return;
        }
        As(function() {
            var d = i, y = nl(t), C = [];
            e: {
                var h = Eo.get(e);
                if (h !== void 0) {
                    var S = wl, k = e;
                    switch(e){
                        case "keypress":
                            if (Wt(t) === 0) break e;
                        case "keydown":
                        case "keyup":
                            S = xa;
                            break;
                        case "focusin":
                            k = "focus", S = kl;
                            break;
                        case "focusout":
                            k = "blur", S = kl;
                            break;
                        case "beforeblur":
                        case "afterblur":
                            S = kl;
                            break;
                        case "click":
                            if (t.button === 2) break e;
                        case "auxclick":
                        case "dblclick":
                        case "mousedown":
                        case "mousemove":
                        case "mouseup":
                        case "mouseout":
                        case "mouseover":
                        case "contextmenu":
                            S = _o;
                            break;
                        case "drag":
                        case "dragend":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "dragstart":
                        case "drop":
                            S = ca;
                            break;
                        case "touchcancel":
                        case "touchend":
                        case "touchmove":
                        case "touchstart":
                            S = Na;
                            break;
                        case yo:
                        case go:
                        case wo:
                            S = ma;
                            break;
                        case So:
                            S = Ta;
                            break;
                        case "scroll":
                            S = aa;
                            break;
                        case "wheel":
                            S = za;
                            break;
                        case "copy":
                        case "cut":
                        case "paste":
                            S = va;
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerup":
                            S = Po;
                    }
                    var E = (n & 4) !== 0, c = !E && e === "scroll", a = E ? h !== null ? h + "Capture" : null : h;
                    E = [];
                    for(var f = d, p; f !== null;){
                        p = f;
                        var m = p.stateNode;
                        if (p.tag === 5 && m !== null && (p = m, a !== null && (m = Vn(f, a), m != null && E.push(nt(f, m, p)))), c) break;
                        f = f.return;
                    }
                    0 < E.length && (h = new S(h, k, null, t, y), C.push({
                        event: h,
                        listeners: E
                    }));
                }
            }
            if ((n & 7) === 0) {
                e: {
                    if (h = e === "mouseover" || e === "pointerover", S = e === "mouseout" || e === "pointerout", h && (n & 16) === 0 && (k = t.relatedTarget || t.fromElement) && (Ye(k) || k[vn])) break e;
                    if ((S || h) && (h = y.window === y ? y : (h = y.ownerDocument) ? h.defaultView || h.parentWindow : window, S ? (k = t.relatedTarget || t.toElement, S = d, k = k ? Ye(k) : null, k !== null && (c = $e(k), k !== c || k.tag !== 5 && k.tag !== 6) && (k = null)) : (S = null, k = d), S !== k)) {
                        if (E = _o, m = "onMouseLeave", a = "onMouseEnter", f = "mouse", (e === "pointerout" || e === "pointerover") && (E = Po, m = "onPointerLeave", a = "onPointerEnter", f = "pointer"), c = S == null ? h : yn(S), p = k == null ? h : yn(k), h = new E(m, f + "leave", S, t, y), h.target = c, h.relatedTarget = p, m = null, Ye(y) === d && (E = new E(a, f + "enter", k, t, y), E.target = p, E.relatedTarget = c, m = E), c = m, S && k) n: {
                            for(E = S, a = k, f = 0, p = E; p; p = mn(p))f++;
                            for(p = 0, m = a; m; m = mn(m))p++;
                            for(; 0 < f - p;)E = mn(E), f--;
                            for(; 0 < p - f;)a = mn(a), p--;
                            for(; f--;){
                                if (E === a || a !== null && E === a.alternate) break n;
                                E = mn(E), a = mn(a);
                            }
                            E = null;
                        }
                        else E = null;
                        S !== null && Jo(C, h, S, E, !1), k !== null && c !== null && Jo(C, c, k, E, !0);
                    }
                }
                e: {
                    if (h = d ? yn(d) : window, S = h.nodeName && h.nodeName.toLowerCase(), S === "select" || S === "input" && h.type === "file") var _ = ja;
                    else if (Ro(h)) if (Io) _ = Ha;
                    else {
                        _ = Va;
                        var w = Ua;
                    }
                    else (S = h.nodeName) && S.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (_ = Ba);
                    if (_ && (_ = _(e, d))) {
                        Do(C, _, t, y);
                        break e;
                    }
                    w && w(e, h, d), e === "focusout" && (w = h._wrapperState) && w.controlled && h.type === "number" && Kr(h, "number", h.value);
                }
                switch(w = d ? yn(d) : window, e){
                    case "focusin":
                        (Ro(w) || w.contentEditable === "true") && (pn = w, Pl = d, bn = null);
                        break;
                    case "focusout":
                        bn = Pl = pn = null;
                        break;
                    case "mousedown":
                        Tl = !0;
                        break;
                    case "contextmenu":
                    case "mouseup":
                    case "dragend":
                        Tl = !1, Wo(C, t, y);
                        break;
                    case "selectionchange":
                        if (Qa) break;
                    case "keydown":
                    case "keyup":
                        Wo(C, t, y);
                }
                var N;
                if (Cl) e: {
                    switch(e){
                        case "compositionstart":
                            var T = "onCompositionStart";
                            break e;
                        case "compositionend":
                            T = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            T = "onCompositionUpdate";
                            break e;
                    }
                    T = void 0;
                }
                else dn ? Oo(e, t) && (T = "onCompositionEnd") : e === "keydown" && t.keyCode === 229 && (T = "onCompositionStart");
                T && (To && t.locale !== "ko" && (dn || T !== "onCompositionStart" ? T === "onCompositionEnd" && dn && (N = xo()) : (Pe = y, gl = "value" in Pe ? Pe.value : Pe.textContent, dn = !0)), w = Gt(d, T), 0 < w.length && (T = new No(T, e, null, t, y), C.push({
                    event: T,
                    listeners: w
                }), N ? T.data = N : (N = Mo(t), N !== null && (T.data = N)))), (N = Ma ? Ra(e, t) : Da(e, t)) && (d = Gt(d, "onBeforeInput"), 0 < d.length && (y = new No("onBeforeInput", "beforeinput", null, t, y), C.push({
                    event: y,
                    listeners: d
                }), y.data = N));
            }
            $o(C, n);
        });
    }
    function nt(e, n, t) {
        return {
            instance: e,
            listener: n,
            currentTarget: t
        };
    }
    function Gt(e, n) {
        for(var t = n + "Capture", r = []; e !== null;){
            var l = e, i = l.stateNode;
            l.tag === 5 && i !== null && (l = i, i = Vn(e, t), i != null && r.unshift(nt(e, i, l)), i = Vn(e, n), i != null && r.push(nt(e, i, l))), e = e.return;
        }
        return r;
    }
    function mn(e) {
        if (e === null) return null;
        do e = e.return;
        while (e && e.tag !== 5)
        return e || null;
    }
    function Jo(e, n, t, r, l) {
        for(var i = n._reactName, o = []; t !== null && t !== r;){
            var u = t, s = u.alternate, d = u.stateNode;
            if (s !== null && s === r) break;
            u.tag === 5 && d !== null && (u = d, l ? (s = Vn(t, i), s != null && o.unshift(nt(t, s, u))) : l || (s = Vn(t, i), s != null && o.push(nt(t, s, u)))), t = t.return;
        }
        o.length !== 0 && e.push({
            event: n,
            listeners: o
        });
    }
    function Zt() {}
    var zl = null, Ol = null;
    function qo(e, n) {
        switch(e){
            case "button":
            case "input":
            case "select":
            case "textarea":
                return !!n.autoFocus;
        }
        return !1;
    }
    function Ml(e, n) {
        return e === "textarea" || e === "option" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null;
    }
    var bo = typeof setTimeout == "function" ? setTimeout : void 0, $a = typeof clearTimeout == "function" ? clearTimeout : void 0;
    function Rl(e) {
        e.nodeType === 1 ? e.textContent = "" : e.nodeType === 9 && (e = e.body, e != null && (e.textContent = ""));
    }
    function hn(e) {
        for(; e != null; e = e.nextSibling){
            var n = e.nodeType;
            if (n === 1 || n === 3) break;
        }
        return e;
    }
    function eu(e) {
        e = e.previousSibling;
        for(var n = 0; e;){
            if (e.nodeType === 8) {
                var t = e.data;
                if (t === "$" || t === "$!" || t === "$?") {
                    if (n === 0) return e;
                    n--;
                } else t === "/$" && n++;
            }
            e = e.previousSibling;
        }
        return null;
    }
    var Dl = 0;
    function Ya(e) {
        return {
            $$typeof: Hr,
            toString: e,
            valueOf: e
        };
    }
    var Jt = Math.random().toString(36).slice(2), Te = "__reactFiber$" + Jt, qt = "__reactProps$" + Jt, vn = "__reactContainer$" + Jt, nu = "__reactEvents$" + Jt;
    function Ye(e) {
        var n = e[Te];
        if (n) return n;
        for(var t = e.parentNode; t;){
            if (n = t[vn] || t[Te]) {
                if (t = n.alternate, n.child !== null || t !== null && t.child !== null) for(e = eu(e); e !== null;){
                    if (t = e[Te]) return t;
                    e = eu(e);
                }
                return n;
            }
            e = t, t = e.parentNode;
        }
        return null;
    }
    function tt(e) {
        return e = e[Te] || e[vn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e;
    }
    function yn(e) {
        if (e.tag === 5 || e.tag === 6) return e.stateNode;
        throw Error(v(33));
    }
    function bt(e) {
        return e[qt] || null;
    }
    function tu(e) {
        var n = e[nu];
        return n === void 0 && (n = e[nu] = new Set), n;
    }
    var Il = [], gn = -1;
    function Le(e) {
        return {
            current: e
        };
    }
    function O(e) {
        0 > gn || (e.current = Il[gn], Il[gn] = null, gn--);
    }
    function R(e, n) {
        gn++, Il[gn] = e.current, e.current = n;
    }
    var ze = {}, W = Le(ze), K = Le(!1), Xe = ze;
    function wn(e, n) {
        var t = e.type.contextTypes;
        if (!t) return ze;
        var r = e.stateNode;
        if (r && r.__reactInternalMemoizedUnmaskedChildContext === n) return r.__reactInternalMemoizedMaskedChildContext;
        var l = {}, i;
        for(i in t)l[i] = n[i];
        return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = l), l;
    }
    function G(e) {
        return e = e.childContextTypes, e != null;
    }
    function er() {
        O(K), O(W);
    }
    function ru(e, n, t) {
        if (W.current !== ze) throw Error(v(168));
        R(W, n), R(K, t);
    }
    function lu(e, n, t) {
        var r = e.stateNode;
        if (e = n.childContextTypes, typeof r.getChildContext != "function") return t;
        r = r.getChildContext();
        for(var l in r)if (!(l in e)) throw Error(v(108, tn(n) || "Unknown", l));
        return M({}, t, r);
    }
    function nr(e) {
        return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ze, Xe = W.current, R(W, e), R(K, K.current), !0;
    }
    function iu(e, n, t) {
        var r = e.stateNode;
        if (!r) throw Error(v(169));
        t ? (e = lu(e, n, Xe), r.__reactInternalMemoizedMergedChildContext = e, O(K), O(W), R(W, e)) : O(K), R(K, t);
    }
    var Fl = null, Ke = null, Xa = U.unstable_runWithPriority, jl = U.unstable_scheduleCallback, Ul = U.unstable_cancelCallback, Ka = U.unstable_shouldYield, ou = U.unstable_requestPaint, Vl = U.unstable_now, Ga = U.unstable_getCurrentPriorityLevel, tr = U.unstable_ImmediatePriority, uu = U.unstable_UserBlockingPriority, su = U.unstable_NormalPriority, au = U.unstable_LowPriority, fu = U.unstable_IdlePriority, Bl = {}, Za = ou !== void 0 ? ou : function() {}, he = null, rr = null, Hl = !1, cu = Vl(), A = 1e4 > cu ? Vl : function() {
        return Vl() - cu;
    };
    function Sn() {
        switch(Ga()){
            case tr:
                return 99;
            case uu:
                return 98;
            case su:
                return 97;
            case au:
                return 96;
            case fu:
                return 95;
            default:
                throw Error(v(332));
        }
    }
    function du(e) {
        switch(e){
            case 99:
                return tr;
            case 98:
                return uu;
            case 97:
                return su;
            case 96:
                return au;
            case 95:
                return fu;
            default:
                throw Error(v(332));
        }
    }
    function Ge(e, n) {
        return e = du(e), Xa(e, n);
    }
    function rt(e, n, t) {
        return e = du(e), jl(e, n, t);
    }
    function ae() {
        if (rr !== null) {
            var e = rr;
            rr = null, Ul(e);
        }
        pu();
    }
    function pu() {
        if (!Hl && he !== null) {
            Hl = !0;
            var e = 0;
            try {
                var n = he;
                Ge(99, function() {
                    for(; e < n.length; e++){
                        var t = n[e];
                        do t = t(!0);
                        while (t !== null)
                    }
                }), he = null;
            } catch (t) {
                throw he !== null && (he = he.slice(e + 1)), jl(tr, ae), t;
            } finally{
                Hl = !1;
            }
        }
    }
    var Ja = We.ReactCurrentBatchConfig;
    function oe(e, n) {
        if (e && e.defaultProps) {
            n = M({}, n), e = e.defaultProps;
            for(var t in e)n[t] === void 0 && (n[t] = e[t]);
            return n;
        }
        return n;
    }
    var lr = Le(null), ir = null, En = null, or = null;
    function Wl() {
        or = En = ir = null;
    }
    function Al(e) {
        var n = lr.current;
        O(lr), e.type._context._currentValue = n;
    }
    function mu(e, n) {
        for(; e !== null;){
            var t = e.alternate;
            if ((e.childLanes & n) === n) {
                if (t === null || (t.childLanes & n) === n) break;
                t.childLanes |= n;
            } else e.childLanes |= n, t !== null && (t.childLanes |= n);
            e = e.return;
        }
    }
    function kn(e, n) {
        ir = e, or = En = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & n) !== 0 && (ue = !0), e.firstContext = null);
    }
    function ne(e, n) {
        if (or !== e && n !== !1 && n !== 0) if ((typeof n != "number" || n === 1073741823) && (or = e, n = 1073741823), n = {
            context: e,
            observedBits: n,
            next: null
        }, En === null) {
            if (ir === null) throw Error(v(308));
            En = n, ir.dependencies = {
                lanes: 0,
                firstContext: n,
                responders: null
            };
        } else En = En.next = n;
        return e._currentValue;
    }
    var Oe = !1;
    function Ql(e) {
        e.updateQueue = {
            baseState: e.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null
            },
            effects: null
        };
    }
    function hu(e, n) {
        e = e.updateQueue, n.updateQueue === e && (n.updateQueue = {
            baseState: e.baseState,
            firstBaseUpdate: e.firstBaseUpdate,
            lastBaseUpdate: e.lastBaseUpdate,
            shared: e.shared,
            effects: e.effects
        });
    }
    function Me1(e, n) {
        return {
            eventTime: e,
            lane: n,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        };
    }
    function Re(e, n) {
        if (e = e.updateQueue, e !== null) {
            e = e.shared;
            var t = e.pending;
            t === null ? n.next = n : (n.next = t.next, t.next = n), e.pending = n;
        }
    }
    function vu(e, n) {
        var t = e.updateQueue, r = e.alternate;
        if (r !== null && (r = r.updateQueue, t === r)) {
            var l = null, i = null;
            if (t = t.firstBaseUpdate, t !== null) {
                do {
                    var o = {
                        eventTime: t.eventTime,
                        lane: t.lane,
                        tag: t.tag,
                        payload: t.payload,
                        callback: t.callback,
                        next: null
                    };
                    i === null ? l = i = o : i = i.next = o, t = t.next;
                }while (t !== null)
                i === null ? l = i = n : i = i.next = n;
            } else l = i = n;
            t = {
                baseState: r.baseState,
                firstBaseUpdate: l,
                lastBaseUpdate: i,
                shared: r.shared,
                effects: r.effects
            }, e.updateQueue = t;
            return;
        }
        e = t.lastBaseUpdate, e === null ? t.firstBaseUpdate = n : e.next = n, t.lastBaseUpdate = n;
    }
    function lt(e, n, t, r) {
        var l = e.updateQueue;
        Oe = !1;
        var i = l.firstBaseUpdate, o = l.lastBaseUpdate, u = l.shared.pending;
        if (u !== null) {
            l.shared.pending = null;
            var s = u, d = s.next;
            s.next = null, o === null ? i = d : o.next = d, o = s;
            var y = e.alternate;
            if (y !== null) {
                y = y.updateQueue;
                var C = y.lastBaseUpdate;
                C !== o && (C === null ? y.firstBaseUpdate = d : C.next = d, y.lastBaseUpdate = s);
            }
        }
        if (i !== null) {
            C = l.baseState, o = 0, y = d = s = null;
            do {
                u = i.lane;
                var h = i.eventTime;
                if ((r & u) === u) {
                    y !== null && (y = y.next = {
                        eventTime: h,
                        lane: 0,
                        tag: i.tag,
                        payload: i.payload,
                        callback: i.callback,
                        next: null
                    });
                    e: {
                        var S = e, k = i;
                        switch(u = n, h = t, k.tag){
                            case 1:
                                if (S = k.payload, typeof S == "function") {
                                    C = S.call(h, C, u);
                                    break e;
                                }
                                C = S;
                                break e;
                            case 3:
                                S.flags = S.flags & -4097 | 64;
                            case 0:
                                if (S = k.payload, u = typeof S == "function" ? S.call(h, C, u) : S, u == null) break e;
                                C = M({}, C, u);
                                break e;
                            case 2:
                                Oe = !0;
                        }
                    }
                    i.callback !== null && (e.flags |= 32, u = l.effects, u === null ? l.effects = [
                        i
                    ] : u.push(i));
                } else h = {
                    eventTime: h,
                    lane: u,
                    tag: i.tag,
                    payload: i.payload,
                    callback: i.callback,
                    next: null
                }, y === null ? (d = y = h, s = C) : y = y.next = h, o |= u;
                if (i = i.next, i === null) {
                    if (u = l.shared.pending, u === null) break;
                    i = u.next, u.next = null, l.lastBaseUpdate = u, l.shared.pending = null;
                }
            }while (1)
            y === null && (s = C), l.baseState = s, l.firstBaseUpdate = d, l.lastBaseUpdate = y, vt |= o, e.lanes = o, e.memoizedState = C;
        }
    }
    function yu(e, n, t) {
        if (e = n.effects, n.effects = null, e !== null) for(n = 0; n < e.length; n++){
            var r = e[n], l = r.callback;
            if (l !== null) {
                if (r.callback = null, r = t, typeof l != "function") throw Error(v(191, l));
                l.call(r);
            }
        }
    }
    var gu = new _t.Component().refs;
    function ur(e, n, t, r) {
        n = e.memoizedState, t = t(r, n), t = t == null ? n : M({}, n, t), e.memoizedState = t, e.lanes === 0 && (e.updateQueue.baseState = t);
    }
    var sr = {
        isMounted: function(e) {
            return (e = e._reactInternals) ? $e(e) === e : !1;
        },
        enqueueSetState: function(e, n, t) {
            e = e._reactInternals;
            var r = b(), l = Fe(e), i = Me1(r, l);
            i.payload = n, t != null && (i.callback = t), Re(e, i), je(e, l, r);
        },
        enqueueReplaceState: function(e, n, t) {
            e = e._reactInternals;
            var r = b(), l = Fe(e), i = Me1(r, l);
            i.tag = 1, i.payload = n, t != null && (i.callback = t), Re(e, i), je(e, l, r);
        },
        enqueueForceUpdate: function(e, n) {
            e = e._reactInternals;
            var t = b(), r = Fe(e), l = Me1(t, r);
            l.tag = 2, n != null && (l.callback = n), Re(e, l), je(e, r, t);
        }
    };
    function wu(e, n, t, r, l, i, o) {
        return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : n.prototype && n.prototype.isPureReactComponent ? !qn(t, r) || !qn(l, i) : !0;
    }
    function Su(e, n, t) {
        var r = !1, l = ze, i = n.contextType;
        return typeof i == "object" && i !== null ? i = ne(i) : (l = G(n) ? Xe : W.current, r = n.contextTypes, i = (r = r != null) ? wn(e, l) : ze), n = new n(t, i), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = sr, e.stateNode = n, n._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = l, e.__reactInternalMemoizedMaskedChildContext = i), n;
    }
    function Eu(e, n, t, r) {
        e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(t, r), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(t, r), n.state !== e && sr.enqueueReplaceState(n, n.state, null);
    }
    function $l(e, n, t, r) {
        var l = e.stateNode;
        l.props = t, l.state = e.memoizedState, l.refs = gu, Ql(e);
        var i = n.contextType;
        typeof i == "object" && i !== null ? l.context = ne(i) : (i = G(n) ? Xe : W.current, l.context = wn(e, i)), lt(e, t, l, r), l.state = e.memoizedState, i = n.getDerivedStateFromProps, typeof i == "function" && (ur(e, n, i, t), l.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof l.getSnapshotBeforeUpdate == "function" || typeof l.UNSAFE_componentWillMount != "function" && typeof l.componentWillMount != "function" || (n = l.state, typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount(), n !== l.state && sr.enqueueReplaceState(l, l.state, null), lt(e, t, l, r), l.state = e.memoizedState), typeof l.componentDidMount == "function" && (e.flags |= 4);
    }
    var ar = Array.isArray;
    function it(e, n, t) {
        if (e = t.ref, e !== null && typeof e != "function" && typeof e != "object") {
            if (t._owner) {
                if (t = t._owner, t) {
                    if (t.tag !== 1) throw Error(v(309));
                    var r = t.stateNode;
                }
                if (!r) throw Error(v(147, e));
                var l = "" + e;
                return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === l ? n.ref : (n = function(i) {
                    var o = r.refs;
                    o === gu && (o = r.refs = {}), i === null ? delete o[l] : o[l] = i;
                }, n._stringRef = l, n);
            }
            if (typeof e != "string") throw Error(v(284));
            if (!t._owner) throw Error(v(290, e));
        }
        return e;
    }
    function fr(e, n) {
        if (e.type !== "textarea") throw Error(v(31, Object.prototype.toString.call(n) === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : n));
    }
    function ku(e) {
        function n(c, a) {
            if (e) {
                var f = c.lastEffect;
                f !== null ? (f.nextEffect = a, c.lastEffect = a) : c.firstEffect = c.lastEffect = a, a.nextEffect = null, a.flags = 8;
            }
        }
        function t(c, a) {
            if (!e) return null;
            for(; a !== null;)n(c, a), a = a.sibling;
            return null;
        }
        function r(c, a) {
            for(c = new Map; a !== null;)a.key !== null ? c.set(a.key, a) : c.set(a.index, a), a = a.sibling;
            return c;
        }
        function l(c, a) {
            return c = Be(c, a), c.index = 0, c.sibling = null, c;
        }
        function i(c, a, f) {
            return c.index = f, e ? (f = c.alternate, f !== null ? (f = f.index, f < a ? (c.flags = 2, a) : f) : (c.flags = 2, a)) : a;
        }
        function o(c) {
            return e && c.alternate === null && (c.flags = 2), c;
        }
        function u(c, a, f, p) {
            return a === null || a.tag !== 6 ? (a = Pi(f, c.mode, p), a.return = c, a) : (a = l(a, f), a.return = c, a);
        }
        function s(c, a, f, p) {
            return a !== null && a.elementType === f.type ? (p = l(a, f.props), p.ref = it(c, a, f), p.return = c, p) : (p = Tr(f.type, f.key, f.props, null, c.mode, p), p.ref = it(c, a, f), p.return = c, p);
        }
        function d(c, a, f, p) {
            return a === null || a.tag !== 4 || a.stateNode.containerInfo !== f.containerInfo || a.stateNode.implementation !== f.implementation ? (a = Ti(f, c.mode, p), a.return = c, a) : (a = l(a, f.children || []), a.return = c, a);
        }
        function y(c, a, f, p, m) {
            return a === null || a.tag !== 7 ? (a = zn(f, c.mode, p, m), a.return = c, a) : (a = l(a, f), a.return = c, a);
        }
        function C(c, a, f) {
            if (typeof a == "string" || typeof a == "number") return a = Pi("" + a, c.mode, f), a.return = c, a;
            if (typeof a == "object" && a !== null) {
                switch(a.$$typeof){
                    case Mn:
                        return f = Tr(a.type, a.key, a.props, null, c.mode, f), f.ref = it(c, null, a), f.return = c, f;
                    case Ae:
                        return a = Ti(a, c.mode, f), a.return = c, a;
                }
                if (ar(a) || In(a)) return a = zn(a, c.mode, f, null), a.return = c, a;
                fr(c, a);
            }
            return null;
        }
        function h(c, a, f, p) {
            var m = a !== null ? a.key : null;
            if (typeof f == "string" || typeof f == "number") return m !== null ? null : u(c, a, "" + f, p);
            if (typeof f == "object" && f !== null) {
                switch(f.$$typeof){
                    case Mn:
                        return f.key === m ? f.type === Ee ? y(c, a, f.props.children, p, m) : s(c, a, f, p) : null;
                    case Ae:
                        return f.key === m ? d(c, a, f, p) : null;
                }
                if (ar(f) || In(f)) return m !== null ? null : y(c, a, f, p, null);
                fr(c, f);
            }
            return null;
        }
        function S(c, a, f, p, m) {
            if (typeof p == "string" || typeof p == "number") return c = c.get(f) || null, u(a, c, "" + p, m);
            if (typeof p == "object" && p !== null) {
                switch(p.$$typeof){
                    case Mn:
                        return c = c.get(p.key === null ? f : p.key) || null, p.type === Ee ? y(a, c, p.props.children, m, p.key) : s(a, c, p, m);
                    case Ae:
                        return c = c.get(p.key === null ? f : p.key) || null, d(a, c, p, m);
                }
                if (ar(p) || In(p)) return c = c.get(f) || null, y(a, c, p, m, null);
                fr(a, p);
            }
            return null;
        }
        function k(c, a, f, p) {
            for(var m = null, _ = null, w = a, N = a = 0, T = null; w !== null && N < f.length; N++){
                w.index > N ? (T = w, w = null) : T = w.sibling;
                var P = h(c, w, f[N], p);
                if (P === null) {
                    w === null && (w = T);
                    break;
                }
                e && w && P.alternate === null && n(c, w), a = i(P, a, N), _ === null ? m = P : _.sibling = P, _ = P, w = T;
            }
            if (N === f.length) return t(c, w), m;
            if (w === null) {
                for(; N < f.length; N++)w = C(c, f[N], p), w !== null && (a = i(w, a, N), _ === null ? m = w : _.sibling = w, _ = w);
                return m;
            }
            for(w = r(c, w); N < f.length; N++)T = S(w, c, N, f[N], p), T !== null && (e && T.alternate !== null && w.delete(T.key === null ? N : T.key), a = i(T, a, N), _ === null ? m = T : _.sibling = T, _ = T);
            return e && w.forEach(function(Se) {
                return n(c, Se);
            }), m;
        }
        function E(c, a, f, p) {
            var m = In(f);
            if (typeof m != "function") throw Error(v(150));
            if (f = m.call(f), f == null) throw Error(v(151));
            for(var _ = m = null, w = a, N = a = 0, T = null, P = f.next(); w !== null && !P.done; N++, P = f.next()){
                w.index > N ? (T = w, w = null) : T = w.sibling;
                var Se = h(c, w, P.value, p);
                if (Se === null) {
                    w === null && (w = T);
                    break;
                }
                e && w && Se.alternate === null && n(c, w), a = i(Se, a, N), _ === null ? m = Se : _.sibling = Se, _ = Se, w = T;
            }
            if (P.done) return t(c, w), m;
            if (w === null) {
                for(; !P.done; N++, P = f.next())P = C(c, P.value, p), P !== null && (a = i(P, a, N), _ === null ? m = P : _.sibling = P, _ = P);
                return m;
            }
            for(w = r(c, w); !P.done; N++, P = f.next())P = S(w, c, N, P.value, p), P !== null && (e && P.alternate !== null && w.delete(P.key === null ? N : P.key), a = i(P, a, N), _ === null ? m = P : _.sibling = P, _ = P);
            return e && w.forEach(function(Ns) {
                return n(c, Ns);
            }), m;
        }
        return function(c, a, f, p) {
            var m = typeof f == "object" && f !== null && f.type === Ee && f.key === null;
            m && (f = f.props.children);
            var _ = typeof f == "object" && f !== null;
            if (_) switch(f.$$typeof){
                case Mn:
                    e: {
                        for(_ = f.key, m = a; m !== null;){
                            if (m.key === _) {
                                switch(m.tag){
                                    case 7:
                                        if (f.type === Ee) {
                                            t(c, m.sibling), a = l(m, f.props.children), a.return = c, c = a;
                                            break e;
                                        }
                                        break;
                                    default:
                                        if (m.elementType === f.type) {
                                            t(c, m.sibling), a = l(m, f.props), a.ref = it(c, m, f), a.return = c, c = a;
                                            break e;
                                        }
                                }
                                t(c, m);
                                break;
                            } else n(c, m);
                            m = m.sibling;
                        }
                        f.type === Ee ? (a = zn(f.props.children, c.mode, p, f.key), a.return = c, c = a) : (p = Tr(f.type, f.key, f.props, null, c.mode, p), p.ref = it(c, a, f), p.return = c, c = p);
                    }
                    return o(c);
                case Ae:
                    e: {
                        for(m = f.key; a !== null;){
                            if (a.key === m) if (a.tag === 4 && a.stateNode.containerInfo === f.containerInfo && a.stateNode.implementation === f.implementation) {
                                t(c, a.sibling), a = l(a, f.children || []), a.return = c, c = a;
                                break e;
                            } else {
                                t(c, a);
                                break;
                            }
                            else n(c, a);
                            a = a.sibling;
                        }
                        a = Ti(f, c.mode, p), a.return = c, c = a;
                    }
                    return o(c);
            }
            if (typeof f == "string" || typeof f == "number") return f = "" + f, a !== null && a.tag === 6 ? (t(c, a.sibling), a = l(a, f), a.return = c, c = a) : (t(c, a), a = Pi(f, c.mode, p), a.return = c, c = a), o(c);
            if (ar(f)) return k(c, a, f, p);
            if (In(f)) return E(c, a, f, p);
            if (_ && fr(c, f), typeof f == "undefined" && !m) switch(c.tag){
                case 1:
                case 22:
                case 0:
                case 11:
                case 15:
                    throw Error(v(152, tn(c.type) || "Component"));
            }
            return t(c, a);
        };
    }
    var cr = ku(!0), xu = ku(!1), ot = {}, fe = Le(ot), ut = Le(ot), st = Le(ot);
    function Ze(e) {
        if (e === ot) throw Error(v(174));
        return e;
    }
    function Yl(e, n) {
        switch(R(st, n), R(ut, e), R(fe, ot), e = n.nodeType, e){
            case 9:
            case 11:
                n = (n = n.documentElement) ? n.namespaceURI : qr(null, "");
                break;
            default:
                e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = qr(n, e);
        }
        O(fe), R(fe, n);
    }
    function xn() {
        O(fe), O(ut), O(st);
    }
    function Cu(e) {
        Ze(st.current);
        var n = Ze(fe.current), t = qr(n, e.type);
        n !== t && (R(ut, e), R(fe, t));
    }
    function Xl(e) {
        ut.current === e && (O(fe), O(ut));
    }
    var D = Le(0);
    function dr(e) {
        for(var n = e; n !== null;){
            if (n.tag === 13) {
                var t = n.memoizedState;
                if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return n;
            } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) {
                if ((n.flags & 64) !== 0) return n;
            } else if (n.child !== null) {
                n.child.return = n, n = n.child;
                continue;
            }
            if (n === e) break;
            for(; n.sibling === null;){
                if (n.return === null || n.return === e) return null;
                n = n.return;
            }
            n.sibling.return = n.return, n = n.sibling;
        }
        return null;
    }
    var ve = null, De = null, ce = !1;
    function _u(e, n) {
        var t = le(5, null, null, 0);
        t.elementType = "DELETED", t.type = "DELETED", t.stateNode = n, t.return = e, t.flags = 8, e.lastEffect !== null ? (e.lastEffect.nextEffect = t, e.lastEffect = t) : e.firstEffect = e.lastEffect = t;
    }
    function Nu(e, n) {
        switch(e.tag){
            case 5:
                var t = e.type;
                return n = n.nodeType !== 1 || t.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, !0) : !1;
            case 6:
                return n = e.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, !0) : !1;
            case 13:
                return !1;
            default:
                return !1;
        }
    }
    function Kl(e) {
        if (ce) {
            var n = De;
            if (n) {
                var t = n;
                if (!Nu(e, n)) {
                    if (n = hn(t.nextSibling), !n || !Nu(e, n)) {
                        e.flags = e.flags & -1025 | 2, ce = !1, ve = e;
                        return;
                    }
                    _u(ve, t);
                }
                ve = e, De = hn(n.firstChild);
            } else e.flags = e.flags & -1025 | 2, ce = !1, ve = e;
        }
    }
    function Pu(e) {
        for(e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return;
        ve = e;
    }
    function pr(e) {
        if (e !== ve) return !1;
        if (!ce) return Pu(e), ce = !0, !1;
        var n = e.type;
        if (e.tag !== 5 || n !== "head" && n !== "body" && !Ml(n, e.memoizedProps)) for(n = De; n;)_u(e, n), n = hn(n.nextSibling);
        if (Pu(e), e.tag === 13) {
            if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(v(317));
            e: {
                for(e = e.nextSibling, n = 0; e;){
                    if (e.nodeType === 8) {
                        var t = e.data;
                        if (t === "/$") {
                            if (n === 0) {
                                De = hn(e.nextSibling);
                                break e;
                            }
                            n--;
                        } else t !== "$" && t !== "$!" && t !== "$?" || n++;
                    }
                    e = e.nextSibling;
                }
                De = null;
            }
        } else De = ve ? hn(e.stateNode.nextSibling) : null;
        return !0;
    }
    function Gl() {
        De = ve = null, ce = !1;
    }
    var Cn = [];
    function Zl() {
        for(var e = 0; e < Cn.length; e++)Cn[e]._workInProgressVersionPrimary = null;
        Cn.length = 0;
    }
    var at = We.ReactCurrentDispatcher, te = We.ReactCurrentBatchConfig, ft = 0, I = null, Q = null, B = null, mr = !1, ct = !1;
    function Z() {
        throw Error(v(321));
    }
    function Jl(e, n) {
        if (n === null) return !1;
        for(var t = 0; t < n.length && t < e.length; t++)if (!ee(e[t], n[t])) return !1;
        return !0;
    }
    function ql(e, n, t, r, l, i) {
        if (ft = i, I = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, at.current = e === null || e.memoizedState === null ? ba : ef, e = t(r, l), ct) {
            i = 0;
            do {
                if (ct = !1, !(25 > i)) throw Error(v(301));
                i += 1, B = Q = null, n.updateQueue = null, at.current = nf, e = t(r, l);
            }while (ct)
        }
        if (at.current = gr, n = Q !== null && Q.next !== null, ft = 0, B = Q = I = null, mr = !1, n) throw Error(v(300));
        return e;
    }
    function Je() {
        var e = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return B === null ? I.memoizedState = B = e : B = B.next = e, B;
    }
    function qe() {
        if (Q === null) {
            var e = I.alternate;
            e = e !== null ? e.memoizedState : null;
        } else e = Q.next;
        var n = B === null ? I.memoizedState : B.next;
        if (n !== null) B = n, Q = e;
        else {
            if (e === null) throw Error(v(310));
            Q = e, e = {
                memoizedState: Q.memoizedState,
                baseState: Q.baseState,
                baseQueue: Q.baseQueue,
                queue: Q.queue,
                next: null
            }, B === null ? I.memoizedState = B = e : B = B.next = e;
        }
        return B;
    }
    function de(e, n) {
        return typeof n == "function" ? n(e) : n;
    }
    function dt(e) {
        var n = qe(), t = n.queue;
        if (t === null) throw Error(v(311));
        t.lastRenderedReducer = e;
        var r = Q, l = r.baseQueue, i = t.pending;
        if (i !== null) {
            if (l !== null) {
                var o = l.next;
                l.next = i.next, i.next = o;
            }
            r.baseQueue = l = i, t.pending = null;
        }
        if (l !== null) {
            l = l.next, r = r.baseState;
            var u = o = i = null, s = l;
            do {
                var d = s.lane;
                if ((ft & d) === d) u !== null && (u = u.next = {
                    lane: 0,
                    action: s.action,
                    eagerReducer: s.eagerReducer,
                    eagerState: s.eagerState,
                    next: null
                }), r = s.eagerReducer === e ? s.eagerState : e(r, s.action);
                else {
                    var y = {
                        lane: d,
                        action: s.action,
                        eagerReducer: s.eagerReducer,
                        eagerState: s.eagerState,
                        next: null
                    };
                    u === null ? (o = u = y, i = r) : u = u.next = y, I.lanes |= d, vt |= d;
                }
                s = s.next;
            }while (s !== null && s !== l)
            u === null ? i = r : u.next = o, ee(r, n.memoizedState) || (ue = !0), n.memoizedState = r, n.baseState = i, n.baseQueue = u, t.lastRenderedState = r;
        }
        return [
            n.memoizedState,
            t.dispatch
        ];
    }
    function pt(e) {
        var n = qe(), t = n.queue;
        if (t === null) throw Error(v(311));
        t.lastRenderedReducer = e;
        var r = t.dispatch, l = t.pending, i = n.memoizedState;
        if (l !== null) {
            t.pending = null;
            var o = l = l.next;
            do i = e(i, o.action), o = o.next;
            while (o !== l)
            ee(i, n.memoizedState) || (ue = !0), n.memoizedState = i, n.baseQueue === null && (n.baseState = i), t.lastRenderedState = i;
        }
        return [
            i,
            r
        ];
    }
    function Tu(e, n, t) {
        var r = n._getVersion;
        r = r(n._source);
        var l = n._workInProgressVersionPrimary;
        if (l !== null ? e = l === r : (e = e.mutableReadLanes, (e = (ft & e) === e) && (n._workInProgressVersionPrimary = r, Cn.push(n))), e) return t(n._source);
        throw Cn.push(n), Error(v(350));
    }
    function Lu(e, n, t, r) {
        var l = X;
        if (l === null) throw Error(v(349));
        var i = n._getVersion, o = i(n._source), u = at.current, s = u.useState(function() {
            return Tu(l, n, t);
        }), d = s[1], y = s[0];
        s = B;
        var C = e.memoizedState, h = C.refs, S = h.getSnapshot, k = C.source;
        C = C.subscribe;
        var E = I;
        return e.memoizedState = {
            refs: h,
            source: n,
            subscribe: r
        }, u.useEffect(function() {
            h.getSnapshot = t, h.setSnapshot = d;
            var c = i(n._source);
            if (!ee(o, c)) {
                c = t(n._source), ee(y, c) || (d(c), c = Fe(E), l.mutableReadLanes |= c & l.pendingLanes), c = l.mutableReadLanes, l.entangledLanes |= c;
                for(var a = l.entanglements, f = c; 0 < f;){
                    var p = 31 - Ne(f), m = 1 << p;
                    a[p] |= c, f &= ~m;
                }
            }
        }, [
            t,
            n,
            r
        ]), u.useEffect(function() {
            return r(n._source, function() {
                var c = h.getSnapshot, a = h.setSnapshot;
                try {
                    a(c(n._source));
                    var f = Fe(E);
                    l.mutableReadLanes |= f & l.pendingLanes;
                } catch (p) {
                    a(function() {
                        throw p;
                    });
                }
            });
        }, [
            n,
            r
        ]), ee(S, t) && ee(k, n) && ee(C, r) || (e = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: de,
            lastRenderedState: y
        }, e.dispatch = d = ti.bind(null, I, e), s.queue = e, s.baseQueue = null, y = Tu(l, n, t), s.memoizedState = s.baseState = y), y;
    }
    function zu(e, n, t) {
        var r = qe();
        return Lu(r, e, n, t);
    }
    function mt(e) {
        var n = Je();
        return typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e, e = n.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: de,
            lastRenderedState: e
        }, e = e.dispatch = ti.bind(null, I, e), [
            n.memoizedState,
            e
        ];
    }
    function hr(e, n, t, r) {
        return e = {
            tag: e,
            create: n,
            destroy: t,
            deps: r,
            next: null
        }, n = I.updateQueue, n === null ? (n = {
            lastEffect: null
        }, I.updateQueue = n, n.lastEffect = e.next = e) : (t = n.lastEffect, t === null ? n.lastEffect = e.next = e : (r = t.next, t.next = e, e.next = r, n.lastEffect = e)), e;
    }
    function Ou(e) {
        var n = Je();
        return e = {
            current: e
        }, n.memoizedState = e;
    }
    function vr() {
        return qe().memoizedState;
    }
    function bl(e, n, t, r) {
        var l = Je();
        I.flags |= e, l.memoizedState = hr(1 | n, t, void 0, r === void 0 ? null : r);
    }
    function ei(e, n, t, r) {
        var l = qe();
        r = r === void 0 ? null : r;
        var i = void 0;
        if (Q !== null) {
            var o = Q.memoizedState;
            if (i = o.destroy, r !== null && Jl(r, o.deps)) {
                hr(n, t, i, r);
                return;
            }
        }
        I.flags |= e, l.memoizedState = hr(1 | n, t, i, r);
    }
    function Mu(e, n) {
        return bl(516, 4, e, n);
    }
    function yr(e, n) {
        return ei(516, 4, e, n);
    }
    function Ru(e, n) {
        return ei(4, 2, e, n);
    }
    function Du(e, n) {
        if (typeof n == "function") return e = e(), n(e), function() {
            n(null);
        };
        if (n != null) return e = e(), n.current = e, function() {
            n.current = null;
        };
    }
    function Iu(e, n, t) {
        return t = t != null ? t.concat([
            e
        ]) : null, ei(4, 2, Du.bind(null, n, e), t);
    }
    function ni() {}
    function Fu(e, n) {
        var t = qe();
        n = n === void 0 ? null : n;
        var r = t.memoizedState;
        return r !== null && n !== null && Jl(n, r[1]) ? r[0] : (t.memoizedState = [
            e,
            n
        ], e);
    }
    function ju(e, n) {
        var t = qe();
        n = n === void 0 ? null : n;
        var r = t.memoizedState;
        return r !== null && n !== null && Jl(n, r[1]) ? r[0] : (e = e(), t.memoizedState = [
            e,
            n
        ], e);
    }
    function qa(e, n) {
        var t = Sn();
        Ge(98 > t ? 98 : t, function() {
            e(!0);
        }), Ge(97 < t ? 97 : t, function() {
            var r = te.transition;
            te.transition = 1;
            try {
                e(!1), n();
            } finally{
                te.transition = r;
            }
        });
    }
    function ti(e, n, t) {
        var r = b(), l = Fe(e), i = {
            lane: l,
            action: t,
            eagerReducer: null,
            eagerState: null,
            next: null
        }, o = n.pending;
        if (o === null ? i.next = i : (i.next = o.next, o.next = i), n.pending = i, o = e.alternate, e === I || o !== null && o === I) ct = mr = !0;
        else {
            if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = n.lastRenderedReducer, o !== null)) try {
                var u = n.lastRenderedState, s = o(u, t);
                if (i.eagerReducer = o, i.eagerState = s, ee(s, u)) return;
            } catch  {} finally{}
            je(e, l, r);
        }
    }
    var gr = {
        readContext: ne,
        useCallback: Z,
        useContext: Z,
        useEffect: Z,
        useImperativeHandle: Z,
        useLayoutEffect: Z,
        useMemo: Z,
        useReducer: Z,
        useRef: Z,
        useState: Z,
        useDebugValue: Z,
        useDeferredValue: Z,
        useTransition: Z,
        useMutableSource: Z,
        useOpaqueIdentifier: Z,
        unstable_isNewReconciler: !1
    }, ba = {
        readContext: ne,
        useCallback: function(e, n) {
            return Je().memoizedState = [
                e,
                n === void 0 ? null : n
            ], e;
        },
        useContext: ne,
        useEffect: Mu,
        useImperativeHandle: function(e, n, t) {
            return t = t != null ? t.concat([
                e
            ]) : null, bl(4, 2, Du.bind(null, n, e), t);
        },
        useLayoutEffect: function(e, n) {
            return bl(4, 2, e, n);
        },
        useMemo: function(e, n) {
            var t = Je();
            return n = n === void 0 ? null : n, e = e(), t.memoizedState = [
                e,
                n
            ], e;
        },
        useReducer: function(e, n, t) {
            var r = Je();
            return n = t !== void 0 ? t(n) : n, r.memoizedState = r.baseState = n, e = r.queue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: e,
                lastRenderedState: n
            }, e = e.dispatch = ti.bind(null, I, e), [
                r.memoizedState,
                e
            ];
        },
        useRef: Ou,
        useState: mt,
        useDebugValue: ni,
        useDeferredValue: function(e) {
            var n = mt(e), t = n[0], r = n[1];
            return Mu(function() {
                var l = te.transition;
                te.transition = 1;
                try {
                    r(e);
                } finally{
                    te.transition = l;
                }
            }, [
                e
            ]), t;
        },
        useTransition: function() {
            var e = mt(!1), n = e[0];
            return e = qa.bind(null, e[1]), Ou(e), [
                e,
                n
            ];
        },
        useMutableSource: function(e, n, t) {
            var r = Je();
            return r.memoizedState = {
                refs: {
                    getSnapshot: n,
                    setSnapshot: null
                },
                source: e,
                subscribe: t
            }, Lu(r, e, n, t);
        },
        useOpaqueIdentifier: function() {
            if (ce) {
                var e = !1, n = Ya(function() {
                    throw e || (e = !0, t("r:" + (Dl++).toString(36))), Error(v(355));
                }), t = mt(n)[1];
                return (I.mode & 2) === 0 && (I.flags |= 516, hr(5, function() {
                    t("r:" + (Dl++).toString(36));
                }, void 0, null)), n;
            }
            return n = "r:" + (Dl++).toString(36), mt(n), n;
        },
        unstable_isNewReconciler: !1
    }, ef = {
        readContext: ne,
        useCallback: Fu,
        useContext: ne,
        useEffect: yr,
        useImperativeHandle: Iu,
        useLayoutEffect: Ru,
        useMemo: ju,
        useReducer: dt,
        useRef: vr,
        useState: function() {
            return dt(de);
        },
        useDebugValue: ni,
        useDeferredValue: function(e) {
            var n = dt(de), t = n[0], r = n[1];
            return yr(function() {
                var l = te.transition;
                te.transition = 1;
                try {
                    r(e);
                } finally{
                    te.transition = l;
                }
            }, [
                e
            ]), t;
        },
        useTransition: function() {
            var e = dt(de)[0];
            return [
                vr().current,
                e
            ];
        },
        useMutableSource: zu,
        useOpaqueIdentifier: function() {
            return dt(de)[0];
        },
        unstable_isNewReconciler: !1
    }, nf = {
        readContext: ne,
        useCallback: Fu,
        useContext: ne,
        useEffect: yr,
        useImperativeHandle: Iu,
        useLayoutEffect: Ru,
        useMemo: ju,
        useReducer: pt,
        useRef: vr,
        useState: function() {
            return pt(de);
        },
        useDebugValue: ni,
        useDeferredValue: function(e) {
            var n = pt(de), t = n[0], r = n[1];
            return yr(function() {
                var l = te.transition;
                te.transition = 1;
                try {
                    r(e);
                } finally{
                    te.transition = l;
                }
            }, [
                e
            ]), t;
        },
        useTransition: function() {
            var e = pt(de)[0];
            return [
                vr().current,
                e
            ];
        },
        useMutableSource: zu,
        useOpaqueIdentifier: function() {
            return pt(de)[0];
        },
        unstable_isNewReconciler: !1
    }, tf = We.ReactCurrentOwner, ue = !1;
    function J(e, n, t, r) {
        n.child = e === null ? xu(n, null, t, r) : cr(n, e.child, t, r);
    }
    function Uu(e, n, t, r, l) {
        t = t.render;
        var i = n.ref;
        return kn(n, l), r = ql(e, n, t, r, i, l), e !== null && !ue ? (n.updateQueue = e.updateQueue, n.flags &= -517, e.lanes &= ~l, ye(e, n, l)) : (n.flags |= 1, J(e, n, r, l), n.child);
    }
    function Vu(e, n, t, r, l, i) {
        if (e === null) {
            var o = t.type;
            return typeof o == "function" && !_i(o) && o.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (n.tag = 15, n.type = o, Bu(e, n, o, r, l, i)) : (e = Tr(t.type, null, r, n, n.mode, i), e.ref = n.ref, e.return = n, n.child = e);
        }
        return o = e.child, (l & i) === 0 && (l = o.memoizedProps, t = t.compare, t = t !== null ? t : qn, t(l, r) && e.ref === n.ref) ? ye(e, n, i) : (n.flags |= 1, e = Be(o, r), e.ref = n.ref, e.return = n, n.child = e);
    }
    function Bu(e, n, t, r, l, i) {
        if (e !== null && qn(e.memoizedProps, r) && e.ref === n.ref) if (ue = !1, (i & l) !== 0) (e.flags & 16384) !== 0 && (ue = !0);
        else return n.lanes = e.lanes, ye(e, n, i);
        return li(e, n, t, r, i);
    }
    function ri(e, n, t) {
        var r = n.pendingProps, l = r.children, i = e !== null ? e.memoizedState : null;
        if (r.mode === "hidden" || r.mode === "unstable-defer-without-hiding") if ((n.mode & 4) === 0) n.memoizedState = {
            baseLanes: 0
        }, Pr(n, t);
        else if ((t & 1073741824) !== 0) n.memoizedState = {
            baseLanes: 0
        }, Pr(n, i !== null ? i.baseLanes : t);
        else return e = i !== null ? i.baseLanes | t : t, n.lanes = n.childLanes = 1073741824, n.memoizedState = {
            baseLanes: e
        }, Pr(n, e), null;
        else i !== null ? (r = i.baseLanes | t, n.memoizedState = null) : r = t, Pr(n, r);
        return J(e, n, l, t), n.child;
    }
    function Hu(e, n) {
        var t = n.ref;
        (e === null && t !== null || e !== null && e.ref !== t) && (n.flags |= 128);
    }
    function li(e, n, t, r, l) {
        var i = G(t) ? Xe : W.current;
        return i = wn(n, i), kn(n, l), t = ql(e, n, t, r, i, l), e !== null && !ue ? (n.updateQueue = e.updateQueue, n.flags &= -517, e.lanes &= ~l, ye(e, n, l)) : (n.flags |= 1, J(e, n, t, l), n.child);
    }
    function Wu(e, n, t, r, l) {
        if (G(t)) {
            var i = !0;
            nr(n);
        } else i = !1;
        if (kn(n, l), n.stateNode === null) e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2), Su(n, t, r), $l(n, t, r, l), r = !0;
        else if (e === null) {
            var o = n.stateNode, u = n.memoizedProps;
            o.props = u;
            var s = o.context, d = t.contextType;
            typeof d == "object" && d !== null ? d = ne(d) : (d = G(t) ? Xe : W.current, d = wn(n, d));
            var y = t.getDerivedStateFromProps, C = typeof y == "function" || typeof o.getSnapshotBeforeUpdate == "function";
            C || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (u !== r || s !== d) && Eu(n, o, r, d), Oe = !1;
            var h = n.memoizedState;
            o.state = h, lt(n, r, o, l), s = n.memoizedState, u !== r || h !== s || K.current || Oe ? (typeof y == "function" && (ur(n, t, y, r), s = n.memoizedState), (u = Oe || wu(n, t, u, r, h, s, d)) ? (C || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (n.flags |= 4)) : (typeof o.componentDidMount == "function" && (n.flags |= 4), n.memoizedProps = r, n.memoizedState = s), o.props = r, o.state = s, o.context = d, r = u) : (typeof o.componentDidMount == "function" && (n.flags |= 4), r = !1);
        } else {
            o = n.stateNode, hu(e, n), u = n.memoizedProps, d = n.type === n.elementType ? u : oe(n.type, u), o.props = d, C = n.pendingProps, h = o.context, s = t.contextType, typeof s == "object" && s !== null ? s = ne(s) : (s = G(t) ? Xe : W.current, s = wn(n, s));
            var S = t.getDerivedStateFromProps;
            (y = typeof S == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (u !== C || h !== s) && Eu(n, o, r, s), Oe = !1, h = n.memoizedState, o.state = h, lt(n, r, o, l);
            var k = n.memoizedState;
            u !== C || h !== k || K.current || Oe ? (typeof S == "function" && (ur(n, t, S, r), k = n.memoizedState), (d = Oe || wu(n, t, d, r, h, k, s)) ? (y || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, k, s), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, k, s)), typeof o.componentDidUpdate == "function" && (n.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (n.flags |= 256)) : (typeof o.componentDidUpdate != "function" || u === e.memoizedProps && h === e.memoizedState || (n.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || u === e.memoizedProps && h === e.memoizedState || (n.flags |= 256), n.memoizedProps = r, n.memoizedState = k), o.props = r, o.state = k, o.context = s, r = d) : (typeof o.componentDidUpdate != "function" || u === e.memoizedProps && h === e.memoizedState || (n.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || u === e.memoizedProps && h === e.memoizedState || (n.flags |= 256), r = !1);
        }
        return ii(e, n, t, r, i, l);
    }
    function ii(e, n, t, r, l, i) {
        Hu(e, n);
        var o = (n.flags & 64) !== 0;
        if (!r && !o) return l && iu(n, t, !1), ye(e, n, i);
        r = n.stateNode, tf.current = n;
        var u = o && typeof t.getDerivedStateFromError != "function" ? null : r.render();
        return n.flags |= 1, e !== null && o ? (n.child = cr(n, e.child, null, i), n.child = cr(n, null, u, i)) : J(e, n, u, i), n.memoizedState = r.state, l && iu(n, t, !0), n.child;
    }
    function Au(e) {
        var n = e.stateNode;
        n.pendingContext ? ru(e, n.pendingContext, n.pendingContext !== n.context) : n.context && ru(e, n.context, !1), Yl(e, n.containerInfo);
    }
    var wr = {
        dehydrated: null,
        retryLane: 0
    };
    function Qu(e, n, t) {
        var r = n.pendingProps, l = D.current, i = !1, o;
        return (o = (n.flags & 64) !== 0) || (o = e !== null && e.memoizedState === null ? !1 : (l & 2) !== 0), o ? (i = !0, n.flags &= -65) : e !== null && e.memoizedState === null || r.fallback === void 0 || r.unstable_avoidThisFallback === !0 || (l |= 1), R(D, l & 1), e === null ? (r.fallback !== void 0 && Kl(n), e = r.children, l = r.fallback, i ? (e = $u(n, e, l, t), n.child.memoizedState = {
            baseLanes: t
        }, n.memoizedState = wr, e) : typeof r.unstable_expectedLoadTime == "number" ? (e = $u(n, e, l, t), n.child.memoizedState = {
            baseLanes: t
        }, n.memoizedState = wr, n.lanes = 33554432, e) : (t = Ni({
            mode: "visible",
            children: e
        }, n.mode, t, null), t.return = n, n.child = t)) : e.memoizedState !== null ? i ? (r = Xu(e, n, r.children, r.fallback, t), i = n.child, l = e.child.memoizedState, i.memoizedState = l === null ? {
            baseLanes: t
        } : {
            baseLanes: l.baseLanes | t
        }, i.childLanes = e.childLanes & ~t, n.memoizedState = wr, r) : (t = Yu(e, n, r.children, t), n.memoizedState = null, t) : i ? (r = Xu(e, n, r.children, r.fallback, t), i = n.child, l = e.child.memoizedState, i.memoizedState = l === null ? {
            baseLanes: t
        } : {
            baseLanes: l.baseLanes | t
        }, i.childLanes = e.childLanes & ~t, n.memoizedState = wr, r) : (t = Yu(e, n, r.children, t), n.memoizedState = null, t);
    }
    function $u(e, n, t, r) {
        var l = e.mode, i = e.child;
        return n = {
            mode: "hidden",
            children: n
        }, (l & 2) === 0 && i !== null ? (i.childLanes = 0, i.pendingProps = n) : i = Ni(n, l, 0, null), t = zn(t, l, r, null), i.return = e, t.return = e, i.sibling = t, e.child = i, t;
    }
    function Yu(e, n, t, r) {
        var l = e.child;
        return e = l.sibling, t = Be(l, {
            mode: "visible",
            children: t
        }), (n.mode & 2) === 0 && (t.lanes = r), t.return = n, t.sibling = null, e !== null && (e.nextEffect = null, e.flags = 8, n.firstEffect = n.lastEffect = e), n.child = t;
    }
    function Xu(e, n, t, r, l) {
        var i = n.mode, o = e.child;
        e = o.sibling;
        var u = {
            mode: "hidden",
            children: t
        };
        return (i & 2) === 0 && n.child !== o ? (t = n.child, t.childLanes = 0, t.pendingProps = u, o = t.lastEffect, o !== null ? (n.firstEffect = t.firstEffect, n.lastEffect = o, o.nextEffect = null) : n.firstEffect = n.lastEffect = null) : t = Be(o, u), e !== null ? r = Be(e, r) : (r = zn(r, i, l, null), r.flags |= 2), r.return = n, t.return = n, t.sibling = r, n.child = t, r;
    }
    function Ku(e, n) {
        e.lanes |= n;
        var t = e.alternate;
        t !== null && (t.lanes |= n), mu(e.return, n);
    }
    function oi(e, n, t, r, l, i) {
        var o = e.memoizedState;
        o === null ? e.memoizedState = {
            isBackwards: n,
            rendering: null,
            renderingStartTime: 0,
            last: r,
            tail: t,
            tailMode: l,
            lastEffect: i
        } : (o.isBackwards = n, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = t, o.tailMode = l, o.lastEffect = i);
    }
    function Gu(e, n, t) {
        var r = n.pendingProps, l = r.revealOrder, i = r.tail;
        if (J(e, n, r.children, t), r = D.current, (r & 2) !== 0) r = r & 1 | 2, n.flags |= 64;
        else {
            if (e !== null && (e.flags & 64) !== 0) e: for(e = n.child; e !== null;){
                if (e.tag === 13) e.memoizedState !== null && Ku(e, t);
                else if (e.tag === 19) Ku(e, t);
                else if (e.child !== null) {
                    e.child.return = e, e = e.child;
                    continue;
                }
                if (e === n) break e;
                for(; e.sibling === null;){
                    if (e.return === null || e.return === n) break e;
                    e = e.return;
                }
                e.sibling.return = e.return, e = e.sibling;
            }
            r &= 1;
        }
        if (R(D, r), (n.mode & 2) === 0) n.memoizedState = null;
        else switch(l){
            case "forwards":
                for(t = n.child, l = null; t !== null;)e = t.alternate, e !== null && dr(e) === null && (l = t), t = t.sibling;
                t = l, t === null ? (l = n.child, n.child = null) : (l = t.sibling, t.sibling = null), oi(n, !1, l, t, i, n.lastEffect);
                break;
            case "backwards":
                for(t = null, l = n.child, n.child = null; l !== null;){
                    if (e = l.alternate, e !== null && dr(e) === null) {
                        n.child = l;
                        break;
                    }
                    e = l.sibling, l.sibling = t, t = l, l = e;
                }
                oi(n, !0, t, null, i, n.lastEffect);
                break;
            case "together":
                oi(n, !1, null, null, void 0, n.lastEffect);
                break;
            default:
                n.memoizedState = null;
        }
        return n.child;
    }
    function ye(e, n, t) {
        if (e !== null && (n.dependencies = e.dependencies), vt |= n.lanes, (t & n.childLanes) !== 0) {
            if (e !== null && n.child !== e.child) throw Error(v(153));
            if (n.child !== null) {
                for(e = n.child, t = Be(e, e.pendingProps), n.child = t, t.return = n; e.sibling !== null;)e = e.sibling, t = t.sibling = Be(e, e.pendingProps), t.return = n;
                t.sibling = null;
            }
            return n.child;
        }
        return null;
    }
    var Zu, ui, Ju, qu;
    Zu = function(e, n) {
        for(var t = n.child; t !== null;){
            if (t.tag === 5 || t.tag === 6) e.appendChild(t.stateNode);
            else if (t.tag !== 4 && t.child !== null) {
                t.child.return = t, t = t.child;
                continue;
            }
            if (t === n) break;
            for(; t.sibling === null;){
                if (t.return === null || t.return === n) return;
                t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
        }
    };
    ui = function() {};
    Ju = function(e, n, t, r) {
        var l = e.memoizedProps;
        if (l !== r) {
            e = n.stateNode, Ze(fe.current);
            var i = null;
            switch(t){
                case "input":
                    l = Yr(e, l), r = Yr(e, r), i = [];
                    break;
                case "option":
                    l = Gr(e, l), r = Gr(e, r), i = [];
                    break;
                case "select":
                    l = M({}, l, {
                        value: void 0
                    }), r = M({}, r, {
                        value: void 0
                    }), i = [];
                    break;
                case "textarea":
                    l = Zr(e, l), r = Zr(e, r), i = [];
                    break;
                default:
                    typeof l.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Zt);
            }
            br(t, r);
            var o;
            t = null;
            for(d in l)if (!r.hasOwnProperty(d) && l.hasOwnProperty(d) && l[d] != null) if (d === "style") {
                var u = l[d];
                for(o in u)u.hasOwnProperty(o) && (t || (t = {}), t[o] = "");
            } else d !== "dangerouslySetInnerHTML" && d !== "children" && d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && d !== "autoFocus" && (On.hasOwnProperty(d) ? i || (i = []) : (i = i || []).push(d, null));
            for(d in r){
                var s = r[d];
                if (u = l != null ? l[d] : void 0, r.hasOwnProperty(d) && s !== u && (s != null || u != null)) if (d === "style") if (u) {
                    for(o in u)!u.hasOwnProperty(o) || s && s.hasOwnProperty(o) || (t || (t = {}), t[o] = "");
                    for(o in s)s.hasOwnProperty(o) && u[o] !== s[o] && (t || (t = {}), t[o] = s[o]);
                } else t || (i || (i = []), i.push(d, t)), t = s;
                else d === "dangerouslySetInnerHTML" ? (s = s ? s.__html : void 0, u = u ? u.__html : void 0, s != null && u !== s && (i = i || []).push(d, s)) : d === "children" ? typeof s != "string" && typeof s != "number" || (i = i || []).push(d, "" + s) : d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && (On.hasOwnProperty(d) ? (s != null && d === "onScroll" && z("scroll", e), i || u === s || (i = [])) : typeof s == "object" && s !== null && s.$$typeof === Hr ? s.toString() : (i = i || []).push(d, s));
            }
            t && (i = i || []).push("style", t);
            var d = i;
            (n.updateQueue = d) && (n.flags |= 4);
        }
    };
    qu = function(e, n, t, r) {
        t !== r && (n.flags |= 4);
    };
    function ht(e, n) {
        if (!ce) switch(e.tailMode){
            case "hidden":
                n = e.tail;
                for(var t = null; n !== null;)n.alternate !== null && (t = n), n = n.sibling;
                t === null ? e.tail = null : t.sibling = null;
                break;
            case "collapsed":
                t = e.tail;
                for(var r = null; t !== null;)t.alternate !== null && (r = t), t = t.sibling;
                r === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null;
        }
    }
    function rf(e, n, t) {
        var r = n.pendingProps;
        switch(n.tag){
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return null;
            case 1:
                return G(n.type) && er(), null;
            case 3:
                return xn(), O(K), O(W), Zl(), r = n.stateNode, r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (pr(n) ? n.flags |= 4 : r.hydrate || (n.flags |= 256)), ui(n), null;
            case 5:
                Xl(n);
                var l = Ze(st.current);
                if (t = n.type, e !== null && n.stateNode != null) Ju(e, n, t, r, l), e.ref !== n.ref && (n.flags |= 128);
                else {
                    if (!r) {
                        if (n.stateNode === null) throw Error(v(166));
                        return null;
                    }
                    if (e = Ze(fe.current), pr(n)) {
                        r = n.stateNode, t = n.type;
                        var i = n.memoizedProps;
                        switch(r[Te] = n, r[qt] = i, t){
                            case "dialog":
                                z("cancel", r), z("close", r);
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                z("load", r);
                                break;
                            case "video":
                            case "audio":
                                for(e = 0; e < et.length; e++)z(et[e], r);
                                break;
                            case "source":
                                z("error", r);
                                break;
                            case "img":
                            case "image":
                            case "link":
                                z("error", r), z("load", r);
                                break;
                            case "details":
                                z("toggle", r);
                                break;
                            case "input":
                                Ai(r, i), z("invalid", r);
                                break;
                            case "select":
                                r._wrapperState = {
                                    wasMultiple: !!i.multiple
                                }, z("invalid", r);
                                break;
                            case "textarea":
                                Yi(r, i), z("invalid", r);
                        }
                        br(t, i), e = null;
                        for(var o in i)i.hasOwnProperty(o) && (l = i[o], o === "children" ? typeof l == "string" ? r.textContent !== l && (e = [
                            "children",
                            l
                        ]) : typeof l == "number" && r.textContent !== "" + l && (e = [
                            "children",
                            "" + l
                        ]) : On.hasOwnProperty(o) && l != null && o === "onScroll" && z("scroll", r));
                        switch(t){
                            case "input":
                                zt(r), $i(r, i, !0);
                                break;
                            case "textarea":
                                zt(r), Ki(r);
                                break;
                            case "select":
                            case "option":
                                break;
                            default:
                                typeof i.onClick == "function" && (r.onclick = Zt);
                        }
                        r = e, n.updateQueue = r, r !== null && (n.flags |= 4);
                    } else {
                        switch(o = l.nodeType === 9 ? l : l.ownerDocument, e === Jr.html && (e = Gi(t)), e === Jr.html ? t === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(t, {
                            is: r.is
                        }) : (e = o.createElement(t), t === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, t), e[Te] = n, e[qt] = r, Zu(e, n, !1, !1), n.stateNode = e, o = el(t, r), t){
                            case "dialog":
                                z("cancel", e), z("close", e), l = r;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                z("load", e), l = r;
                                break;
                            case "video":
                            case "audio":
                                for(l = 0; l < et.length; l++)z(et[l], e);
                                l = r;
                                break;
                            case "source":
                                z("error", e), l = r;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                z("error", e), z("load", e), l = r;
                                break;
                            case "details":
                                z("toggle", e), l = r;
                                break;
                            case "input":
                                Ai(e, r), l = Yr(e, r), z("invalid", e);
                                break;
                            case "option":
                                l = Gr(e, r);
                                break;
                            case "select":
                                e._wrapperState = {
                                    wasMultiple: !!r.multiple
                                }, l = M({}, r, {
                                    value: void 0
                                }), z("invalid", e);
                                break;
                            case "textarea":
                                Yi(e, r), l = Zr(e, r), z("invalid", e);
                                break;
                            default:
                                l = r;
                        }
                        br(t, l);
                        var u = l;
                        for(i in u)if (u.hasOwnProperty(i)) {
                            var s = u[i];
                            i === "style" ? qi(e, s) : i === "dangerouslySetInnerHTML" ? (s = s ? s.__html : void 0, s != null && Zi(e, s)) : i === "children" ? typeof s == "string" ? (t !== "textarea" || s !== "") && jn(e, s) : typeof s == "number" && jn(e, "" + s) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (On.hasOwnProperty(i) ? s != null && i === "onScroll" && z("scroll", e) : s != null && Ir(e, i, s, o));
                        }
                        switch(t){
                            case "input":
                                zt(e), $i(e, r, !1);
                                break;
                            case "textarea":
                                zt(e), Ki(e);
                                break;
                            case "option":
                                r.value != null && e.setAttribute("value", "" + ke(r.value));
                                break;
                            case "select":
                                e.multiple = !!r.multiple, i = r.value, i != null ? rn(e, !!r.multiple, i, !1) : r.defaultValue != null && rn(e, !!r.multiple, r.defaultValue, !0);
                                break;
                            default:
                                typeof l.onClick == "function" && (e.onclick = Zt);
                        }
                        qo(t, r) && (n.flags |= 4);
                    }
                    n.ref !== null && (n.flags |= 128);
                }
                return null;
            case 6:
                if (e && n.stateNode != null) qu(e, n, e.memoizedProps, r);
                else {
                    if (typeof r != "string" && n.stateNode === null) throw Error(v(166));
                    t = Ze(st.current), Ze(fe.current), pr(n) ? (r = n.stateNode, t = n.memoizedProps, r[Te] = n, r.nodeValue !== t && (n.flags |= 4)) : (r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r), r[Te] = n, n.stateNode = r);
                }
                return null;
            case 13:
                return O(D), r = n.memoizedState, (n.flags & 64) !== 0 ? (n.lanes = t, n) : (r = r !== null, t = !1, e === null ? n.memoizedProps.fallback !== void 0 && pr(n) : t = e.memoizedState !== null, r && !t && (n.mode & 2) !== 0 && (e === null && n.memoizedProps.unstable_avoidThisFallback !== !0 || (D.current & 1) !== 0 ? H === 0 && (H = 3) : ((H === 0 || H === 3) && (H = 4), X === null || (vt & 134217727) === 0 && (Nn & 134217727) === 0 || Tn(X, $))), (r || t) && (n.flags |= 4), null);
            case 4:
                return xn(), ui(n), e === null && Xo(n.stateNode.containerInfo), null;
            case 10:
                return Al(n), null;
            case 17:
                return G(n.type) && er(), null;
            case 19:
                if (O(D), r = n.memoizedState, r === null) return null;
                if (i = (n.flags & 64) !== 0, o = r.rendering, o === null) if (i) ht(r, !1);
                else {
                    if (H !== 0 || e !== null && (e.flags & 64) !== 0) for(e = n.child; e !== null;){
                        if (o = dr(e), o !== null) {
                            for(n.flags |= 64, ht(r, !1), i = o.updateQueue, i !== null && (n.updateQueue = i, n.flags |= 4), r.lastEffect === null && (n.firstEffect = null), n.lastEffect = r.lastEffect, r = t, t = n.child; t !== null;)i = t, e = r, i.flags &= 2, i.nextEffect = null, i.firstEffect = null, i.lastEffect = null, o = i.alternate, o === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, i.type = o.type, e = o.dependencies, i.dependencies = e === null ? null : {
                                lanes: e.lanes,
                                firstContext: e.firstContext
                            }), t = t.sibling;
                            return R(D, D.current & 1 | 2), n.child;
                        }
                        e = e.sibling;
                    }
                    r.tail !== null && A() > gi && (n.flags |= 64, i = !0, ht(r, !1), n.lanes = 33554432);
                }
                else {
                    if (!i) if (e = dr(o), e !== null) {
                        if (n.flags |= 64, i = !0, t = e.updateQueue, t !== null && (n.updateQueue = t, n.flags |= 4), ht(r, !0), r.tail === null && r.tailMode === "hidden" && !o.alternate && !ce) return n = n.lastEffect = r.lastEffect, n !== null && (n.nextEffect = null), null;
                    } else 2 * A() - r.renderingStartTime > gi && t !== 1073741824 && (n.flags |= 64, i = !0, ht(r, !1), n.lanes = 33554432);
                    r.isBackwards ? (o.sibling = n.child, n.child = o) : (t = r.last, t !== null ? t.sibling = o : n.child = o, r.last = o);
                }
                return r.tail !== null ? (t = r.tail, r.rendering = t, r.tail = t.sibling, r.lastEffect = n.lastEffect, r.renderingStartTime = A(), t.sibling = null, n = D.current, R(D, i ? n & 1 | 2 : n & 1), t) : null;
            case 23:
            case 24:
                return Ci(), e !== null && e.memoizedState !== null != (n.memoizedState !== null) && r.mode !== "unstable-defer-without-hiding" && (n.flags |= 4), null;
        }
        throw Error(v(156, n.tag));
    }
    function lf(e) {
        switch(e.tag){
            case 1:
                G(e.type) && er();
                var n = e.flags;
                return n & 4096 ? (e.flags = n & -4097 | 64, e) : null;
            case 3:
                if (xn(), O(K), O(W), Zl(), n = e.flags, (n & 64) !== 0) throw Error(v(285));
                return e.flags = n & -4097 | 64, e;
            case 5:
                return Xl(e), null;
            case 13:
                return O(D), n = e.flags, n & 4096 ? (e.flags = n & -4097 | 64, e) : null;
            case 19:
                return O(D), null;
            case 4:
                return xn(), null;
            case 10:
                return Al(e), null;
            case 23:
            case 24:
                return Ci(), null;
            default:
                return null;
        }
    }
    function si(e, n) {
        try {
            var t = "", r = n;
            do t += Us(r), r = r.return;
            while (r)
            var l = t;
        } catch (i) {
            l = `
Error generating stack: ` + i.message + `
` + i.stack;
        }
        return {
            value: e,
            source: n,
            stack: l
        };
    }
    function ai(e, n) {
        try {
            console.error(n.value);
        } catch (t) {
            setTimeout(function() {
                throw t;
            });
        }
    }
    var of = typeof WeakMap == "function" ? WeakMap : Map;
    function bu(e, n, t) {
        t = Me1(-1, t), t.tag = 3, t.payload = {
            element: null
        };
        var r = n.value;
        return t.callback = function() {
            kr || (kr = !0, wi = r), ai(e, n);
        }, t;
    }
    function es(e, n, t) {
        t = Me1(-1, t), t.tag = 3;
        var r = e.type.getDerivedStateFromError;
        if (typeof r == "function") {
            var l = n.value;
            t.payload = function() {
                return ai(e, n), r(l);
            };
        }
        var i = e.stateNode;
        return i !== null && typeof i.componentDidCatch == "function" && (t.callback = function() {
            typeof r != "function" && (pe === null ? pe = new Set([
                this
            ]) : pe.add(this), ai(e, n));
            var o = n.stack;
            this.componentDidCatch(n.value, {
                componentStack: o !== null ? o : ""
            });
        }), t;
    }
    var uf = typeof WeakSet == "function" ? WeakSet : Set;
    function ns(e) {
        var n = e.ref;
        if (n !== null) if (typeof n == "function") try {
            n(null);
        } catch (t) {
            Ve(e, t);
        }
        else n.current = null;
    }
    function sf(e, n) {
        switch(n.tag){
            case 0:
            case 11:
            case 15:
            case 22:
                return;
            case 1:
                if (n.flags & 256 && e !== null) {
                    var t = e.memoizedProps, r = e.memoizedState;
                    e = n.stateNode, n = e.getSnapshotBeforeUpdate(n.elementType === n.type ? t : oe(n.type, t), r), e.__reactInternalSnapshotBeforeUpdate = n;
                }
                return;
            case 3:
                n.flags & 256 && Rl(n.stateNode.containerInfo);
                return;
            case 5:
            case 6:
            case 4:
            case 17:
                return;
        }
        throw Error(v(163));
    }
    function af(e, n, t) {
        switch(t.tag){
            case 0:
            case 11:
            case 15:
            case 22:
                if (n = t.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) {
                    e = n = n.next;
                    do {
                        if ((e.tag & 3) === 3) {
                            var r = e.create;
                            e.destroy = r();
                        }
                        e = e.next;
                    }while (e !== n)
                }
                if (n = t.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) {
                    e = n = n.next;
                    do {
                        var l = e;
                        r = l.next, l = l.tag, (l & 4) !== 0 && (l & 1) !== 0 && (vs(t, e), yf(t, e)), e = r;
                    }while (e !== n)
                }
                return;
            case 1:
                e = t.stateNode, t.flags & 4 && (n === null ? e.componentDidMount() : (r = t.elementType === t.type ? n.memoizedProps : oe(t.type, n.memoizedProps), e.componentDidUpdate(r, n.memoizedState, e.__reactInternalSnapshotBeforeUpdate))), n = t.updateQueue, n !== null && yu(t, n, e);
                return;
            case 3:
                if (n = t.updateQueue, n !== null) {
                    if (e = null, t.child !== null) switch(t.child.tag){
                        case 5:
                            e = t.child.stateNode;
                            break;
                        case 1:
                            e = t.child.stateNode;
                    }
                    yu(t, n, e);
                }
                return;
            case 5:
                e = t.stateNode, n === null && t.flags & 4 && qo(t.type, t.memoizedProps) && e.focus();
                return;
            case 6:
                return;
            case 4:
                return;
            case 12:
                return;
            case 13:
                t.memoizedState === null && (t = t.alternate, t !== null && (t = t.memoizedState, t !== null && (t = t.dehydrated, t !== null && ho(t))));
                return;
            case 19:
            case 17:
            case 20:
            case 21:
            case 23:
            case 24:
                return;
        }
        throw Error(v(163));
    }
    function ts(e, n) {
        for(var t = e;;){
            if (t.tag === 5) {
                var r = t.stateNode;
                if (n) r = r.style, typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
                else {
                    r = t.stateNode;
                    var l = t.memoizedProps.style;
                    l = l != null && l.hasOwnProperty("display") ? l.display : null, r.style.display = Ji("display", l);
                }
            } else if (t.tag === 6) t.stateNode.nodeValue = n ? "" : t.memoizedProps;
            else if ((t.tag !== 23 && t.tag !== 24 || t.memoizedState === null || t === e) && t.child !== null) {
                t.child.return = t, t = t.child;
                continue;
            }
            if (t === e) break;
            for(; t.sibling === null;){
                if (t.return === null || t.return === e) return;
                t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
        }
    }
    function rs(e, n) {
        if (Ke && typeof Ke.onCommitFiberUnmount == "function") try {
            Ke.onCommitFiberUnmount(Fl, n);
        } catch  {}
        switch(n.tag){
            case 0:
            case 11:
            case 14:
            case 15:
            case 22:
                if (e = n.updateQueue, e !== null && (e = e.lastEffect, e !== null)) {
                    var t = e = e.next;
                    do {
                        var r = t, l = r.destroy;
                        if (r = r.tag, l !== void 0) if ((r & 4) !== 0) vs(n, t);
                        else {
                            r = n;
                            try {
                                l();
                            } catch (i) {
                                Ve(r, i);
                            }
                        }
                        t = t.next;
                    }while (t !== e)
                }
                break;
            case 1:
                if (ns(n), e = n.stateNode, typeof e.componentWillUnmount == "function") try {
                    e.props = n.memoizedProps, e.state = n.memoizedState, e.componentWillUnmount();
                } catch (i1) {
                    Ve(n, i1);
                }
                break;
            case 5:
                ns(n);
                break;
            case 4:
                us(e, n);
        }
    }
    function ls(e) {
        e.alternate = null, e.child = null, e.dependencies = null, e.firstEffect = null, e.lastEffect = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.return = null, e.updateQueue = null;
    }
    function is(e) {
        return e.tag === 5 || e.tag === 3 || e.tag === 4;
    }
    function os(e) {
        e: {
            for(var n = e.return; n !== null;){
                if (is(n)) break e;
                n = n.return;
            }
            throw Error(v(160));
        }
        var t = n;
        switch(n = t.stateNode, t.tag){
            case 5:
                var r = !1;
                break;
            case 3:
                n = n.containerInfo, r = !0;
                break;
            case 4:
                n = n.containerInfo, r = !0;
                break;
            default:
                throw Error(v(161));
        }
        t.flags & 16 && (jn(n, ""), t.flags &= -17);
        e: n: for(t = e;;){
            for(; t.sibling === null;){
                if (t.return === null || is(t.return)) {
                    t = null;
                    break e;
                }
                t = t.return;
            }
            for(t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;){
                if (t.flags & 2 || t.child === null || t.tag === 4) continue n;
                t.child.return = t, t = t.child;
            }
            if (!(t.flags & 2)) {
                t = t.stateNode;
                break e;
            }
        }
        r ? fi(e, t, n) : ci(e, t, n);
    }
    function fi(e, n, t) {
        var r = e.tag, l = r === 5 || r === 6;
        if (l) e = l ? e.stateNode : e.stateNode.instance, n ? t.nodeType === 8 ? t.parentNode.insertBefore(e, n) : t.insertBefore(e, n) : (t.nodeType === 8 ? (n = t.parentNode, n.insertBefore(e, t)) : (n = t, n.appendChild(e)), t = t._reactRootContainer, t != null || n.onclick !== null || (n.onclick = Zt));
        else if (r !== 4 && (e = e.child, e !== null)) for(fi(e, n, t), e = e.sibling; e !== null;)fi(e, n, t), e = e.sibling;
    }
    function ci(e, n, t) {
        var r = e.tag, l = r === 5 || r === 6;
        if (l) e = l ? e.stateNode : e.stateNode.instance, n ? t.insertBefore(e, n) : t.appendChild(e);
        else if (r !== 4 && (e = e.child, e !== null)) for(ci(e, n, t), e = e.sibling; e !== null;)ci(e, n, t), e = e.sibling;
    }
    function us(e, n) {
        for(var t = n, r = !1, l, i;;){
            if (!r) {
                r = t.return;
                e: for(;;){
                    if (r === null) throw Error(v(160));
                    switch(l = r.stateNode, r.tag){
                        case 5:
                            i = !1;
                            break e;
                        case 3:
                            l = l.containerInfo, i = !0;
                            break e;
                        case 4:
                            l = l.containerInfo, i = !0;
                            break e;
                    }
                    r = r.return;
                }
                r = !0;
            }
            if (t.tag === 5 || t.tag === 6) {
                e: for(var o = e, u = t, s = u;;)if (rs(o, s), s.child !== null && s.tag !== 4) s.child.return = s, s = s.child;
                else {
                    if (s === u) break e;
                    for(; s.sibling === null;){
                        if (s.return === null || s.return === u) break e;
                        s = s.return;
                    }
                    s.sibling.return = s.return, s = s.sibling;
                }
                i ? (o = l, u = t.stateNode, o.nodeType === 8 ? o.parentNode.removeChild(u) : o.removeChild(u)) : l.removeChild(t.stateNode);
            } else if (t.tag === 4) {
                if (t.child !== null) {
                    l = t.stateNode.containerInfo, i = !0, t.child.return = t, t = t.child;
                    continue;
                }
            } else if (rs(e, t), t.child !== null) {
                t.child.return = t, t = t.child;
                continue;
            }
            if (t === n) break;
            for(; t.sibling === null;){
                if (t.return === null || t.return === n) return;
                t = t.return, t.tag === 4 && (r = !1);
            }
            t.sibling.return = t.return, t = t.sibling;
        }
    }
    function di(e, n) {
        switch(n.tag){
            case 0:
            case 11:
            case 14:
            case 15:
            case 22:
                var t = n.updateQueue;
                if (t = t !== null ? t.lastEffect : null, t !== null) {
                    var r = t = t.next;
                    do (r.tag & 3) === 3 && (e = r.destroy, r.destroy = void 0, e !== void 0 && e()), r = r.next;
                    while (r !== t)
                }
                return;
            case 1:
                return;
            case 5:
                if (t = n.stateNode, t != null) {
                    r = n.memoizedProps;
                    var l = e !== null ? e.memoizedProps : r;
                    e = n.type;
                    var i = n.updateQueue;
                    if (n.updateQueue = null, i !== null) {
                        for(t[qt] = r, e === "input" && r.type === "radio" && r.name != null && Qi(t, r), el(e, l), n = el(e, r), l = 0; l < i.length; l += 2){
                            var o = i[l], u = i[l + 1];
                            o === "style" ? qi(t, u) : o === "dangerouslySetInnerHTML" ? Zi(t, u) : o === "children" ? jn(t, u) : Ir(t, o, u, n);
                        }
                        switch(e){
                            case "input":
                                Xr(t, r);
                                break;
                            case "textarea":
                                Xi(t, r);
                                break;
                            case "select":
                                e = t._wrapperState.wasMultiple, t._wrapperState.wasMultiple = !!r.multiple, i = r.value, i != null ? rn(t, !!r.multiple, i, !1) : e !== !!r.multiple && (r.defaultValue != null ? rn(t, !!r.multiple, r.defaultValue, !0) : rn(t, !!r.multiple, r.multiple ? [] : "", !1));
                        }
                    }
                }
                return;
            case 6:
                if (n.stateNode === null) throw Error(v(162));
                n.stateNode.nodeValue = n.memoizedProps;
                return;
            case 3:
                t = n.stateNode, t.hydrate && (t.hydrate = !1, ho(t.containerInfo));
                return;
            case 12:
                return;
            case 13:
                n.memoizedState !== null && (yi = A(), ts(n.child, !0)), ss(n);
                return;
            case 19:
                ss(n);
                return;
            case 17:
                return;
            case 23:
            case 24:
                ts(n, n.memoizedState !== null);
                return;
        }
        throw Error(v(163));
    }
    function ss(e) {
        var n = e.updateQueue;
        if (n !== null) {
            e.updateQueue = null;
            var t = e.stateNode;
            t === null && (t = e.stateNode = new uf), n.forEach(function(r) {
                var l = Sf.bind(null, e, r);
                t.has(r) || (t.add(r), r.then(l, l));
            });
        }
    }
    function ff(e, n) {
        return e !== null && (e = e.memoizedState, e === null || e.dehydrated !== null) ? (n = n.memoizedState, n !== null && n.dehydrated === null) : !1;
    }
    var cf = Math.ceil, Sr = We.ReactCurrentDispatcher, pi = We.ReactCurrentOwner, x1 = 0, X = null, j = null, $ = 0, be = 0, mi = Le(0), H = 0, Er = null, _n = 0, vt = 0, Nn = 0, hi = 0, vi = null, yi = 0, gi = 1 / 0;
    function Pn() {
        gi = A() + 500;
    }
    var g = null, kr = !1, wi = null, pe = null, Ie = !1, yt = null, gt = 90, Si = [], Ei = [], ge = null, wt = 0, ki = null, xr = -1, we = 0, Cr = 0, St = null, _r = !1;
    function b() {
        return (x1 & 48) !== 0 ? A() : xr !== -1 ? xr : xr = A();
    }
    function Fe(e) {
        if (e = e.mode, (e & 2) === 0) return 1;
        if ((e & 4) === 0) return Sn() === 99 ? 1 : 2;
        if (we === 0 && (we = _n), Ja.transition !== 0) {
            Cr !== 0 && (Cr = vi !== null ? vi.pendingLanes : 0), e = we;
            var n = 4186112 & ~Cr;
            return n &= -n, n === 0 && (e = 4186112 & ~e, n = e & -e, n === 0 && (n = 8192)), n;
        }
        return e = Sn(), (x1 & 4) !== 0 && e === 98 ? e = Ut(12, we) : (e = ea(e), e = Ut(e, we)), e;
    }
    function je(e, n, t) {
        if (50 < wt) throw wt = 0, ki = null, Error(v(185));
        if (e = Nr(e, n), e === null) return null;
        Vt(e, n, t), e === X && (Nn |= n, H === 4 && Tn(e, $));
        var r = Sn();
        n === 1 ? (x1 & 8) !== 0 && (x1 & 48) === 0 ? xi(e) : (re(e, t), x1 === 0 && (Pn(), ae())) : ((x1 & 4) === 0 || r !== 98 && r !== 99 || (ge === null ? ge = new Set([
            e
        ]) : ge.add(e)), re(e, t)), vi = e;
    }
    function Nr(e, n) {
        e.lanes |= n;
        var t = e.alternate;
        for(t !== null && (t.lanes |= n), t = e, e = e.return; e !== null;)e.childLanes |= n, t = e.alternate, t !== null && (t.childLanes |= n), t = e, e = e.return;
        return t.tag === 3 ? t.stateNode : null;
    }
    function re(e, n) {
        for(var t = e.callbackNode, r = e.suspendedLanes, l = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;){
            var u = 31 - Ne(o), s = 1 << u, d = i[u];
            if (d === -1) {
                if ((s & r) === 0 || (s & l) !== 0) {
                    d = n, an(s);
                    var y = L;
                    i[u] = 10 <= y ? d + 250 : 6 <= y ? d + 5e3 : -1;
                }
            } else d <= n && (e.expiredLanes |= s);
            o &= ~s;
        }
        if (r = Yn(e, e === X ? $ : 0), n = L, r === 0) t !== null && (t !== Bl && Ul(t), e.callbackNode = null, e.callbackPriority = 0);
        else {
            if (t !== null) {
                if (e.callbackPriority === n) return;
                t !== Bl && Ul(t);
            }
            n === 15 ? (t = xi.bind(null, e), he === null ? (he = [
                t
            ], rr = jl(tr, pu)) : he.push(t), t = Bl) : n === 14 ? t = rt(99, xi.bind(null, e)) : (t = na(n), t = rt(t, as.bind(null, e))), e.callbackPriority = n, e.callbackNode = t;
        }
    }
    function as(e) {
        if (xr = -1, Cr = we = 0, (x1 & 48) !== 0) throw Error(v(327));
        var n = e.callbackNode;
        if (Ue() && e.callbackNode !== n) return null;
        var t = Yn(e, e === X ? $ : 0);
        if (t === 0) return null;
        var r = t, l = x1;
        x1 |= 16;
        var i = ps();
        (X !== e || $ !== r) && (Pn(), Ln(e, r));
        do try {
            mf();
            break;
        } catch (u) {
            ds(e, u);
        }
        while (1)
        if (Wl(), Sr.current = i, x1 = l, j !== null ? r = 0 : (X = null, $ = 0, r = H), (_n & Nn) !== 0) Ln(e, 0);
        else if (r !== 0) {
            if (r === 2 && (x1 |= 64, e.hydrate && (e.hydrate = !1, Rl(e.containerInfo)), t = ko(e), t !== 0 && (r = Et(e, t))), r === 1) throw n = Er, Ln(e, 0), Tn(e, t), re(e, A()), n;
            switch(e.finishedWork = e.current.alternate, e.finishedLanes = t, r){
                case 0:
                case 1:
                    throw Error(v(345));
                case 2:
                    en(e);
                    break;
                case 3:
                    if (Tn(e, t), (t & 62914560) === t && (r = yi + 500 - A(), 10 < r)) {
                        if (Yn(e, 0) !== 0) break;
                        if (l = e.suspendedLanes, (l & t) !== t) {
                            b(), e.pingedLanes |= e.suspendedLanes & l;
                            break;
                        }
                        e.timeoutHandle = bo(en.bind(null, e), r);
                        break;
                    }
                    en(e);
                    break;
                case 4:
                    if (Tn(e, t), (t & 4186112) === t) break;
                    for(r = e.eventTimes, l = -1; 0 < t;){
                        var o = 31 - Ne(t);
                        i = 1 << o, o = r[o], o > l && (l = o), t &= ~i;
                    }
                    if (t = l, t = A() - t, t = (120 > t ? 120 : 480 > t ? 480 : 1080 > t ? 1080 : 1920 > t ? 1920 : 3e3 > t ? 3e3 : 4320 > t ? 4320 : 1960 * cf(t / 1960)) - t, 10 < t) {
                        e.timeoutHandle = bo(en.bind(null, e), t);
                        break;
                    }
                    en(e);
                    break;
                case 5:
                    en(e);
                    break;
                default:
                    throw Error(v(329));
            }
        }
        return re(e, A()), e.callbackNode === n ? as.bind(null, e) : null;
    }
    function Tn(e, n) {
        for(n &= ~hi, n &= ~Nn, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n;){
            var t = 31 - Ne(n), r = 1 << t;
            e[t] = -1, n &= ~r;
        }
    }
    function xi(e) {
        if ((x1 & 48) !== 0) throw Error(v(327));
        if (Ue(), e === X && (e.expiredLanes & $) !== 0) {
            var n = $, t = Et(e, n);
            (_n & Nn) !== 0 && (n = Yn(e, n), t = Et(e, n));
        } else n = Yn(e, 0), t = Et(e, n);
        if (e.tag !== 0 && t === 2 && (x1 |= 64, e.hydrate && (e.hydrate = !1, Rl(e.containerInfo)), n = ko(e), n !== 0 && (t = Et(e, n))), t === 1) throw t = Er, Ln(e, 0), Tn(e, n), re(e, A()), t;
        return e.finishedWork = e.current.alternate, e.finishedLanes = n, en(e), re(e, A()), null;
    }
    function df() {
        if (ge !== null) {
            var e = ge;
            ge = null, e.forEach(function(n) {
                n.expiredLanes |= 24 & n.pendingLanes, re(n, A());
            });
        }
        ae();
    }
    function fs(e, n) {
        var t = x1;
        x1 |= 1;
        try {
            return e(n);
        } finally{
            x1 = t, x1 === 0 && (Pn(), ae());
        }
    }
    function cs(e, n) {
        var t = x1;
        x1 &= -2, x1 |= 8;
        try {
            return e(n);
        } finally{
            x1 = t, x1 === 0 && (Pn(), ae());
        }
    }
    function Pr(e, n) {
        R(mi, be), be |= n, _n |= n;
    }
    function Ci() {
        be = mi.current, O(mi);
    }
    function Ln(e, n) {
        e.finishedWork = null, e.finishedLanes = 0;
        var t = e.timeoutHandle;
        if (t !== -1 && (e.timeoutHandle = -1, $a(t)), j !== null) for(t = j.return; t !== null;){
            var r = t;
            switch(r.tag){
                case 1:
                    r = r.type.childContextTypes, r != null && er();
                    break;
                case 3:
                    xn(), O(K), O(W), Zl();
                    break;
                case 5:
                    Xl(r);
                    break;
                case 4:
                    xn();
                    break;
                case 13:
                    O(D);
                    break;
                case 19:
                    O(D);
                    break;
                case 10:
                    Al(r);
                    break;
                case 23:
                case 24:
                    Ci();
            }
            t = t.return;
        }
        X = e, j = Be(e.current, null), $ = be = _n = n, H = 0, Er = null, hi = Nn = vt = 0;
    }
    function ds(e, n) {
        do {
            var t = j;
            try {
                if (Wl(), at.current = gr, mr) {
                    for(var r = I.memoizedState; r !== null;){
                        var l = r.queue;
                        l !== null && (l.pending = null), r = r.next;
                    }
                    mr = !1;
                }
                if (ft = 0, B = Q = I = null, ct = !1, pi.current = null, t === null || t.return === null) {
                    H = 1, Er = n, j = null;
                    break;
                }
                e: {
                    var i = e, o = t.return, u = t, s = n;
                    if (n = $, u.flags |= 2048, u.firstEffect = u.lastEffect = null, s !== null && typeof s == "object" && typeof s.then == "function") {
                        var d = s;
                        if ((u.mode & 2) === 0) {
                            var y = u.alternate;
                            y ? (u.updateQueue = y.updateQueue, u.memoizedState = y.memoizedState, u.lanes = y.lanes) : (u.updateQueue = null, u.memoizedState = null);
                        }
                        var C = (D.current & 1) !== 0, h = o;
                        do {
                            var S;
                            if (S = h.tag === 13) {
                                var k = h.memoizedState;
                                if (k !== null) S = k.dehydrated !== null;
                                else {
                                    var E = h.memoizedProps;
                                    S = E.fallback === void 0 ? !1 : E.unstable_avoidThisFallback !== !0 ? !0 : !C;
                                }
                            }
                            if (S) {
                                var c = h.updateQueue;
                                if (c === null) {
                                    var a = new Set;
                                    a.add(d), h.updateQueue = a;
                                } else c.add(d);
                                if ((h.mode & 2) === 0) {
                                    if (h.flags |= 64, u.flags |= 16384, u.flags &= -2981, u.tag === 1) if (u.alternate === null) u.tag = 17;
                                    else {
                                        var f = Me1(-1, 1);
                                        f.tag = 2, Re(u, f);
                                    }
                                    u.lanes |= 1;
                                    break e;
                                }
                                s = void 0, u = n;
                                var p = i.pingCache;
                                if (p === null ? (p = i.pingCache = new of, s = new Set, p.set(d, s)) : (s = p.get(d), s === void 0 && (s = new Set, p.set(d, s))), !s.has(u)) {
                                    s.add(u);
                                    var m = wf.bind(null, i, d, u);
                                    d.then(m, m);
                                }
                                h.flags |= 4096, h.lanes = n;
                                break e;
                            }
                            h = h.return;
                        }while (h !== null)
                        s = Error((tn(u.type) || "A React component") + ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`);
                    }
                    H !== 5 && (H = 2), s = si(s, u), h = o;
                    do {
                        switch(h.tag){
                            case 3:
                                i = s, h.flags |= 4096, n &= -n, h.lanes |= n;
                                var _ = bu(h, i, n);
                                vu(h, _);
                                break e;
                            case 1:
                                i = s;
                                var w = h.type, N = h.stateNode;
                                if ((h.flags & 64) === 0 && (typeof w.getDerivedStateFromError == "function" || N !== null && typeof N.componentDidCatch == "function" && (pe === null || !pe.has(N)))) {
                                    h.flags |= 4096, n &= -n, h.lanes |= n;
                                    var T = es(h, i, n);
                                    vu(h, T);
                                    break e;
                                }
                        }
                        h = h.return;
                    }while (h !== null)
                }
                hs(t);
            } catch (P) {
                n = P, j === t && t !== null && (j = t = t.return);
                continue;
            }
            break;
        }while (1)
    }
    function ps() {
        var e = Sr.current;
        return Sr.current = gr, e === null ? gr : e;
    }
    function Et(e, n) {
        var t = x1;
        x1 |= 16;
        var r = ps();
        X === e && $ === n || Ln(e, n);
        do try {
            pf();
            break;
        } catch (l) {
            ds(e, l);
        }
        while (1)
        if (Wl(), x1 = t, Sr.current = r, j !== null) throw Error(v(261));
        return X = null, $ = 0, H;
    }
    function pf() {
        for(; j !== null;)ms(j);
    }
    function mf() {
        for(; j !== null && !Ka();)ms(j);
    }
    function ms(e) {
        var n = gs(e.alternate, e, be);
        e.memoizedProps = e.pendingProps, n === null ? hs(e) : j = n, pi.current = null;
    }
    function hs(e) {
        var n = e;
        do {
            var t = n.alternate;
            if (e = n.return, (n.flags & 2048) === 0) {
                if (t = rf(t, n, be), t !== null) {
                    j = t;
                    return;
                }
                if (t = n, t.tag !== 24 && t.tag !== 23 || t.memoizedState === null || (be & 1073741824) !== 0 || (t.mode & 4) === 0) {
                    for(var r = 0, l = t.child; l !== null;)r |= l.lanes | l.childLanes, l = l.sibling;
                    t.childLanes = r;
                }
                e !== null && (e.flags & 2048) === 0 && (e.firstEffect === null && (e.firstEffect = n.firstEffect), n.lastEffect !== null && (e.lastEffect !== null && (e.lastEffect.nextEffect = n.firstEffect), e.lastEffect = n.lastEffect), 1 < n.flags && (e.lastEffect !== null ? e.lastEffect.nextEffect = n : e.firstEffect = n, e.lastEffect = n));
            } else {
                if (t = lf(n), t !== null) {
                    t.flags &= 2047, j = t;
                    return;
                }
                e !== null && (e.firstEffect = e.lastEffect = null, e.flags |= 2048);
            }
            if (n = n.sibling, n !== null) {
                j = n;
                return;
            }
            j = n = e;
        }while (n !== null)
        H === 0 && (H = 5);
    }
    function en(e) {
        var n = Sn();
        return Ge(99, hf.bind(null, e, n)), null;
    }
    function hf(e, n) {
        do Ue();
        while (yt !== null)
        if ((x1 & 48) !== 0) throw Error(v(327));
        var t = e.finishedWork;
        if (t === null) return null;
        if (e.finishedWork = null, e.finishedLanes = 0, t === e.current) throw Error(v(177));
        e.callbackNode = null;
        var r = t.lanes | t.childLanes, l = r, i = e.pendingLanes & ~l;
        e.pendingLanes = l, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= l, e.mutableReadLanes &= l, e.entangledLanes &= l, l = e.entanglements;
        for(var o = e.eventTimes, u = e.expirationTimes; 0 < i;){
            var s = 31 - Ne(i), d = 1 << s;
            l[s] = 0, o[s] = -1, u[s] = -1, i &= ~d;
        }
        if (ge !== null && (r & 24) === 0 && ge.has(e) && ge.delete(e), e === X && (j = X = null, $ = 0), 1 < t.flags ? t.lastEffect !== null ? (t.lastEffect.nextEffect = t, r = t.firstEffect) : r = t : r = t.firstEffect, r !== null) {
            if (l = x1, x1 |= 32, pi.current = null, zl = Bt, o = Ho(), Nl(o)) {
                if ("selectionStart" in o) u = {
                    start: o.selectionStart,
                    end: o.selectionEnd
                };
                else e: if (u = (u = o.ownerDocument) && u.defaultView || window, (d = u.getSelection && u.getSelection()) && d.rangeCount !== 0) {
                    u = d.anchorNode, i = d.anchorOffset, s = d.focusNode, d = d.focusOffset;
                    try {
                        u.nodeType, s.nodeType;
                    } catch  {
                        u = null;
                        break e;
                    }
                    var y = 0, C = -1, h = -1, S = 0, k = 0, E = o, c = null;
                    n: for(;;){
                        for(var a; E !== u || i !== 0 && E.nodeType !== 3 || (C = y + i), E !== s || d !== 0 && E.nodeType !== 3 || (h = y + d), E.nodeType === 3 && (y += E.nodeValue.length), (a = E.firstChild) !== null;)c = E, E = a;
                        for(;;){
                            if (E === o) break n;
                            if (c === u && ++S === i && (C = y), c === s && ++k === d && (h = y), (a = E.nextSibling) !== null) break;
                            E = c, c = E.parentNode;
                        }
                        E = a;
                    }
                    u = C === -1 || h === -1 ? null : {
                        start: C,
                        end: h
                    };
                } else u = null;
                u = u || {
                    start: 0,
                    end: 0
                };
            } else u = null;
            Ol = {
                focusedElem: o,
                selectionRange: u
            }, Bt = !1, St = null, _r = !1, g = r;
            do try {
                vf();
            } catch (P) {
                if (g === null) throw Error(v(330));
                Ve(g, P), g = g.nextEffect;
            }
            while (g !== null)
            St = null, g = r;
            do try {
                for(o = e; g !== null;){
                    var f = g.flags;
                    if (f & 16 && jn(g.stateNode, ""), f & 128) {
                        var p = g.alternate;
                        if (p !== null) {
                            var m = p.ref;
                            m !== null && (typeof m == "function" ? m(null) : m.current = null);
                        }
                    }
                    switch(f & 1038){
                        case 2:
                            os(g), g.flags &= -3;
                            break;
                        case 6:
                            os(g), g.flags &= -3, di(g.alternate, g);
                            break;
                        case 1024:
                            g.flags &= -1025;
                            break;
                        case 1028:
                            g.flags &= -1025, di(g.alternate, g);
                            break;
                        case 4:
                            di(g.alternate, g);
                            break;
                        case 8:
                            u = g, us(o, u);
                            var _ = u.alternate;
                            ls(u), _ !== null && ls(_);
                    }
                    g = g.nextEffect;
                }
            } catch (P1) {
                if (g === null) throw Error(v(330));
                Ve(g, P1), g = g.nextEffect;
            }
            while (g !== null)
            if (m = Ol, p = Ho(), f = m.focusedElem, o = m.selectionRange, p !== f && f && f.ownerDocument && Bo(f.ownerDocument.documentElement, f)) {
                for(o !== null && Nl(f) && (p = o.start, m = o.end, m === void 0 && (m = p), ("selectionStart" in f) ? (f.selectionStart = p, f.selectionEnd = Math.min(m, f.value.length)) : (m = (p = f.ownerDocument || document) && p.defaultView || window, m.getSelection && (m = m.getSelection(), u = f.textContent.length, _ = Math.min(o.start, u), o = o.end === void 0 ? _ : Math.min(o.end, u), !m.extend && _ > o && (u = o, o = _, _ = u), u = Vo(f, _), i = Vo(f, o), u && i && (m.rangeCount !== 1 || m.anchorNode !== u.node || m.anchorOffset !== u.offset || m.focusNode !== i.node || m.focusOffset !== i.offset) && (p = p.createRange(), p.setStart(u.node, u.offset), m.removeAllRanges(), _ > o ? (m.addRange(p), m.extend(i.node, i.offset)) : (p.setEnd(i.node, i.offset), m.addRange(p)))))), p = [], m = f; m = m.parentNode;)m.nodeType === 1 && p.push({
                    element: m,
                    left: m.scrollLeft,
                    top: m.scrollTop
                });
                for(typeof f.focus == "function" && f.focus(), f = 0; f < p.length; f++)m = p[f], m.element.scrollLeft = m.left, m.element.scrollTop = m.top;
            }
            Bt = !!zl, Ol = zl = null, e.current = t, g = r;
            do try {
                for(f = e; g !== null;){
                    var w = g.flags;
                    if (w & 36 && af(f, g.alternate, g), w & 128) {
                        p = void 0;
                        var N = g.ref;
                        if (N !== null) {
                            var T = g.stateNode;
                            switch(g.tag){
                                case 5:
                                    p = T;
                                    break;
                                default:
                                    p = T;
                            }
                            typeof N == "function" ? N(p) : N.current = p;
                        }
                    }
                    g = g.nextEffect;
                }
            } catch (P2) {
                if (g === null) throw Error(v(330));
                Ve(g, P2), g = g.nextEffect;
            }
            while (g !== null)
            g = null, Za(), x1 = l;
        } else e.current = t;
        if (Ie) Ie = !1, yt = e, gt = n;
        else for(g = r; g !== null;)n = g.nextEffect, g.nextEffect = null, g.flags & 8 && (w = g, w.sibling = null, w.stateNode = null), g = n;
        if (r = e.pendingLanes, r === 0 && (pe = null), r === 1 ? e === ki ? wt++ : (wt = 0, ki = e) : wt = 0, t = t.stateNode, Ke && typeof Ke.onCommitFiberRoot == "function") try {
            Ke.onCommitFiberRoot(Fl, t, void 0, (t.current.flags & 64) === 64);
        } catch  {}
        if (re(e, A()), kr) throw kr = !1, e = wi, wi = null, e;
        return (x1 & 8) !== 0 || ae(), null;
    }
    function vf() {
        for(; g !== null;){
            var e = g.alternate;
            _r || St === null || ((g.flags & 8) !== 0 ? uo(g, St) && (_r = !0) : g.tag === 13 && ff(e, g) && uo(g, St) && (_r = !0));
            var n = g.flags;
            (n & 256) !== 0 && sf(e, g), (n & 512) === 0 || Ie || (Ie = !0, rt(97, function() {
                return Ue(), null;
            })), g = g.nextEffect;
        }
    }
    function Ue() {
        if (gt !== 90) {
            var e = 97 < gt ? 97 : gt;
            return gt = 90, Ge(e, gf);
        }
        return !1;
    }
    function yf(e, n) {
        Si.push(n, e), Ie || (Ie = !0, rt(97, function() {
            return Ue(), null;
        }));
    }
    function vs(e, n) {
        Ei.push(n, e), Ie || (Ie = !0, rt(97, function() {
            return Ue(), null;
        }));
    }
    function gf() {
        if (yt === null) return !1;
        var e = yt;
        if (yt = null, (x1 & 48) !== 0) throw Error(v(331));
        var n = x1;
        x1 |= 32;
        var t = Ei;
        Ei = [];
        for(var r = 0; r < t.length; r += 2){
            var l = t[r], i = t[r + 1], o = l.destroy;
            if (l.destroy = void 0, typeof o == "function") try {
                o();
            } catch (s) {
                if (i === null) throw Error(v(330));
                Ve(i, s);
            }
        }
        for(t = Si, Si = [], r = 0; r < t.length; r += 2){
            l = t[r], i = t[r + 1];
            try {
                var u = l.create;
                l.destroy = u();
            } catch (s1) {
                if (i === null) throw Error(v(330));
                Ve(i, s1);
            }
        }
        for(u = e.current.firstEffect; u !== null;)e = u.nextEffect, u.nextEffect = null, u.flags & 8 && (u.sibling = null, u.stateNode = null), u = e;
        return x1 = n, ae(), !0;
    }
    function ys(e, n, t) {
        n = si(t, n), n = bu(e, n, 1), Re(e, n), n = b(), e = Nr(e, 1), e !== null && (Vt(e, 1, n), re(e, n));
    }
    function Ve(e, n) {
        if (e.tag === 3) ys(e, e, n);
        else for(var t = e.return; t !== null;){
            if (t.tag === 3) {
                ys(t, e, n);
                break;
            } else if (t.tag === 1) {
                var r = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (pe === null || !pe.has(r))) {
                    e = si(n, e);
                    var l = es(t, e, 1);
                    if (Re(t, l), l = b(), t = Nr(t, 1), t !== null) Vt(t, 1, l), re(t, l);
                    else if (typeof r.componentDidCatch == "function" && (pe === null || !pe.has(r))) try {
                        r.componentDidCatch(n, e);
                    } catch  {}
                    break;
                }
            }
            t = t.return;
        }
    }
    function wf(e, n, t) {
        var r = e.pingCache;
        r !== null && r.delete(n), n = b(), e.pingedLanes |= e.suspendedLanes & t, X === e && ($ & t) === t && (H === 4 || H === 3 && ($ & 62914560) === $ && 500 > A() - yi ? Ln(e, 0) : hi |= t), re(e, n);
    }
    function Sf(e, n) {
        var t = e.stateNode;
        t !== null && t.delete(n), n = 0, n === 0 && (n = e.mode, (n & 2) === 0 ? n = 1 : (n & 4) === 0 ? n = Sn() === 99 ? 1 : 2 : (we === 0 && (we = _n), n = fn(62914560 & ~we), n === 0 && (n = 4194304))), t = b(), e = Nr(e, n), e !== null && (Vt(e, n, t), re(e, t));
    }
    var gs;
    gs = function(e, n, t) {
        var r = n.lanes;
        if (e !== null) if (e.memoizedProps !== n.pendingProps || K.current) ue = !0;
        else if ((t & r) !== 0) ue = (e.flags & 16384) !== 0;
        else {
            switch(ue = !1, n.tag){
                case 3:
                    Au(n), Gl();
                    break;
                case 5:
                    Cu(n);
                    break;
                case 1:
                    G(n.type) && nr(n);
                    break;
                case 4:
                    Yl(n, n.stateNode.containerInfo);
                    break;
                case 10:
                    r = n.memoizedProps.value;
                    var l = n.type._context;
                    R(lr, l._currentValue), l._currentValue = r;
                    break;
                case 13:
                    if (n.memoizedState !== null) return (t & n.child.childLanes) !== 0 ? Qu(e, n, t) : (R(D, D.current & 1), n = ye(e, n, t), n !== null ? n.sibling : null);
                    R(D, D.current & 1);
                    break;
                case 19:
                    if (r = (t & n.childLanes) !== 0, (e.flags & 64) !== 0) {
                        if (r) return Gu(e, n, t);
                        n.flags |= 64;
                    }
                    if (l = n.memoizedState, l !== null && (l.rendering = null, l.tail = null, l.lastEffect = null), R(D, D.current), r) break;
                    return null;
                case 23:
                case 24:
                    return n.lanes = 0, ri(e, n, t);
            }
            return ye(e, n, t);
        }
        else ue = !1;
        switch(n.lanes = 0, n.tag){
            case 2:
                if (r = n.type, e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2), e = n.pendingProps, l = wn(n, W.current), kn(n, t), l = ql(null, n, r, e, l, t), n.flags |= 1, typeof l == "object" && l !== null && typeof l.render == "function" && l.$$typeof === void 0) {
                    if (n.tag = 1, n.memoizedState = null, n.updateQueue = null, G(r)) {
                        var i = !0;
                        nr(n);
                    } else i = !1;
                    n.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, Ql(n);
                    var o = r.getDerivedStateFromProps;
                    typeof o == "function" && ur(n, r, o, e), l.updater = sr, n.stateNode = l, l._reactInternals = n, $l(n, r, e, t), n = ii(null, n, r, !0, i, t);
                } else n.tag = 0, J(null, n, l, t), n = n.child;
                return n;
            case 16:
                l = n.elementType;
                e: {
                    switch(e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2), e = n.pendingProps, i = l._init, l = i(l._payload), n.type = l, i = n.tag = kf(l), e = oe(l, e), i){
                        case 0:
                            n = li(null, n, l, e, t);
                            break e;
                        case 1:
                            n = Wu(null, n, l, e, t);
                            break e;
                        case 11:
                            n = Uu(null, n, l, e, t);
                            break e;
                        case 14:
                            n = Vu(null, n, l, oe(l.type, e), r, t);
                            break e;
                    }
                    throw Error(v(306, l, ""));
                }
                return n;
            case 0:
                return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : oe(r, l), li(e, n, r, l, t);
            case 1:
                return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : oe(r, l), Wu(e, n, r, l, t);
            case 3:
                if (Au(n), r = n.updateQueue, e === null || r === null) throw Error(v(282));
                if (r = n.pendingProps, l = n.memoizedState, l = l !== null ? l.element : null, hu(e, n), lt(n, r, null, t), r = n.memoizedState.element, r === l) Gl(), n = ye(e, n, t);
                else {
                    if (l = n.stateNode, (i = l.hydrate) && (De = hn(n.stateNode.containerInfo.firstChild), ve = n, i = ce = !0), i) {
                        if (e = l.mutableSourceEagerHydrationData, e != null) for(l = 0; l < e.length; l += 2)i = e[l], i._workInProgressVersionPrimary = e[l + 1], Cn.push(i);
                        for(t = xu(n, null, r, t), n.child = t; t;)t.flags = t.flags & -3 | 1024, t = t.sibling;
                    } else J(e, n, r, t), Gl();
                    n = n.child;
                }
                return n;
            case 5:
                return Cu(n), e === null && Kl(n), r = n.type, l = n.pendingProps, i = e !== null ? e.memoizedProps : null, o = l.children, Ml(r, l) ? o = null : i !== null && Ml(r, i) && (n.flags |= 16), Hu(e, n), J(e, n, o, t), n.child;
            case 6:
                return e === null && Kl(n), null;
            case 13:
                return Qu(e, n, t);
            case 4:
                return Yl(n, n.stateNode.containerInfo), r = n.pendingProps, e === null ? n.child = cr(n, null, r, t) : J(e, n, r, t), n.child;
            case 11:
                return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : oe(r, l), Uu(e, n, r, l, t);
            case 7:
                return J(e, n, n.pendingProps, t), n.child;
            case 8:
                return J(e, n, n.pendingProps.children, t), n.child;
            case 12:
                return J(e, n, n.pendingProps.children, t), n.child;
            case 10:
                e: {
                    r = n.type._context, l = n.pendingProps, o = n.memoizedProps, i = l.value;
                    var u = n.type._context;
                    if (R(lr, u._currentValue), u._currentValue = i, o !== null) if (u = o.value, i = ee(u, i) ? 0 : (typeof r._calculateChangedBits == "function" ? r._calculateChangedBits(u, i) : 1073741823) | 0, i === 0) {
                        if (o.children === l.children && !K.current) {
                            n = ye(e, n, t);
                            break e;
                        }
                    } else for(u = n.child, u !== null && (u.return = n); u !== null;){
                        var s = u.dependencies;
                        if (s !== null) {
                            o = u.child;
                            for(var d = s.firstContext; d !== null;){
                                if (d.context === r && (d.observedBits & i) !== 0) {
                                    u.tag === 1 && (d = Me1(-1, t & -t), d.tag = 2, Re(u, d)), u.lanes |= t, d = u.alternate, d !== null && (d.lanes |= t), mu(u.return, t), s.lanes |= t;
                                    break;
                                }
                                d = d.next;
                            }
                        } else o = u.tag === 10 && u.type === n.type ? null : u.child;
                        if (o !== null) o.return = u;
                        else for(o = u; o !== null;){
                            if (o === n) {
                                o = null;
                                break;
                            }
                            if (u = o.sibling, u !== null) {
                                u.return = o.return, o = u;
                                break;
                            }
                            o = o.return;
                        }
                        u = o;
                    }
                    J(e, n, l.children, t), n = n.child;
                }
                return n;
            case 9:
                return l = n.type, i = n.pendingProps, r = i.children, kn(n, t), l = ne(l, i.unstable_observedBits), r = r(l), n.flags |= 1, J(e, n, r, t), n.child;
            case 14:
                return l = n.type, i = oe(l, n.pendingProps), i = oe(l.type, i), Vu(e, n, l, i, r, t);
            case 15:
                return Bu(e, n, n.type, n.pendingProps, r, t);
            case 17:
                return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : oe(r, l), e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2), n.tag = 1, G(r) ? (e = !0, nr(n)) : e = !1, kn(n, t), Su(n, r, l), $l(n, r, l, t), ii(null, n, r, !0, e, t);
            case 19:
                return Gu(e, n, t);
            case 23:
                return ri(e, n, t);
            case 24:
                return ri(e, n, t);
        }
        throw Error(v(156, n.tag));
    };
    function Ef(e, n, t, r) {
        this.tag = e, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function le(e, n, t, r) {
        return new Ef(e, n, t, r);
    }
    function _i(e) {
        return e = e.prototype, !(!e || !e.isReactComponent);
    }
    function kf(e) {
        if (typeof e == "function") return _i(e) ? 1 : 0;
        if (e != null) {
            if (e = e.$$typeof, e === Nt) return 11;
            if (e === Tt) return 14;
        }
        return 2;
    }
    function Be(e, n) {
        var t = e.alternate;
        return t === null ? (t = le(e.tag, n, e.key, e.mode), t.elementType = e.elementType, t.type = e.type, t.stateNode = e.stateNode, t.alternate = e, e.alternate = t) : (t.pendingProps = n, t.type = e.type, t.flags = 0, t.nextEffect = null, t.firstEffect = null, t.lastEffect = null), t.childLanes = e.childLanes, t.lanes = e.lanes, t.child = e.child, t.memoizedProps = e.memoizedProps, t.memoizedState = e.memoizedState, t.updateQueue = e.updateQueue, n = e.dependencies, t.dependencies = n === null ? null : {
            lanes: n.lanes,
            firstContext: n.firstContext
        }, t.sibling = e.sibling, t.index = e.index, t.ref = e.ref, t;
    }
    function Tr(e, n, t, r, l, i) {
        var o = 2;
        if (r = e, typeof e == "function") _i(e) && (o = 1);
        else if (typeof e == "string") o = 5;
        else e: switch(e){
            case Ee:
                return zn(t.children, l, i, n);
            case Vi:
                o = 8, l |= 16;
                break;
            case Fr:
                o = 8, l |= 1;
                break;
            case Rn:
                return e = le(12, t, n, l | 8), e.elementType = Rn, e.type = Rn, e.lanes = i, e;
            case Dn:
                return e = le(13, t, n, l), e.type = Dn, e.elementType = Dn, e.lanes = i, e;
            case Pt:
                return e = le(19, t, n, l), e.elementType = Pt, e.lanes = i, e;
            case Wr:
                return Ni(t, l, i, n);
            case Ar:
                return e = le(24, t, n, l), e.elementType = Ar, e.lanes = i, e;
            default:
                if (typeof e == "object" && e !== null) switch(e.$$typeof){
                    case jr:
                        o = 10;
                        break e;
                    case Ur:
                        o = 9;
                        break e;
                    case Nt:
                        o = 11;
                        break e;
                    case Tt:
                        o = 14;
                        break e;
                    case Vr:
                        o = 16, r = null;
                        break e;
                    case Br:
                        o = 22;
                        break e;
                }
                throw Error(v(130, e == null ? e : typeof e, ""));
        }
        return n = le(o, t, n, l), n.elementType = e, n.type = r, n.lanes = i, n;
    }
    function zn(e, n, t, r) {
        return e = le(7, e, r, n), e.lanes = t, e;
    }
    function Ni(e, n, t, r) {
        return e = le(23, e, r, n), e.elementType = Wr, e.lanes = t, e;
    }
    function Pi(e, n, t) {
        return e = le(6, e, null, n), e.lanes = t, e;
    }
    function Ti(e, n, t) {
        return n = le(4, e.children !== null ? e.children : [], e.key, n), n.lanes = t, n.stateNode = {
            containerInfo: e.containerInfo,
            pendingChildren: null,
            implementation: e.implementation
        }, n;
    }
    function xf(e, n, t) {
        this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.pendingContext = this.context = null, this.hydrate = t, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = hl(0), this.expirationTimes = hl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = hl(0), this.mutableSourceEagerHydrationData = null;
    }
    function Cf(e, n, t) {
        var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: Ae,
            key: r == null ? null : "" + r,
            children: e,
            containerInfo: n,
            implementation: t
        };
    }
    function Lr(e, n, t, r) {
        var l = n.current, i = b(), o = Fe(l);
        e: if (t) {
            t = t._reactInternals;
            n: {
                if ($e(t) !== t || t.tag !== 1) throw Error(v(170));
                var u = t;
                do {
                    switch(u.tag){
                        case 3:
                            u = u.stateNode.context;
                            break n;
                        case 1:
                            if (G(u.type)) {
                                u = u.stateNode.__reactInternalMemoizedMergedChildContext;
                                break n;
                            }
                    }
                    u = u.return;
                }while (u !== null)
                throw Error(v(171));
            }
            if (t.tag === 1) {
                var s = t.type;
                if (G(s)) {
                    t = lu(t, s, u);
                    break e;
                }
            }
            t = u;
        } else t = ze;
        return n.context === null ? n.context = t : n.pendingContext = t, n = Me1(i, o), n.payload = {
            element: e
        }, r = r === void 0 ? null : r, r !== null && (n.callback = r), Re(l, n), je(l, o, i), o;
    }
    function Li(e) {
        if (e = e.current, !e.child) return null;
        switch(e.child.tag){
            case 5:
                return e.child.stateNode;
            default:
                return e.child.stateNode;
        }
    }
    function ws(e, n) {
        if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
            var t = e.retryLane;
            e.retryLane = t !== 0 && t < n ? t : n;
        }
    }
    function zi(e, n) {
        ws(e, n), (e = e.alternate) && ws(e, n);
    }
    function _f() {
        return null;
    }
    function Oi(e, n, t) {
        var r = t != null && t.hydrationOptions != null && t.hydrationOptions.mutableSources || null;
        if (t = new xf(e, n, t != null && t.hydrate === !0), n = le(3, null, null, n === 2 ? 7 : n === 1 ? 3 : 0), t.current = n, n.stateNode = t, Ql(n), e[vn] = t.current, Xo(e.nodeType === 8 ? e.parentNode : e), r) for(e = 0; e < r.length; e++){
            n = r[e];
            var l = n._getVersion;
            l = l(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [
                n,
                l
            ] : t.mutableSourceEagerHydrationData.push(n, l);
        }
        this._internalRoot = t;
    }
    Oi.prototype.render = function(e) {
        Lr(e, this._internalRoot, null, null);
    };
    Oi.prototype.unmount = function() {
        var e = this._internalRoot, n = e.containerInfo;
        Lr(null, e, null, function() {
            n[vn] = null;
        });
    };
    function kt(e) {
        return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "));
    }
    function Nf(e, n) {
        if (n || (n = e ? e.nodeType === 9 ? e.documentElement : e.firstChild : null, n = !(!n || n.nodeType !== 1 || !n.hasAttribute("data-reactroot"))), !n) for(var t; t = e.lastChild;)e.removeChild(t);
        return new Oi(e, 0, n ? {
            hydrate: !0
        } : void 0);
    }
    function zr(e, n, t, r, l) {
        var i = t._reactRootContainer;
        if (i) {
            var o = i._internalRoot;
            if (typeof l == "function") {
                var u = l;
                l = function() {
                    var d = Li(o);
                    u.call(d);
                };
            }
            Lr(n, o, e, l);
        } else {
            if (i = t._reactRootContainer = Nf(t, r), o = i._internalRoot, typeof l == "function") {
                var s = l;
                l = function() {
                    var d = Li(o);
                    s.call(d);
                };
            }
            cs(function() {
                Lr(n, o, e, l);
            });
        }
        return Li(o);
    }
    so = function(e) {
        if (e.tag === 13) {
            var n = b();
            je(e, 4, n), zi(e, 4);
        }
    };
    al = function(e) {
        if (e.tag === 13) {
            var n = b();
            je(e, 67108864, n), zi(e, 67108864);
        }
    };
    ao = function(e) {
        if (e.tag === 13) {
            var n = b(), t = Fe(e);
            je(e, t, n), zi(e, t);
        }
    };
    fo = function(e, n) {
        return n();
    };
    tl = function(e, n, t) {
        switch(n){
            case "input":
                if (Xr(e, t), n = t.name, t.type === "radio" && n != null) {
                    for(t = e; t.parentNode;)t = t.parentNode;
                    for(t = t.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < t.length; n++){
                        var r = t[n];
                        if (r !== e && r.form === e.form) {
                            var l = bt(r);
                            if (!l) throw Error(v(90));
                            Wi(r), Xr(r, l);
                        }
                    }
                }
                break;
            case "textarea":
                Xi(e, t);
                break;
            case "select":
                n = t.value, n != null && rn(e, !!t.multiple, n, !1);
        }
    };
    rl = fs;
    to = function(e, n, t, r, l) {
        var i = x1;
        x1 |= 4;
        try {
            return Ge(98, e.bind(null, n, t, r, l));
        } finally{
            x1 = i, x1 === 0 && (Pn(), ae());
        }
    };
    ll = function() {
        (x1 & 49) === 0 && (df(), Ue());
    };
    ro = function(e, n) {
        var t = x1;
        x1 |= 2;
        try {
            return e(n);
        } finally{
            x1 = t, x1 === 0 && (Pn(), ae());
        }
    };
    function Ss(e, n) {
        var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!kt(n)) throw Error(v(200));
        return Cf(e, n, null, t);
    }
    var Pf = {
        Events: [
            tt,
            yn,
            bt,
            eo,
            no,
            Ue,
            {
                current: !1
            }
        ]
    }, xt = {
        findFiberByHostInstance: Ye,
        bundleType: 0,
        version: "17.0.2",
        rendererPackageName: "react-dom"
    }, Tf = {
        bundleType: xt.bundleType,
        version: xt.version,
        rendererPackageName: xt.rendererPackageName,
        rendererConfig: xt.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: We.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(e) {
            return e = oo(e), e === null ? null : e.stateNode;
        },
        findFiberByHostInstance: xt.findFiberByHostInstance || _f,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" && (Ct = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Ct.isDisabled && Ct.supportsFiber)) try {
        Fl = Ct.inject(Tf), Ke = Ct;
    } catch  {}
    var Ct;
    ie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Pf;
    ie.createPortal = Ss;
    ie.findDOMNode = function(e) {
        if (e == null) return null;
        if (e.nodeType === 1) return e;
        var n = e._reactInternals;
        if (n === void 0) throw typeof e.render == "function" ? Error(v(188)) : Error(v(268, Object.keys(e)));
        return e = oo(n), e = e === null ? null : e.stateNode, e;
    };
    ie.flushSync = function(e, n) {
        var t = x1;
        if ((t & 48) !== 0) return e(n);
        x1 |= 1;
        try {
            if (e) return Ge(99, e.bind(null, n));
        } finally{
            x1 = t, ae();
        }
    };
    ie.hydrate = function(e, n, t) {
        if (!kt(n)) throw Error(v(200));
        return zr(null, e, n, !0, t);
    };
    ie.render = function(e, n, t) {
        if (!kt(n)) throw Error(v(200));
        return zr(null, e, n, !1, t);
    };
    ie.unmountComponentAtNode = function(e) {
        if (!kt(e)) throw Error(v(40));
        return e._reactRootContainer ? (cs(function() {
            zr(null, null, e, !1, function() {
                e._reactRootContainer = null, e[vn] = null;
            });
        }), !0) : !1;
    };
    ie.unstable_batchedUpdates = fs;
    ie.unstable_createPortal = function(e, n) {
        return Ss(e, n, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
    };
    ie.unstable_renderSubtreeIntoContainer = function(e, n, t, r) {
        if (!kt(t)) throw Error(v(200));
        if (e == null || e._reactInternals === void 0) throw Error(v(38));
        return zr(e, n, t, !1, r);
    };
    ie.version = "17.0.2";
});
var Mi = Ri((Of, xs)=>{
    "use strict";
    function ks() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ks);
        } catch (e) {
            console.error(e);
        }
    }
    ks(), xs.exports = Es();
});
var Cs = Di(Mi()), _s = Di(Mi()), { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: Mf , createPortal: Rf , findDOMNode: Df , flushSync: If , hydrate: Ff , render: jf , unmountComponentAtNode: Uf , unstable_batchedUpdates: Vf , unstable_createPortal: Bf , unstable_renderSubtreeIntoContainer: Hf , version: Wf  } = _s, Af = Cs.default || _s;
var v3 = Me.createContext(null);
function Ae1(e) {
    e();
}
var be2 = Ae1, we2 = function(r) {
    return be2 = r;
}, Ce3 = function() {
    return be2;
};
function je1() {
    var e = Ce3(), r = null, t = null;
    return {
        clear: function() {
            r = null, t = null;
        },
        notify: function() {
            e(function() {
                for(var n = r; n;)n.callback(), n = n.next;
            });
        },
        get: function() {
            for(var n = [], i = r; i;)n.push(i), i = i.next;
            return n;
        },
        subscribe: function(n) {
            var i = !0, o = t = {
                callback: n,
                next: null,
                prev: t
            };
            return o.prev ? o.prev.next = o : r = o, function() {
                !i || r === null || (i = !1, o.next ? o.next.prev = o.prev : t = o.prev, o.prev ? o.prev.next = o.next : r = o.next);
            };
        }
    };
}
var ge2 = {
    notify: function() {},
    get: function() {
        return [];
    }
};
function _1(e, r) {
    var t, a = ge2;
    function n(f) {
        return c(), a.subscribe(f);
    }
    function i() {
        a.notify();
    }
    function o() {
        u.onStateChange && u.onStateChange();
    }
    function s() {
        return Boolean(t);
    }
    function c() {
        t || (t = r ? r.addNestedSub(o) : e.subscribe(o), a = je1());
    }
    function p() {
        t && (t(), t = void 0, a.clear(), a = ge2);
    }
    var u = {
        addNestedSub: n,
        notifyNestedSubs: i,
        handleChangeWrapper: o,
        isSubscribed: s,
        trySubscribe: c,
        tryUnsubscribe: p,
        getListeners: function() {
            return a;
        }
    };
    return u;
}
var T = typeof window != "undefined" && typeof window.document != "undefined" && typeof window.document.createElement != "undefined" ? we : xe;
function Ye(e) {
    var r = e.store, t = e.context, a = e.children, n = Ae(function() {
        var s = _1(r);
        return s.onStateChange = s.notifyNestedSubs, {
            store: r,
            subscription: s
        };
    }, [
        r
    ]), i = Ae(function() {
        return r.getState();
    }, [
        r
    ]);
    T(function() {
        var s = n.subscription;
        return s.trySubscribe(), i !== r.getState() && s.notifyNestedSubs(), function() {
            s.tryUnsubscribe(), s.onStateChange = null;
        };
    }, [
        n,
        i
    ]);
    var o = t || v3;
    return Me.createElement(o.Provider, {
        value: n
    }, a);
}
var Ke = Ye;
var Je = [
    "getDisplayName",
    "methodName",
    "renderCountProp",
    "shouldHandleStateChanges",
    "storeKey",
    "withRef",
    "forwardRef",
    "context"
], ze = [
    "reactReduxForwardedRef"
], Ze = [], er = [
    null,
    null
];
function rr(e, r) {
    var t = e[1];
    return [
        r.payload,
        t + 1
    ];
}
function Ne(e, r, t) {
    T(function() {
        return e.apply(void 0, r);
    }, t);
}
function tr(e, r, t, a, n, i, o) {
    e.current = a, r.current = n, t.current = !1, i.current && (i.current = null, o());
}
function or(e, r, t, a, n, i, o, s, c, p) {
    if (!!e) {
        var u = !1, f = null, l = function() {
            if (!u) {
                var b = r.getState(), h, m;
                try {
                    h = a(b, n.current);
                } catch (g) {
                    m = g, f = g;
                }
                m || (f = null), h === i.current ? o.current || c() : (i.current = h, s.current = h, o.current = !0, p({
                    type: "STORE_UPDATED",
                    payload: {
                        error: m
                    }
                }));
            }
        };
        t.onStateChange = l, t.trySubscribe(), l();
        var d = function() {
            if (u = !0, t.tryUnsubscribe(), t.onStateChange = null, f) throw f;
        };
        return d;
    }
}
var nr = function() {
    return [
        null,
        0
    ];
};
function Q4(e, r) {
    r === void 0 && (r = {});
    var t = r, a = t.getDisplayName, n = a === void 0 ? function(E) {
        return "ConnectAdvanced(" + E + ")";
    } : a, i = t.methodName, o = i === void 0 ? "connectAdvanced" : i, s = t.renderCountProp, c = s === void 0 ? void 0 : s, p = t.shouldHandleStateChanges, u = p === void 0 ? !0 : p, f1 = t.storeKey, l = f1 === void 0 ? "store" : f1, d = t.withRef, b = t.forwardRef, h = b === void 0 ? !1 : b, m = t.context, g = m === void 0 ? v3 : m, x = f(t, Je);
    if (!1) ;
    var C = g;
    return function(w) {
        var U = w.displayName || w.name || "Component", V = n(U), L = a1({}, x, {
            getDisplayName: n,
            methodName: o,
            renderCountProp: c,
            shouldHandleStateChanges: u,
            storeKey: l,
            displayName: V,
            wrappedComponentName: U,
            WrappedComponent: w
        }), B = x.pure;
        function te(P) {
            return e(P.dispatch, L);
        }
        var oe = B ? Ae : function(P) {
            return P();
        };
        function $(P) {
            var k = Ae(function() {
                var A = P.reactReduxForwardedRef, ce = f(P, ze);
                return [
                    P.context,
                    A,
                    ce
                ];
            }, [
                P
            ]), M = k[0], me = k[1], I = k[2], ne = Ae(function() {
                return M && M.Consumer && ce(Me.createElement(M.Consumer, null)) ? M : C;
            }, [
                M,
                C
            ]), R = Pe(ne), H = Boolean(P.store) && Boolean(P.store.getState) && Boolean(P.store.dispatch), Vr = Boolean(R) && Boolean(R.store), O = H ? P.store : R.store, ae = Ae(function() {
                return te(O);
            }, [
                O
            ]), ve = Ae(function() {
                if (!u) return er;
                var A = _1(O, H ? null : R.subscription), ce = A.notifyNestedSubs.bind(A);
                return [
                    A,
                    ce
                ];
            }, [
                O,
                H,
                R
            ]), Y = ve[0], he = ve[1], Pe1 = Ae(function() {
                return H ? R : a1({}, R, {
                    subscription: Y
                });
            }, [
                H,
                R,
                Y
            ]), ye = Fe(rr, Ze, nr), $e = ye[0], K = $e[0], ke = ye[1];
            if (K && K.error) throw K.error;
            var xe = Le(), ie = Le(I), J = Le(), Se = Le(!1), ue = oe(function() {
                return J.current && I === ie.current ? J.current : ae(O.getState(), I);
            }, [
                O,
                K,
                I
            ]);
            Ne(tr, [
                ie,
                xe,
                Se,
                I,
                ue,
                J,
                he
            ]), Ne(or, [
                u,
                O,
                Y,
                ae,
                ie,
                xe,
                Se,
                J,
                he,
                ke
            ], [
                O,
                Y,
                ae
            ]);
            var se = Ae(function() {
                return Me.createElement(w, a1({}, ue, {
                    ref: me
                }));
            }, [
                me,
                w,
                ue
            ]), Ie = Ae(function() {
                return u ? Me.createElement(ne.Provider, {
                    value: Pe1
                }, se) : se;
            }, [
                ne,
                se,
                Pe1
            ]);
            return Ie;
        }
        var F = B ? Me.memo($) : $;
        if (F.WrappedComponent = w, F.displayName = $.displayName = V, h) {
            var W = Me.forwardRef(function(k, M) {
                return Me.createElement(F, a1({}, k, {
                    reactReduxForwardedRef: M
                }));
            });
            return W.displayName = V, W.WrappedComponent = w, B2(W, w);
        }
        return B2(F, w);
    };
}
function Me2(e, r) {
    return e === r ? e !== 0 || r !== 0 || 1 / e === 1 / r : e !== e && r !== r;
}
function q3(e, r) {
    if (Me2(e, r)) return !0;
    if (typeof e != "object" || e === null || typeof r != "object" || r === null) return !1;
    var t = Object.keys(e), a = Object.keys(r);
    if (t.length !== a.length) return !1;
    for(var n = 0; n < t.length; n++)if (!Object.prototype.hasOwnProperty.call(r, t[n]) || !Me2(e[t[n]], r[t[n]])) return !1;
    return !0;
}
function pe4(e, r) {
    var t = {}, a = function(o) {
        var s = e[o];
        typeof s == "function" && (t[o] = function() {
            return r(s.apply(void 0, arguments));
        });
    };
    for(var n in e)a(n);
    return t;
}
function j3(e) {
    return function(t, a) {
        var n = e(t, a);
        function i() {
            return n;
        }
        return i.dependsOnOwnProps = !1, i;
    };
}
function Te1(e) {
    return e.dependsOnOwnProps !== null && e.dependsOnOwnProps !== void 0 ? Boolean(e.dependsOnOwnProps) : e.length !== 1;
}
function X4(e, r) {
    return function(a, n) {
        var i = n.displayName, o = function(c, p) {
            return o.dependsOnOwnProps ? o.mapToProps(c, p) : o.mapToProps(c);
        };
        return o.dependsOnOwnProps = !0, o.mapToProps = function(c, p) {
            o.mapToProps = e, o.dependsOnOwnProps = Te1(e);
            var u = o(c, p);
            return typeof u == "function" && (o.mapToProps = u, o.dependsOnOwnProps = Te1(u), u = o(c, p)), u;
        }, o;
    };
}
function ir(e) {
    return typeof e == "function" ? X4(e, "mapDispatchToProps") : void 0;
}
function ur(e) {
    return e ? void 0 : j3(function(r) {
        return {
            dispatch: r
        };
    });
}
function sr(e) {
    return e && typeof e == "object" ? j3(function(r) {
        return pe4(e, r);
    }) : void 0;
}
var Fe1 = [
    ir,
    ur,
    sr
];
function cr(e) {
    return typeof e == "function" ? X4(e, "mapStateToProps") : void 0;
}
function pr(e) {
    return e ? void 0 : j3(function() {
        return {};
    });
}
var _e3 = [
    cr,
    pr
];
function dr(e, r, t) {
    return a1({}, t, e, r);
}
function lr(e) {
    return function(t, a) {
        var n = a.displayName, i = a.pure, o = a.areMergedPropsEqual, s = !1, c;
        return function(u, f, l) {
            var d = e(u, f, l);
            return s ? (!i || !o(d, c)) && (c = d) : (s = !0, c = d), c;
        };
    };
}
function mr(e) {
    return typeof e == "function" ? lr(e) : void 0;
}
function vr(e) {
    return e ? void 0 : function() {
        return dr;
    };
}
var De1 = [
    mr,
    vr
];
var Pr = [
    "initMapStateToProps",
    "initMapDispatchToProps",
    "initMergeProps"
];
function yr(e, r, t, a) {
    return function(i, o) {
        return t(e(i, o), r(a, o), o);
    };
}
function xr(e, r, t, a, n) {
    var i = n.areStatesEqual, o = n.areOwnPropsEqual, s = n.areStatePropsEqual, c = !1, p, u, f, l, d;
    function y(x, S) {
        return p = x, u = S, f = e(p, u), l = r(a, u), d = t(f, l, u), c = !0, d;
    }
    function b() {
        return f = e(p, u), r.dependsOnOwnProps && (l = r(a, u)), d = t(f, l, u), d;
    }
    function h() {
        return e.dependsOnOwnProps && (f = e(p, u)), r.dependsOnOwnProps && (l = r(a, u)), d = t(f, l, u), d;
    }
    function m() {
        var x = e(p, u), S = !s(x, f);
        return f = x, S && (d = t(f, l, u)), d;
    }
    function g(x, S) {
        var C = !o(S, u), E = !i(x, p);
        return p = x, u = S, C && E ? b() : C ? h() : E ? m() : d;
    }
    return function(S, C) {
        return c ? g(S, C) : y(S, C);
    };
}
function fe2(e, r) {
    var t = r.initMapStateToProps, a = r.initMapDispatchToProps, n = r.initMergeProps, i = f(r, Pr), o = t(e, i), s = a(e, i), c = n(e, i), p = i.pure ? xr : yr;
    return p(o, s, c, e, i);
}
var wr = [
    "pure",
    "areStatesEqual",
    "areOwnPropsEqual",
    "areStatePropsEqual",
    "areMergedPropsEqual"
];
function de3(e, r, t) {
    for(var a = r.length - 1; a >= 0; a--){
        var n = r[a](e);
        if (n) return n;
    }
    return function(i, o) {
        throw new Error("Invalid value of type " + typeof e + " for " + t + " argument when connecting component " + o.wrappedComponentName + ".");
    };
}
function Cr(e, r) {
    return e === r;
}
function gr(e) {
    var r = e === void 0 ? {} : e, t = r.connectHOC, a = t === void 0 ? Q4 : t, n = r.mapStateToPropsFactories, i = n === void 0 ? _e3 : n, o = r.mapDispatchToPropsFactories, s = o === void 0 ? Fe1 : o, c = r.mergePropsFactories, p = c === void 0 ? De1 : c, u = r.selectorFactory, f1 = u === void 0 ? fe2 : u;
    return function(d, y, b, h) {
        h === void 0 && (h = {});
        var m = h, g = m.pure, x = g === void 0 ? !0 : g, S = m.areStatesEqual, C = S === void 0 ? Cr : S, E = m.areOwnPropsEqual, w = E === void 0 ? q3 : E, U = m.areStatePropsEqual, V = U === void 0 ? q3 : U, L = m.areMergedPropsEqual, B = L === void 0 ? q3 : L, te = f(m, wr), oe = de3(d, i, "mapStateToProps"), $ = de3(y, s, "mapDispatchToProps"), F = de3(b, p, "mergeProps");
        return a(f1, a1({
            methodName: "connect",
            getDisplayName: function(P) {
                return "Connect(" + P + ")";
            },
            shouldHandleStateChanges: Boolean(d),
            initMapStateToProps: oe,
            initMapDispatchToProps: $,
            initMergeProps: F,
            pure: x,
            areStatesEqual: C,
            areOwnPropsEqual: w,
            areStatePropsEqual: V,
            areMergedPropsEqual: B
        }, te));
    };
}
gr();
function Z4() {
    var e = Pe(v3);
    return e;
}
function ee4(e) {
    e === void 0 && (e = v3);
    var r = e === v3 ? Z4 : function() {
        return Pe(e);
    };
    return function() {
        var a = r(), n = a.store;
        return n;
    };
}
var le4 = ee4();
function qe1(e) {
    e === void 0 && (e = v3);
    var r = e === v3 ? le4 : ee4(e);
    return function() {
        var a = r();
        return a.dispatch;
    };
}
var Nr = qe1();
var Dr = function(r, t) {
    return r === t;
};
function qr(e, r, t, a) {
    var n = Fe(function(y) {
        return y + 1;
    }, 0), i = n[1], o = Ae(function() {
        return _1(t, a);
    }, [
        t,
        a
    ]), s = Le(), c = Le(), p = Le(), u = Le(), f = t.getState(), l;
    try {
        if (e !== c.current || f !== p.current || s.current) {
            var d = e(f);
            u.current === void 0 || !r(d, u.current) ? l = d : l = u.current;
        } else l = u.current;
    } catch (y) {
        throw s.current && (y.message += `
The error may be correlated with this previous error:
` + s.current.stack + `

`), y;
    }
    return T(function() {
        c.current = e, p.current = f, u.current = l, s.current = void 0;
    }), T(function() {
        function y() {
            try {
                var b = t.getState();
                if (b === p.current) return;
                var h = c.current(b);
                if (r(h, u.current)) return;
                u.current = h, p.current = b;
            } catch (m) {
                s.current = m;
            }
            i();
        }
        return o.onStateChange = y, o.trySubscribe(), y(), function() {
            return o.tryUnsubscribe();
        };
    }, [
        t,
        o
    ]), l;
}
function Ue(e) {
    e === void 0 && (e = v3);
    var r = e === v3 ? Z4 : function() {
        return Pe(e);
    };
    return function(a, n) {
        n === void 0 && (n = Dr);
        var i = r(), o = i.store, s = i.subscription, c = qr(a, n, o, s);
        return je(c), c;
    };
}
var Ur = Ue();
we2(Vf);
function o(t, e) {
    return o = Object.setPrototypeOf || function(r, p) {
        return r.__proto__ = p, r;
    }, o(t, e);
}
function f2(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, o(t, e);
}
var q4 = Object.create;
var h4 = Object.defineProperty;
var A3 = Object.getOwnPropertyDescriptor;
var M3 = Object.getOwnPropertyNames;
var z4 = Object.getPrototypeOf, B4 = Object.prototype.hasOwnProperty;
var H3 = (e)=>h4(e, "__esModule", {
        value: !0
    });
var k1 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var W3 = (e, t, n, u)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let o of M3(t))!B4.call(e, o) && (n || o !== "default") && h4(e, o, {
        get: ()=>t[o],
        enumerable: !(u = A3(t, o)) || u.enumerable
    });
    return e;
}, b3 = (e, t)=>W3(H3(h4(e != null ? q4(z4(e)) : {}, "default", !t && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var L3 = k1((r)=>{
    "use strict";
    var y = Symbol.for("react.element"), Y = Symbol.for("react.portal"), G = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), K = Symbol.for("react.profiler"), Q = Symbol.for("react.provider"), X = Symbol.for("react.context"), Z = Symbol.for("react.forward_ref"), ee = Symbol.for("react.suspense"), te = Symbol.for("react.memo"), re = Symbol.for("react.lazy"), w = Symbol.iterator;
    function ne(e) {
        return e === null || typeof e != "object" ? null : (e = w && e[w] || e["@@iterator"], typeof e == "function" ? e : null);
    }
    var j = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }, I = Object.assign, g = {};
    function p(e, t, n) {
        this.props = e, this.context = t, this.refs = g, this.updater = n || j;
    }
    p.prototype.isReactComponent = {};
    p.prototype.setState = function(e, t) {
        if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, e, t, "setState");
    };
    p.prototype.forceUpdate = function(e) {
        this.updater.enqueueForceUpdate(this, e, "forceUpdate");
    };
    function P() {}
    P.prototype = p.prototype;
    function S(e, t, n) {
        this.props = e, this.context = t, this.refs = g, this.updater = n || j;
    }
    var E = S.prototype = new P;
    E.constructor = S;
    I(E, p.prototype);
    E.isPureReactComponent = !0;
    var x = Array.isArray, T = Object.prototype.hasOwnProperty, R = {
        current: null
    }, D = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function V(e, t, n) {
        var u, o = {}, c = null, f = null;
        if (t != null) for(u in t.ref !== void 0 && (f = t.ref), t.key !== void 0 && (c = "" + t.key), t)T.call(t, u) && !D.hasOwnProperty(u) && (o[u] = t[u]);
        var i = arguments.length - 2;
        if (i === 1) o.children = n;
        else if (1 < i) {
            for(var s = Array(i), a = 0; a < i; a++)s[a] = arguments[a + 2];
            o.children = s;
        }
        if (e && e.defaultProps) for(u in i = e.defaultProps, i)o[u] === void 0 && (o[u] = i[u]);
        return {
            $$typeof: y,
            type: e,
            key: c,
            ref: f,
            props: o,
            _owner: R.current
        };
    }
    function oe(e, t) {
        return {
            $$typeof: y,
            type: e.type,
            key: t,
            ref: e.ref,
            props: e.props,
            _owner: e._owner
        };
    }
    function C(e) {
        return typeof e == "object" && e !== null && e.$$typeof === y;
    }
    function ue(e) {
        var t = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + e.replace(/[=:]/g, function(n) {
            return t[n];
        });
    }
    var O = /\/+/g;
    function v(e, t) {
        return typeof e == "object" && e !== null && e.key != null ? ue("" + e.key) : t.toString(36);
    }
    function _(e, t, n, u, o) {
        var c = typeof e;
        (c === "undefined" || c === "boolean") && (e = null);
        var f = !1;
        if (e === null) f = !0;
        else switch(c){
            case "string":
            case "number":
                f = !0;
                break;
            case "object":
                switch(e.$$typeof){
                    case y:
                    case Y:
                        f = !0;
                }
        }
        if (f) return f = e, o = o(f), e = u === "" ? "." + v(f, 0) : u, x(o) ? (n = "", e != null && (n = e.replace(O, "$&/") + "/"), _(o, t, n, "", function(a) {
            return a;
        })) : o != null && (C(o) && (o = oe(o, n + (!o.key || f && f.key === o.key ? "" : ("" + o.key).replace(O, "$&/") + "/") + e)), t.push(o)), 1;
        if (f = 0, u = u === "" ? "." : u + ":", x(e)) for(var i = 0; i < e.length; i++){
            c = e[i];
            var s = u + v(c, i);
            f += _(c, t, n, s, o);
        }
        else if (s = ne(e), typeof s == "function") for(e = s.call(e), i = 0; !(c = e.next()).done;)c = c.value, s = u + v(c, i++), f += _(c, t, n, s, o);
        else if (c === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
        return f;
    }
    function d(e, t, n) {
        if (e == null) return e;
        var u = [], o = 0;
        return _(e, u, "", "", function(c) {
            return t.call(n, c, o++);
        }), u;
    }
    function se(e) {
        if (e._status === -1) {
            var t = e._result;
            t = t(), t.then(function(n) {
                (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n);
            }, function(n) {
                (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n);
            }), e._status === -1 && (e._status = 0, e._result = t);
        }
        if (e._status === 1) return e._result.default;
        throw e._result;
    }
    var l = {
        current: null
    }, m = {
        transition: null
    }, ce = {
        ReactCurrentDispatcher: l,
        ReactCurrentBatchConfig: m,
        ReactCurrentOwner: R
    };
    r.Children = {
        map: d,
        forEach: function(e, t, n) {
            d(e, function() {
                t.apply(this, arguments);
            }, n);
        },
        count: function(e) {
            var t = 0;
            return d(e, function() {
                t++;
            }), t;
        },
        toArray: function(e) {
            return d(e, function(t) {
                return t;
            }) || [];
        },
        only: function(e) {
            if (!C(e)) throw Error("React.Children.only expected to receive a single React element child.");
            return e;
        }
    };
    r.Component = p;
    r.Fragment = G;
    r.Profiler = K;
    r.PureComponent = S;
    r.StrictMode = J;
    r.Suspense = ee;
    r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ce;
    r.cloneElement = function(e, t, n) {
        if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
        var u = I({}, e.props), o = e.key, c = e.ref, f = e._owner;
        if (t != null) {
            if (t.ref !== void 0 && (c = t.ref, f = R.current), t.key !== void 0 && (o = "" + t.key), e.type && e.type.defaultProps) var i = e.type.defaultProps;
            for(s in t)T.call(t, s) && !D.hasOwnProperty(s) && (u[s] = t[s] === void 0 && i !== void 0 ? i[s] : t[s]);
        }
        var s = arguments.length - 2;
        if (s === 1) u.children = n;
        else if (1 < s) {
            i = Array(s);
            for(var a = 0; a < s; a++)i[a] = arguments[a + 2];
            u.children = i;
        }
        return {
            $$typeof: y,
            type: e.type,
            key: o,
            ref: c,
            props: u,
            _owner: f
        };
    };
    r.createContext = function(e) {
        return e = {
            $$typeof: X,
            _currentValue: e,
            _currentValue2: e,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        }, e.Provider = {
            $$typeof: Q,
            _context: e
        }, e.Consumer = e;
    };
    r.createElement = V;
    r.createFactory = function(e) {
        var t = V.bind(null, e);
        return t.type = e, t;
    };
    r.createRef = function() {
        return {
            current: null
        };
    };
    r.forwardRef = function(e) {
        return {
            $$typeof: Z,
            render: e
        };
    };
    r.isValidElement = C;
    r.lazy = function(e) {
        return {
            $$typeof: re,
            _payload: {
                _status: -1,
                _result: e
            },
            _init: se
        };
    };
    r.memo = function(e, t) {
        return {
            $$typeof: te,
            type: e,
            compare: t === void 0 ? null : t
        };
    };
    r.startTransition = function(e) {
        var t = m.transition;
        m.transition = {};
        try {
            e();
        } finally{
            m.transition = t;
        }
    };
    r.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
    };
    r.useCallback = function(e, t) {
        return l.current.useCallback(e, t);
    };
    r.useContext = function(e) {
        return l.current.useContext(e);
    };
    r.useDebugValue = function() {};
    r.useDeferredValue = function(e) {
        return l.current.useDeferredValue(e);
    };
    r.useEffect = function(e, t) {
        return l.current.useEffect(e, t);
    };
    r.useId = function() {
        return l.current.useId();
    };
    r.useImperativeHandle = function(e, t, n) {
        return l.current.useImperativeHandle(e, t, n);
    };
    r.useInsertionEffect = function(e, t) {
        return l.current.useInsertionEffect(e, t);
    };
    r.useLayoutEffect = function(e, t) {
        return l.current.useLayoutEffect(e, t);
    };
    r.useMemo = function(e, t) {
        return l.current.useMemo(e, t);
    };
    r.useReducer = function(e, t, n) {
        return l.current.useReducer(e, t, n);
    };
    r.useRef = function(e) {
        return l.current.useRef(e);
    };
    r.useState = function(e) {
        return l.current.useState(e);
    };
    r.useSyncExternalStore = function(e, t, n) {
        return l.current.useSyncExternalStore(e, t, n);
    };
    r.useTransition = function() {
        return l.current.useTransition();
    };
    r.version = "18.0.0-fc46dba67-20220329";
});
var $3 = k1((pe, N)=>{
    "use strict";
    N.exports = L3();
});
var F2 = b3($3()), U2 = b3($3()), { Children: ye3 , Component: de4 , Fragment: _e4 , Profiler: me3 , PureComponent: he2 , StrictMode: ve2 , Suspense: Se2 , __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: Ee1 , cloneElement: Re1 , createContext: Ce4 , createElement: $e2 , createFactory: ke2 , createRef: be3 , forwardRef: we3 , isValidElement: xe2 , lazy: Oe1 , memo: je2 , startTransition: Ie2 , unstable_act: ge3 , useCallback: Pe2 , useContext: Te2 , useDebugValue: De2 , useDeferredValue: Ve , useEffect: Le1 , useId: Ne1 , useImperativeHandle: Fe2 , useInsertionEffect: Ue1 , useLayoutEffect: qe2 , useMemo: Ae2 , useReducer: Me3 , useRef: ze1 , useState: Be , useSyncExternalStore: He , useTransition: We , version: Ye1  } = U2, { default: ie2 , ...fe3 } = U2, Ge = F2.default ?? ie2 ?? fe3;
var P4 = Object.create;
var p1 = Object.defineProperty;
var R4 = Object.getOwnPropertyDescriptor;
var g4 = Object.getOwnPropertyNames;
var _2 = Object.getPrototypeOf, v4 = Object.prototype.hasOwnProperty;
var x3 = (e)=>p1(e, "__esModule", {
        value: !0
    });
var s1 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var E1 = (e, r, o, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of g4(r))!v4.call(e, t) && (o || t !== "default") && p1(e, t, {
        get: ()=>r[t],
        enumerable: !(n = R4(r, t)) || n.enumerable
    });
    return e;
}, i3 = (e, r)=>E1(x3(p1(e != null ? P4(_2(e)) : {}, "default", !r && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var y1 = s1((j, u)=>{
    "use strict";
    var S = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    u.exports = S;
});
var h5 = s1((w, l)=>{
    "use strict";
    var k = y1();
    function f() {}
    function m() {}
    m.resetWarningCache = f;
    l.exports = function() {
        function e(n, t, N, W, q, d) {
            if (d !== k) {
                var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw c.name = "Invariant Violation", c;
            }
        }
        e.isRequired = e;
        function r() {
            return e;
        }
        var o = {
            array: e,
            bigint: e,
            bool: e,
            func: e,
            number: e,
            object: e,
            string: e,
            symbol: e,
            any: e,
            arrayOf: r,
            element: e,
            elementType: e,
            instanceOf: r,
            node: e,
            objectOf: r,
            oneOf: r,
            oneOfType: r,
            shape: r,
            exact: r,
            checkPropTypes: m,
            resetWarningCache: f
        };
        return o.PropTypes = o, o;
    };
});
var a2 = s1((A, T)=>{
    T.exports = h5()();
});
var O6 = i3(a2()), b4 = i3(a2()), { array: L4 , bigint: U3 , bool: V3 , func: B5 , number: H4 , object: Y4 , string: z5 , symbol: G4 , any: J5 , arrayOf: K4 , element: M4 , elementType: Q5 , instanceOf: X5 , node: Z5 , objectOf: ee5 , oneOf: re4 , oneOfType: te4 , shape: oe3 , exact: ne3 , checkPropTypes: pe5 , resetWarningCache: se2 , PropTypes: ae3  } = b4, { default: C2 , ...I2 } = b4, ce2 = O6.default ?? C2 ?? I2;
function a3() {
    return a3 = Object.assign || function(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = arguments[t];
            for(var r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
    }, a3.apply(this, arguments);
}
function t(n) {
    return n.charAt(0) === "/";
}
function h6(n, r) {
    for(var s = r, e = s + 1, i = n.length; e < i; s += 1, e += 1)n[s] = n[e];
    n.pop();
}
function o1(n, r) {
    r === void 0 && (r = "");
    var s = n && n.split("/") || [], e = r && r.split("/") || [], i = n && t(n), g = r && t(r), p = i || g;
    if (n && t(n) ? e = s : s.length && (e.pop(), e = e.concat(s)), !e.length) return "/";
    var l;
    if (e.length) {
        var u = e[e.length - 1];
        l = u === "." || u === ".." || u === "";
    } else l = !1;
    for(var f = 0, a = e.length; a >= 0; a--){
        var c = e[a];
        c === "." ? h6(e, a) : c === ".." ? (h6(e, a), f++) : f && (h6(e, a), f--);
    }
    if (!p) for(; f--; f)e.unshift("..");
    p && e[0] !== "" && (!e[0] || !t(e[0])) && e.unshift("");
    var v = e.join("/");
    return l && v.substr(-1) !== "/" && (v += "/"), v;
}
var b5 = o1;
function l(r) {
    return r.valueOf ? r.valueOf() : Object.prototype.valueOf.call(r);
}
function n(r, e) {
    if (r === e) return !0;
    if (r == null || e == null) return !1;
    if (Array.isArray(r)) return Array.isArray(e) && r.length === e.length && r.every(function(t, i) {
        return n(t, e[i]);
    });
    if (typeof r == "object" || typeof e == "object") {
        var u = l(r), f = l(e);
        return u !== r || f !== e ? n(u, f) : Object.keys(Object.assign({}, r, e)).every(function(t) {
            return n(r[t], e[t]);
        });
    }
    return !1;
}
var c1 = n;
var a4 = !0, n1 = "Invariant failed";
function v5(i, r) {
    if (!i) {
        if (a4) throw new Error(n1);
        var o = typeof r == "function" ? r() : r, t = o ? n1 + ": " + o : n1;
        throw new Error(t);
    }
}
function K5(e) {
    return e.charAt(0) === "/" ? e : "/" + e;
}
function ee6(e) {
    return e.charAt(0) === "/" ? e.substr(1) : e;
}
function ve3(e, n) {
    return e.toLowerCase().indexOf(n.toLowerCase()) === 0 && "/?#".indexOf(e.charAt(n.length)) !== -1;
}
function se3(e, n) {
    return ve3(e, n) ? e.substr(n.length) : e;
}
function ce3(e) {
    return e.charAt(e.length - 1) === "/" ? e.slice(0, -1) : e;
}
function pe6(e) {
    var n = e || "/", f = "", c = "", t = n.indexOf("#");
    t !== -1 && (c = n.substr(t), n = n.substr(0, t));
    var p = n.indexOf("?");
    return p !== -1 && (f = n.substr(p), n = n.substr(0, p)), {
        pathname: n,
        search: f === "?" ? "" : f,
        hash: c === "#" ? "" : c
    };
}
function D2(e) {
    var n = e.pathname, f = e.search, c = e.hash, t = n || "/";
    return f && f !== "?" && (t += f.charAt(0) === "?" ? f : "?" + f), c && c !== "#" && (t += c.charAt(0) === "#" ? c : "#" + c), t;
}
function I3(e, n, f, c) {
    var t;
    typeof e == "string" ? (t = pe6(e), t.state = n) : (t = a3({}, e), t.pathname === void 0 && (t.pathname = ""), t.search ? t.search.charAt(0) !== "?" && (t.search = "?" + t.search) : t.search = "", t.hash ? t.hash.charAt(0) !== "#" && (t.hash = "#" + t.hash) : t.hash = "", n !== void 0 && t.state === void 0 && (t.state = n));
    try {
        t.pathname = decodeURI(t.pathname);
    } catch (p) {
        throw p instanceof URIError ? new URIError('Pathname "' + t.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : p;
    }
    return f && (t.key = f), c ? t.pathname ? t.pathname.charAt(0) !== "/" && (t.pathname = b5(t.pathname, c.pathname)) : t.pathname = c.pathname : t.pathname || (t.pathname = "/"), t;
}
function Ne2(e, n) {
    return e.pathname === n.pathname && e.search === n.search && e.hash === n.hash && e.key === n.key && c1(e.state, n.state);
}
function X6() {
    var e = null;
    function n(g) {
        return e = g, function() {
            e === g && (e = null);
        };
    }
    function f(g, w, l, v) {
        if (e != null) {
            var m = typeof e == "function" ? e(g, w) : e;
            typeof m == "string" ? typeof l == "function" ? l(m, v) : v(!0) : v(m !== !1);
        } else v(!0);
    }
    var c = [];
    function t(g) {
        var w = !0;
        function l() {
            w && g.apply(void 0, arguments);
        }
        return c.push(l), function() {
            w = !1, c = c.filter(function(v) {
                return v !== l;
            });
        };
    }
    function p() {
        for(var g = arguments.length, w = new Array(g), l = 0; l < g; l++)w[l] = arguments[l];
        c.forEach(function(v) {
            return v.apply(void 0, w);
        });
    }
    return {
        setPrompt: n,
        confirmTransitionTo: f,
        appendListener: t,
        notifyListeners: p
    };
}
var he3 = !!(typeof document < "u" && window.document && window.document.createElement);
function fe4(e, n) {
    n(window.confirm(e));
}
function ge4() {
    var e = window.navigator.userAgent;
    return (e.indexOf("Android 2.") !== -1 || e.indexOf("Android 4.0") !== -1) && e.indexOf("Mobile Safari") !== -1 && e.indexOf("Chrome") === -1 && e.indexOf("Windows Phone") === -1 ? !1 : window.history && "pushState" in window.history;
}
function me4() {
    return window.navigator.userAgent.indexOf("Trident") === -1;
}
function we4() {
    return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function ye4(e) {
    return e.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var ne4 = "popstate", te5 = "hashchange";
function ae4() {
    try {
        return window.history.state || {};
    } catch  {
        return {};
    }
}
function Te3(e) {
    e === void 0 && (e = {}), he3 || v5(!1);
    var n = window.history, f = ge4(), c = !me4(), t = e, p = t.forceRefresh, g = p === void 0 ? !1 : p, w = t.getUserConfirmation, l = w === void 0 ? fe4 : w, v = t.keyLength, m = v === void 0 ? 6 : v, S = e.basename ? ce3(K5(e.basename)) : "";
    function U(o) {
        var h = o || {}, a = h.key, i = h.state, s = window.location, u = s.pathname, C = s.search, L = s.hash, O = u + C + L;
        return S && (O = se3(O, S)), I3(O, i, a);
    }
    function b() {
        return Math.random().toString(36).substr(2, m);
    }
    var P = X6();
    function A(o) {
        a3(T, o), T.length = n.length, P.notifyListeners(T.location, T.action);
    }
    function M(o) {
        ye4(o) || j(U(o.state));
    }
    function B() {
        j(U(ae4()));
    }
    var V = !1;
    function j(o) {
        if (V) V = !1, A();
        else {
            var h = "POP";
            P.confirmTransitionTo(o, h, l, function(a) {
                a ? A({
                    action: h,
                    location: o
                }) : q(o);
            });
        }
    }
    function q(o) {
        var h = T.location, a = H.indexOf(h.key);
        a === -1 && (a = 0);
        var i = H.indexOf(o.key);
        i === -1 && (i = 0);
        var s = a - i;
        s && (V = !0, y(s));
    }
    var R = U(ae4()), H = [
        R.key
    ];
    function d(o) {
        return S + D2(o);
    }
    function r(o, h) {
        var a = "PUSH", i = I3(o, h, b(), T.location);
        P.confirmTransitionTo(i, a, l, function(s) {
            if (!!s) {
                var u = d(i), C = i.key, L = i.state;
                if (f) if (n.pushState({
                    key: C,
                    state: L
                }, null, u), g) window.location.href = u;
                else {
                    var O = H.indexOf(T.location.key), G = H.slice(0, O + 1);
                    G.push(i.key), H = G, A({
                        action: a,
                        location: i
                    });
                }
                else window.location.href = u;
            }
        });
    }
    function k(o, h) {
        var a = "REPLACE", i = I3(o, h, b(), T.location);
        P.confirmTransitionTo(i, a, l, function(s) {
            if (!!s) {
                var u = d(i), C = i.key, L = i.state;
                if (f) if (n.replaceState({
                    key: C,
                    state: L
                }, null, u), g) window.location.replace(u);
                else {
                    var O = H.indexOf(T.location.key);
                    O !== -1 && (H[O] = i.key), A({
                        action: a,
                        location: i
                    });
                }
                else window.location.replace(u);
            }
        });
    }
    function y(o) {
        n.go(o);
    }
    function E() {
        y(-1);
    }
    function N() {
        y(1);
    }
    var $ = 0;
    function _(o) {
        $ += o, $ === 1 && o === 1 ? (window.addEventListener(ne4, M), c && window.addEventListener(te5, B)) : $ === 0 && (window.removeEventListener(ne4, M), c && window.removeEventListener(te5, B));
    }
    var x = !1;
    function F(o) {
        o === void 0 && (o = !1);
        var h = P.setPrompt(o);
        return x || (_(1), x = !0), function() {
            return x && (x = !1, _(-1)), h();
        };
    }
    function Y(o) {
        var h = P.appendListener(o);
        return _(1), function() {
            _(-1), h();
        };
    }
    var T = {
        length: n.length,
        action: "POP",
        location: R,
        createHref: d,
        push: r,
        replace: k,
        go: y,
        goBack: E,
        goForward: N,
        block: F,
        listen: Y
    };
    return T;
}
var ie3 = "hashchange", Ee2 = {
    hashbang: {
        encodePath: function(n) {
            return n.charAt(0) === "!" ? n : "!/" + ee6(n);
        },
        decodePath: function(n) {
            return n.charAt(0) === "!" ? n.substr(1) : n;
        }
    },
    noslash: {
        encodePath: ee6,
        decodePath: K5
    },
    slash: {
        encodePath: K5,
        decodePath: K5
    }
};
function de5(e) {
    var n = e.indexOf("#");
    return n === -1 ? e : e.slice(0, n);
}
function W4() {
    var e = window.location.href, n = e.indexOf("#");
    return n === -1 ? "" : e.substring(n + 1);
}
function Pe3(e) {
    window.location.hash = e;
}
function Q6(e) {
    window.location.replace(de5(window.location.href) + "#" + e);
}
function Ce5(e) {
    e === void 0 && (e = {}), he3 || v5(!1);
    var n = window.history, f = we4(), c = e, t = c.getUserConfirmation, p = t === void 0 ? fe4 : t, g = c.hashType, w = g === void 0 ? "slash" : g, l = e.basename ? ce3(K5(e.basename)) : "", v = Ee2[w], m = v.encodePath, S = v.decodePath;
    function U() {
        var a = S(W4());
        return l && (a = se3(a, l)), I3(a);
    }
    var b = X6();
    function P(a) {
        a3(h, a), h.length = n.length, b.notifyListeners(h.location, h.action);
    }
    var A = !1, M = null;
    function B(a, i) {
        return a.pathname === i.pathname && a.search === i.search && a.hash === i.hash;
    }
    function V() {
        var a = W4(), i = m(a);
        if (a !== i) Q6(i);
        else {
            var s = U(), u = h.location;
            if (!A && B(u, s) || M === D2(s)) return;
            M = null, j(s);
        }
    }
    function j(a) {
        if (A) A = !1, P();
        else {
            var i = "POP";
            b.confirmTransitionTo(a, i, p, function(s) {
                s ? P({
                    action: i,
                    location: a
                }) : q(a);
            });
        }
    }
    function q(a) {
        var i = h.location, s = r.lastIndexOf(D2(i));
        s === -1 && (s = 0);
        var u = r.lastIndexOf(D2(a));
        u === -1 && (u = 0);
        var C = s - u;
        C && (A = !0, N(C));
    }
    var R = W4(), H = m(R);
    R !== H && Q6(H);
    var d = U(), r = [
        D2(d)
    ];
    function k(a) {
        var i = document.querySelector("base"), s = "";
        return i && i.getAttribute("href") && (s = de5(window.location.href)), s + "#" + m(l + D2(a));
    }
    function y(a, i) {
        var s = "PUSH", u = I3(a, void 0, void 0, h.location);
        b.confirmTransitionTo(u, s, p, function(C) {
            if (!!C) {
                var L = D2(u), O = m(l + L), G = W4() !== O;
                if (G) {
                    M = L, Pe3(O);
                    var z = r.lastIndexOf(D2(h.location)), Z = r.slice(0, z + 1);
                    Z.push(L), r = Z, P({
                        action: s,
                        location: u
                    });
                } else P();
            }
        });
    }
    function E(a, i) {
        var s = "REPLACE", u = I3(a, void 0, void 0, h.location);
        b.confirmTransitionTo(u, s, p, function(C) {
            if (!!C) {
                var L = D2(u), O = m(l + L), G = W4() !== O;
                G && (M = L, Q6(O));
                var z = r.indexOf(D2(h.location));
                z !== -1 && (r[z] = L), P({
                    action: s,
                    location: u
                });
            }
        });
    }
    function N(a) {
        n.go(a);
    }
    function $() {
        N(-1);
    }
    function _() {
        N(1);
    }
    var x = 0;
    function F(a) {
        x += a, x === 1 && a === 1 ? window.addEventListener(ie3, V) : x === 0 && window.removeEventListener(ie3, V);
    }
    var Y = !1;
    function T(a) {
        a === void 0 && (a = !1);
        var i = b.setPrompt(a);
        return Y || (F(1), Y = !0), function() {
            return Y && (Y = !1, F(-1)), i();
        };
    }
    function o(a) {
        var i = b.appendListener(a);
        return F(1), function() {
            F(-1), i();
        };
    }
    var h = {
        length: n.length,
        action: "POP",
        location: d,
        createHref: k,
        push: y,
        replace: E,
        go: N,
        goBack: $,
        goForward: _,
        block: T,
        listen: o
    };
    return h;
}
function oe4(e, n, f) {
    return Math.min(Math.max(e, n), f);
}
function Ae3(e) {
    e === void 0 && (e = {});
    var n = e, f = n.getUserConfirmation, c = n.initialEntries, t = c === void 0 ? [
        "/"
    ] : c, p = n.initialIndex, g = p === void 0 ? 0 : p, w = n.keyLength, l = w === void 0 ? 6 : w, v = X6();
    function m(r) {
        a3(d, r), d.length = d.entries.length, v.notifyListeners(d.location, d.action);
    }
    function S() {
        return Math.random().toString(36).substr(2, l);
    }
    var U = oe4(g, 0, t.length - 1), b = t.map(function(r) {
        return typeof r == "string" ? I3(r, void 0, S()) : I3(r, void 0, r.key || S());
    }), P = D2;
    function A(r, k) {
        var y = "PUSH", E = I3(r, k, S(), d.location);
        v.confirmTransitionTo(E, y, f, function(N) {
            if (!!N) {
                var $ = d.index, _ = $ + 1, x = d.entries.slice(0);
                x.length > _ ? x.splice(_, x.length - _, E) : x.push(E), m({
                    action: y,
                    location: E,
                    index: _,
                    entries: x
                });
            }
        });
    }
    function M(r, k) {
        var y = "REPLACE", E = I3(r, k, S(), d.location);
        v.confirmTransitionTo(E, y, f, function(N) {
            !N || (d.entries[d.index] = E, m({
                action: y,
                location: E
            }));
        });
    }
    function B(r) {
        var k = oe4(d.index + r, 0, d.entries.length - 1), y = "POP", E = d.entries[k];
        v.confirmTransitionTo(E, y, f, function(N) {
            N ? m({
                action: y,
                location: E,
                index: k
            }) : m();
        });
    }
    function V() {
        B(-1);
    }
    function j() {
        B(1);
    }
    function q(r) {
        var k = d.index + r;
        return k >= 0 && k < d.entries.length;
    }
    function R(r) {
        return r === void 0 && (r = !1), v.setPrompt(r);
    }
    function H(r) {
        return v.appendListener(r);
    }
    var d = {
        length: b.length,
        action: "POP",
        location: b[U],
        index: U,
        entries: b,
        createHref: P,
        push: A,
        replace: M,
        go: B,
        goBack: V,
        goForward: j,
        canGo: q,
        block: R,
        listen: H
    };
    return d;
}
const __object_assign$ = Object.assign;
var G5 = Object.create;
var h7 = Object.defineProperty;
var J6 = Object.getOwnPropertyDescriptor;
var K6 = Object.getOwnPropertyNames;
var Q7 = Object.getPrototypeOf, X7 = Object.prototype.hasOwnProperty;
var Z6 = (e)=>h7(e, "__esModule", {
        value: !0
    });
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (t, r)=>(typeof require != "undefined" ? require : t)[r]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var O7 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var ee7 = (e, t, r, u)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let o of K6(t))!X7.call(e, o) && (r || o !== "default") && h7(e, o, {
        get: ()=>t[o],
        enumerable: !(u = J6(t, o)) || u.enumerable
    });
    return e;
}, P5 = (e, t)=>ee7(Z6(h7(e != null ? G5(Q7(e)) : {}, "default", !t && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var z6 = O7((n)=>{
    "use strict";
    var S = __object_assign$, y = 60103, I = 60106;
    n.Fragment = 60107;
    n.StrictMode = 60108;
    n.Profiler = 60114;
    var w = 60109, A = 60110, F = 60112;
    n.Suspense = 60113;
    var L = 60115, q = 60116;
    typeof Symbol == "function" && Symbol.for && (l = Symbol.for, y = l("react.element"), I = l("react.portal"), n.Fragment = l("react.fragment"), n.StrictMode = l("react.strict_mode"), n.Profiler = l("react.profiler"), w = l("react.provider"), A = l("react.context"), F = l("react.forward_ref"), n.Suspense = l("react.suspense"), L = l("react.memo"), q = l("react.lazy"));
    var l, j = typeof Symbol == "function" && Symbol.iterator;
    function te(e) {
        return e === null || typeof e != "object" ? null : (e = j && e[j] || e["@@iterator"], typeof e == "function" ? e : null);
    }
    function _(e) {
        for(var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++)t += "&args[]=" + encodeURIComponent(arguments[r]);
        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var D = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }, M = {};
    function d(e, t, r) {
        this.props = e, this.context = t, this.refs = M, this.updater = r || D;
    }
    d.prototype.isReactComponent = {};
    d.prototype.setState = function(e, t) {
        if (typeof e != "object" && typeof e != "function" && e != null) throw Error(_(85));
        this.updater.enqueueSetState(this, e, t, "setState");
    };
    d.prototype.forceUpdate = function(e) {
        this.updater.enqueueForceUpdate(this, e, "forceUpdate");
    };
    function N() {}
    N.prototype = d.prototype;
    function C(e, t, r) {
        this.props = e, this.context = t, this.refs = M, this.updater = r || D;
    }
    var R = C.prototype = new N;
    R.constructor = C;
    S(R, d.prototype);
    R.isPureReactComponent = !0;
    var $ = {
        current: null
    }, U = Object.prototype.hasOwnProperty, T = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function V(e, t, r) {
        var u, o = {}, f = null, s = null;
        if (t != null) for(u in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (f = "" + t.key), t)U.call(t, u) && !T.hasOwnProperty(u) && (o[u] = t[u]);
        var c = arguments.length - 2;
        if (c === 1) o.children = r;
        else if (1 < c) {
            for(var i = Array(c), p = 0; p < c; p++)i[p] = arguments[p + 2];
            o.children = i;
        }
        if (e && e.defaultProps) for(u in c = e.defaultProps, c)o[u] === void 0 && (o[u] = c[u]);
        return {
            $$typeof: y,
            type: e,
            key: f,
            ref: s,
            props: o,
            _owner: $.current
        };
    }
    function re(e, t) {
        return {
            $$typeof: y,
            type: e.type,
            key: t,
            ref: e.ref,
            props: e.props,
            _owner: e._owner
        };
    }
    function k(e) {
        return typeof e == "object" && e !== null && e.$$typeof === y;
    }
    function ne(e) {
        var t = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + e.replace(/[=:]/g, function(r) {
            return t[r];
        });
    }
    var x = /\/+/g;
    function E(e, t) {
        return typeof e == "object" && e !== null && e.key != null ? ne("" + e.key) : t.toString(36);
    }
    function m(e, t, r, u, o) {
        var f = typeof e;
        (f === "undefined" || f === "boolean") && (e = null);
        var s = !1;
        if (e === null) s = !0;
        else switch(f){
            case "string":
            case "number":
                s = !0;
                break;
            case "object":
                switch(e.$$typeof){
                    case y:
                    case I:
                        s = !0;
                }
        }
        if (s) return s = e, o = o(s), e = u === "" ? "." + E(s, 0) : u, Array.isArray(o) ? (r = "", e != null && (r = e.replace(x, "$&/") + "/"), m(o, t, r, "", function(p) {
            return p;
        })) : o != null && (k(o) && (o = re(o, r + (!o.key || s && s.key === o.key ? "" : ("" + o.key).replace(x, "$&/") + "/") + e)), t.push(o)), 1;
        if (s = 0, u = u === "" ? "." : u + ":", Array.isArray(e)) for(var c = 0; c < e.length; c++){
            f = e[c];
            var i = u + E(f, c);
            s += m(f, t, r, i, o);
        }
        else if (i = te(e), typeof i == "function") for(e = i.call(e), c = 0; !(f = e.next()).done;)f = f.value, i = u + E(f, c++), s += m(f, t, r, i, o);
        else if (f === "object") throw t = "" + e, Error(_(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
        return s;
    }
    function v(e, t, r) {
        if (e == null) return e;
        var u = [], o = 0;
        return m(e, u, "", "", function(f) {
            return t.call(r, f, o++);
        }), u;
    }
    function oe(e) {
        if (e._status === -1) {
            var t = e._result;
            t = t(), e._status = 0, e._result = t, t.then(function(r) {
                e._status === 0 && (r = r.default, e._status = 1, e._result = r);
            }, function(r) {
                e._status === 0 && (e._status = 2, e._result = r);
            });
        }
        if (e._status === 1) return e._result;
        throw e._result;
    }
    var B = {
        current: null
    };
    function a() {
        var e = B.current;
        if (e === null) throw Error(_(321));
        return e;
    }
    var ue = {
        ReactCurrentDispatcher: B,
        ReactCurrentBatchConfig: {
            transition: 0
        },
        ReactCurrentOwner: $,
        IsSomeRendererActing: {
            current: !1
        },
        assign: S
    };
    n.Children = {
        map: v,
        forEach: function(e, t, r) {
            v(e, function() {
                t.apply(this, arguments);
            }, r);
        },
        count: function(e) {
            var t = 0;
            return v(e, function() {
                t++;
            }), t;
        },
        toArray: function(e) {
            return v(e, function(t) {
                return t;
            }) || [];
        },
        only: function(e) {
            if (!k(e)) throw Error(_(143));
            return e;
        }
    };
    n.Component = d;
    n.PureComponent = C;
    n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ue;
    n.cloneElement = function(e, t, r) {
        if (e == null) throw Error(_(267, e));
        var u = S({}, e.props), o = e.key, f = e.ref, s = e._owner;
        if (t != null) {
            if (t.ref !== void 0 && (f = t.ref, s = $.current), t.key !== void 0 && (o = "" + t.key), e.type && e.type.defaultProps) var c = e.type.defaultProps;
            for(i in t)U.call(t, i) && !T.hasOwnProperty(i) && (u[i] = t[i] === void 0 && c !== void 0 ? c[i] : t[i]);
        }
        var i = arguments.length - 2;
        if (i === 1) u.children = r;
        else if (1 < i) {
            c = Array(i);
            for(var p = 0; p < i; p++)c[p] = arguments[p + 2];
            u.children = c;
        }
        return {
            $$typeof: y,
            type: e.type,
            key: o,
            ref: f,
            props: u,
            _owner: s
        };
    };
    n.createContext = function(e, t) {
        return t === void 0 && (t = null), e = {
            $$typeof: A,
            _calculateChangedBits: t,
            _currentValue: e,
            _currentValue2: e,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        }, e.Provider = {
            $$typeof: w,
            _context: e
        }, e.Consumer = e;
    };
    n.createElement = V;
    n.createFactory = function(e) {
        var t = V.bind(null, e);
        return t.type = e, t;
    };
    n.createRef = function() {
        return {
            current: null
        };
    };
    n.forwardRef = function(e) {
        return {
            $$typeof: F,
            render: e
        };
    };
    n.isValidElement = k;
    n.lazy = function(e) {
        return {
            $$typeof: q,
            _payload: {
                _status: -1,
                _result: e
            },
            _init: oe
        };
    };
    n.memo = function(e, t) {
        return {
            $$typeof: L,
            type: e,
            compare: t === void 0 ? null : t
        };
    };
    n.useCallback = function(e, t) {
        return a().useCallback(e, t);
    };
    n.useContext = function(e, t) {
        return a().useContext(e, t);
    };
    n.useDebugValue = function() {};
    n.useEffect = function(e, t) {
        return a().useEffect(e, t);
    };
    n.useImperativeHandle = function(e, t, r) {
        return a().useImperativeHandle(e, t, r);
    };
    n.useLayoutEffect = function(e, t) {
        return a().useLayoutEffect(e, t);
    };
    n.useMemo = function(e, t) {
        return a().useMemo(e, t);
    };
    n.useReducer = function(e, t, r) {
        return a().useReducer(e, t, r);
    };
    n.useRef = function(e) {
        return a().useRef(e);
    };
    n.useState = function(e) {
        return a().useState(e);
    };
    n.version = "17.0.2";
});
var g5 = O7((le, H)=>{
    "use strict";
    H.exports = z6();
});
var W5 = P5(g5()), Y5 = P5(g5()), { Fragment: pe7 , StrictMode: ae5 , Profiler: ye5 , Suspense: de6 , Children: _e5 , Component: ve4 , PureComponent: me5 , __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: he4 , cloneElement: Ee3 , createContext: Se3 , createElement: Ce6 , createFactory: Re2 , createRef: $e3 , forwardRef: ke3 , isValidElement: ge5 , lazy: Oe2 , memo: Pe4 , useCallback: je3 , useContext: xe3 , useDebugValue: Ie3 , useEffect: we5 , useImperativeHandle: Ae4 , useLayoutEffect: Fe3 , useMemo: Le2 , useReducer: qe3 , useRef: De3 , useState: Me4 , version: Ne3  } = Y5, { default: ie4 , ...fe5 } = Y5, Ue2 = W5.default ?? ie4 ?? fe5;
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
var d3 = 1073741823, g6 = typeof globalThis < "u" ? globalThis : typeof document < "u" ? window : typeof __global$ < "u" ? __global$ : {};
function y2() {
    var t = "__global_unique_id__";
    return g6[t] = (g6[t] || 0) + 1;
}
function C3(t, o) {
    return t === o ? t !== 0 || 1 / t === 1 / o : t !== t && o !== o;
}
function T1(t) {
    var o = [];
    return {
        on: function(i) {
            o.push(i);
        },
        off: function(i) {
            o = o.filter(function(r) {
                return r !== i;
            });
        },
        get: function() {
            return t;
        },
        set: function(i, r) {
            t = i, o.forEach(function(l) {
                return l(t, r);
            });
        }
    };
}
function B6(t) {
    return Array.isArray(t) ? t[0] : t;
}
function I4(t, o) {
    var c, i, r = "__create-react-context-" + y2() + "__", l = function(f) {
        f2(a, f);
        function a() {
            var e;
            return e = f.apply(this, arguments) || this, e.emitter = T1(e.props.value), e;
        }
        var u = a.prototype;
        return u.getChildContext = function() {
            var n;
            return n = {}, n[r] = this.emitter, n;
        }, u.componentWillReceiveProps = function(n) {
            if (this.props.value !== n.value) {
                var s = this.props.value, v = n.value, p;
                C3(s, v) ? p = 0 : (p = typeof o == "function" ? o(s, v) : d3, p |= 0, p !== 0 && this.emitter.set(n.value, p));
            }
        }, u.render = function() {
            return this.props.children;
        }, a;
    }(ve4);
    l.childContextTypes = (c = {}, c[r] = ce2.object.isRequired, c);
    var h = function(f) {
        f2(a, f);
        function a() {
            var e;
            return e = f.apply(this, arguments) || this, e.state = {
                value: e.getValue()
            }, e.onUpdate = function(n, s) {
                var v = e.observedBits | 0;
                (v & s) !== 0 && e.setState({
                    value: e.getValue()
                });
            }, e;
        }
        var u = a.prototype;
        return u.componentWillReceiveProps = function(n) {
            var s = n.observedBits;
            this.observedBits = s ?? d3;
        }, u.componentDidMount = function() {
            this.context[r] && this.context[r].on(this.onUpdate);
            var n = this.props.observedBits;
            this.observedBits = n ?? d3;
        }, u.componentWillUnmount = function() {
            this.context[r] && this.context[r].off(this.onUpdate);
        }, u.getValue = function() {
            return this.context[r] ? this.context[r].get() : t;
        }, u.render = function() {
            return B6(this.props.children)(this.state.value);
        }, a;
    }(ve4);
    return h.contextTypes = (i = {}, i[r] = ce2.object, i), {
        Provider: l,
        Consumer: h
    };
}
var E2 = Ue2.createContext || I4, W6 = E2;
var d4 = Object.create;
var e = Object.defineProperty;
var i4 = Object.getOwnPropertyDescriptor;
var m1 = Object.getOwnPropertyNames;
var n2 = Object.getPrototypeOf, s2 = Object.prototype.hasOwnProperty;
var y3 = (r)=>e(r, "__esModule", {
        value: !0
    });
var $4 = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var A4 = (r, t, c, f)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let o of m1(t))!s2.call(r, o) && (c || o !== "default") && e(r, o, {
        get: ()=>t[o],
        enumerable: !(f = i4(t, o)) || f.enumerable
    });
    return r;
}, l1 = (r, t)=>A4(y3(e(r != null ? d4(n2(r)) : {}, "default", !t && r && r.__esModule ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var a5 = $4((O, p)=>{
    p.exports = Array.isArray || function(r) {
        return Object.prototype.toString.call(r) == "[object Array]";
    };
});
var u2 = l1(a5()), b6 = l1(a5()), { default: j4 , ...x4 } = b6, S3 = u2.default ?? j4 ?? x4;
var O8 = Object.create;
var E3 = Object.defineProperty;
var q5 = Object.getOwnPropertyDescriptor;
var H5 = Object.getOwnPropertyNames;
var K7 = Object.getPrototypeOf, W7 = Object.prototype.hasOwnProperty;
var X8 = (r)=>E3(r, "__esModule", {
        value: !0
    });
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, t)=>(typeof require != "undefined" ? require : e)[t]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var j5 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var z7 = (r, e, t, f)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let l of H5(e))!W7.call(r, l) && (t || l !== "default") && E3(r, l, {
        get: ()=>e[l],
        enumerable: !(f = q5(e, l)) || f.enumerable
    });
    return r;
}, U4 = (r, e)=>z7(X8(E3(r != null ? O8(K7(r)) : {}, "default", !e && r && r.__esModule ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var $5 = j5((ar, h)=>{
    var m = S3;
    h.exports = I;
    h.exports.parse = w;
    h.exports.compile = L;
    h.exports.tokensToFunction = A;
    h.exports.tokensToRegExp = S;
    var B = new RegExp([
        "(\\\\.)",
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
    ].join("|"), "g");
    function w(r, e) {
        for(var t = [], f = 0, l = 0, n = "", o = e && e.delimiter || "/", i; (i = B.exec(r)) != null;){
            var g = i[0], c = i[1], p = i.index;
            if (n += r.slice(l, p), l = p + g.length, c) {
                n += c[1];
                continue;
            }
            var a = r[l], u = i[2], v = i[3], d = i[4], D = i[5], x = i[6], y = i[7];
            n && (t.push(n), n = "");
            var G = u != null && a != null && a !== u, J = x === "+" || x === "*", N = x === "?" || x === "*", b = i[2] || o, C = d || D;
            t.push({
                name: v || f++,
                prefix: u || "",
                delimiter: b,
                optional: N,
                repeat: J,
                partial: G,
                asterisk: !!y,
                pattern: C ? V(C) : y ? ".*" : "[^" + s(b) + "]+?"
            });
        }
        return l < r.length && (n += r.substr(l)), n && t.push(n), t;
    }
    function L(r, e) {
        return A(w(r, e), e);
    }
    function M(r) {
        return encodeURI(r).replace(/[\/?#]/g, function(e) {
            return "%" + e.charCodeAt(0).toString(16).toUpperCase();
        });
    }
    function Q(r) {
        return encodeURI(r).replace(/[?#]/g, function(e) {
            return "%" + e.charCodeAt(0).toString(16).toUpperCase();
        });
    }
    function A(r, e) {
        for(var t = new Array(r.length), f = 0; f < r.length; f++)typeof r[f] == "object" && (t[f] = new RegExp("^(?:" + r[f].pattern + ")$", T(e)));
        return function(l, n) {
            for(var o = "", i = l || {}, g = n || {}, c = g.pretty ? M : encodeURIComponent, p = 0; p < r.length; p++){
                var a = r[p];
                if (typeof a == "string") {
                    o += a;
                    continue;
                }
                var u = i[a.name], v;
                if (u == null) if (a.optional) {
                    a.partial && (o += a.prefix);
                    continue;
                } else throw new TypeError('Expected "' + a.name + '" to be defined');
                if (m(u)) {
                    if (!a.repeat) throw new TypeError('Expected "' + a.name + '" to not repeat, but received `' + JSON.stringify(u) + "`");
                    if (u.length === 0) {
                        if (a.optional) continue;
                        throw new TypeError('Expected "' + a.name + '" to not be empty');
                    }
                    for(var d = 0; d < u.length; d++){
                        if (v = c(u[d]), !t[p].test(v)) throw new TypeError('Expected all "' + a.name + '" to match "' + a.pattern + '", but received `' + JSON.stringify(v) + "`");
                        o += (d === 0 ? a.prefix : a.delimiter) + v;
                    }
                    continue;
                }
                if (v = a.asterisk ? Q(u) : c(u), !t[p].test(v)) throw new TypeError('Expected "' + a.name + '" to match "' + a.pattern + '", but received "' + v + '"');
                o += a.prefix + v;
            }
            return o;
        };
    }
    function s(r) {
        return r.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
    }
    function V(r) {
        return r.replace(/([=!:$\/()])/g, "\\$1");
    }
    function R(r, e) {
        return r.keys = e, r;
    }
    function T(r) {
        return r && r.sensitive ? "" : "i";
    }
    function Y(r, e) {
        var t = r.source.match(/\((?!\?)/g);
        if (t) for(var f = 0; f < t.length; f++)e.push({
            name: f,
            prefix: null,
            delimiter: null,
            optional: !1,
            repeat: !1,
            partial: !1,
            asterisk: !1,
            pattern: null
        });
        return R(r, e);
    }
    function Z(r, e, t) {
        for(var f = [], l = 0; l < r.length; l++)f.push(I(r[l], e, t).source);
        var n = new RegExp("(?:" + f.join("|") + ")", T(t));
        return R(n, e);
    }
    function k(r, e, t) {
        return S(w(r, t), e, t);
    }
    function S(r, e, t) {
        m(e) || (t = e || t, e = []), t = t || {};
        for(var f = t.strict, l = t.end !== !1, n = "", o = 0; o < r.length; o++){
            var i = r[o];
            if (typeof i == "string") n += s(i);
            else {
                var g = s(i.prefix), c = "(?:" + i.pattern + ")";
                e.push(i), i.repeat && (c += "(?:" + g + c + ")*"), i.optional ? i.partial ? c = g + "(" + c + ")?" : c = "(?:" + g + "(" + c + "))?" : c = g + "(" + c + ")", n += c;
            }
        }
        var p = s(t.delimiter || "/"), a = n.slice(-p.length) === p;
        return f || (n = (a ? n.slice(0, -p.length) : n) + "(?:" + p + "(?=$))?"), l ? n += "$" : n += f && a ? "" : "(?=" + p + "|$)", R(new RegExp("^" + n, T(t)), e);
    }
    function I(r, e, t) {
        return m(e) || (t = e || t, e = []), t = t || {}, r instanceof RegExp ? Y(r, e) : m(r) ? Z(r, e, t) : k(r, e, t);
    }
});
var F3 = U4($5()), P6 = U4($5()), { parse: nr1 , compile: ir1 , tokensToFunction: fr , tokensToRegExp: lr1  } = P6, { default: rr1 , ...er1 } = P6, cr1 = F3.default ?? rr1 ?? er1;
var j6 = Object.create;
var S4 = Object.defineProperty;
var A5 = Object.getOwnPropertyDescriptor;
var h8 = Object.getOwnPropertyNames;
var L5 = Object.getPrototypeOf, R5 = Object.prototype.hasOwnProperty;
var q6 = (e)=>S4(e, "__esModule", {
        value: !0
    });
var P7 = (e, o)=>()=>(o || e((o = {
            exports: {}
        }).exports, o), o.exports);
var O9 = (e, o, _, x)=>{
    if (o && typeof o == "object" || typeof o == "function") for (let s of h8(o))!R5.call(e, s) && (_ || s !== "default") && S4(e, s, {
        get: ()=>o[s],
        enumerable: !(x = A5(o, s)) || x.enumerable
    });
    return e;
}, v6 = (e, o)=>O9(q6(S4(e != null ? j6(L5(e)) : {}, "default", !o && e && e.__esModule ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var E4 = P7((r)=>{
    "use strict";
    var t = typeof Symbol == "function" && Symbol.for, $ = t ? Symbol.for("react.element") : 60103, b = t ? Symbol.for("react.portal") : 60106, c = t ? Symbol.for("react.fragment") : 60107, f = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, u = t ? Symbol.for("react.provider") : 60109, l = t ? Symbol.for("react.context") : 60110, C = t ? Symbol.for("react.async_mode") : 60111, m = t ? Symbol.for("react.concurrent_mode") : 60111, y = t ? Symbol.for("react.forward_ref") : 60112, p = t ? Symbol.for("react.suspense") : 60113, V = t ? Symbol.for("react.suspense_list") : 60120, d = t ? Symbol.for("react.memo") : 60115, a = t ? Symbol.for("react.lazy") : 60116, k = t ? Symbol.for("react.block") : 60121, N = t ? Symbol.for("react.fundamental") : 60117, T = t ? Symbol.for("react.responder") : 60118, D = t ? Symbol.for("react.scope") : 60119;
    function n(e) {
        if (typeof e == "object" && e !== null) {
            var o = e.$$typeof;
            switch(o){
                case $:
                    switch(e = e.type, e){
                        case C:
                        case m:
                        case c:
                        case i:
                        case f:
                        case p:
                            return e;
                        default:
                            switch(e = e && e.$$typeof, e){
                                case l:
                                case y:
                                case a:
                                case d:
                                case u:
                                    return e;
                                default:
                                    return o;
                            }
                    }
                case b:
                    return o;
            }
        }
    }
    function w(e) {
        return n(e) === m;
    }
    r.AsyncMode = C;
    r.ConcurrentMode = m;
    r.ContextConsumer = l;
    r.ContextProvider = u;
    r.Element = $;
    r.ForwardRef = y;
    r.Fragment = c;
    r.Lazy = a;
    r.Memo = d;
    r.Portal = b;
    r.Profiler = i;
    r.StrictMode = f;
    r.Suspense = p;
    r.isAsyncMode = function(e) {
        return w(e) || n(e) === C;
    };
    r.isConcurrentMode = w;
    r.isContextConsumer = function(e) {
        return n(e) === l;
    };
    r.isContextProvider = function(e) {
        return n(e) === u;
    };
    r.isElement = function(e) {
        return typeof e == "object" && e !== null && e.$$typeof === $;
    };
    r.isForwardRef = function(e) {
        return n(e) === y;
    };
    r.isFragment = function(e) {
        return n(e) === c;
    };
    r.isLazy = function(e) {
        return n(e) === a;
    };
    r.isMemo = function(e) {
        return n(e) === d;
    };
    r.isPortal = function(e) {
        return n(e) === b;
    };
    r.isProfiler = function(e) {
        return n(e) === i;
    };
    r.isStrictMode = function(e) {
        return n(e) === f;
    };
    r.isSuspense = function(e) {
        return n(e) === p;
    };
    r.isValidElementType = function(e) {
        return typeof e == "string" || typeof e == "function" || e === c || e === m || e === i || e === f || e === p || e === V || typeof e == "object" && e !== null && (e.$$typeof === a || e.$$typeof === d || e.$$typeof === u || e.$$typeof === l || e.$$typeof === y || e.$$typeof === N || e.$$typeof === T || e.$$typeof === D || e.$$typeof === k);
    };
    r.typeOf = n;
});
var M5 = P7((J, F)=>{
    "use strict";
    F.exports = E4();
});
var g7 = v6(M5()), z8 = v6(M5()), { AsyncMode: K8 , ConcurrentMode: Q8 , ContextConsumer: U5 , ContextProvider: W8 , Element: X9 , ForwardRef: Y6 , Fragment: Z7 , Lazy: ee8 , Memo: re5 , Portal: te6 , Profiler: oe5 , StrictMode: ne5 , Suspense: se4 , isAsyncMode: ce4 , isConcurrentMode: fe6 , isContextConsumer: ie5 , isContextProvider: ue1 , isElement: le5 , isForwardRef: me6 , isFragment: ye6 , isLazy: pe8 , isMemo: de7 , isPortal: ae6 , isProfiler: Se4 , isStrictMode: $e4 , isSuspense: be4 , isValidElementType: Ce7 , typeOf: Me5  } = z8, { default: B7 , ...G6 } = z8, xe4 = g7.default ?? B7 ?? G6;
function f3(r, o) {
    if (r == null) return {};
    var n = {}, i = Object.keys(r), e, t;
    for(t = 0; t < i.length; t++)e = i[t], !(o.indexOf(e) >= 0) && (n[e] = r[e]);
    return n;
}
var N2 = Object.create;
var f4 = Object.defineProperty;
var b7 = Object.getOwnPropertyDescriptor;
var j7 = Object.getOwnPropertyNames;
var w3 = Object.getPrototypeOf, A6 = Object.prototype.hasOwnProperty;
var x5 = (r)=>f4(r, "__esModule", {
        value: !0
    });
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, a)=>(typeof require != "undefined" ? require : e)[a]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var I5 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var R6 = (r, e, a, u)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of j7(e))!A6.call(r, t) && (a || t !== "default") && f4(r, t, {
        get: ()=>e[t],
        enumerable: !(u = b7(e, t)) || u.enumerable
    });
    return r;
}, O10 = (r, e)=>R6(x5(f4(r != null ? N2(w3(r)) : {}, "default", !e && r && r.__esModule ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var i5 = I5((G, g)=>{
    "use strict";
    var y = xe4, _ = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    }, E = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    }, F = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    }, l = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    }, v = {};
    v[y.ForwardRef] = F;
    v[y.Memo] = l;
    function P(r) {
        return y.isMemo(r) ? l : v[r.$$typeof] || _;
    }
    var n = Object.defineProperty, M = Object.getOwnPropertyNames, c = Object.getOwnPropertySymbols, h = Object.getOwnPropertyDescriptor, W = Object.getPrototypeOf, d = Object.prototype;
    function S(r, e, a) {
        if (typeof e != "string") {
            if (d) {
                var u = W(e);
                u && u !== d && S(r, u, a);
            }
            var t = M(e);
            c && (t = t.concat(c(e)));
            for(var s = P(r), T = P(e), o = 0; o < t.length; ++o){
                var p = t[o];
                if (!E[p] && !(a && a[p]) && !(T && T[p]) && !(s && s[p])) {
                    var m = h(e, p);
                    try {
                        n(r, p, m);
                    } catch  {}
                }
            }
        }
        return r;
    }
    g.exports = S;
});
var $6 = O10(i5()), q7 = O10(i5()), { default: K9 , ...Y7 } = q7, H6 = $6.default ?? K9 ?? Y7;
var $7 = function(o) {
    var n = W6();
    return n.displayName = o, n;
}, j8 = $7("Router-History"), h9 = $7("Router"), B8 = function(e) {
    f2(o, e), o.computeRootMatch = function(t) {
        return {
            path: "/",
            url: "/",
            params: {},
            isExact: t === "/"
        };
    };
    function o(r) {
        var t;
        return t = e.call(this, r) || this, t.state = {
            location: r.history.location
        }, t._isMounted = !1, t._pendingLocation = null, r.staticContext || (t.unlisten = r.history.listen(function(i) {
            t._isMounted ? t.setState({
                location: i
            }) : t._pendingLocation = i;
        })), t;
    }
    var n = o.prototype;
    return n.componentDidMount = function() {
        this._isMounted = !0, this._pendingLocation && this.setState({
            location: this._pendingLocation
        });
    }, n.componentWillUnmount = function() {
        this.unlisten && (this.unlisten(), this._isMounted = !1, this._pendingLocation = null);
    }, n.render = function() {
        return Ge.createElement(h9.Provider, {
            value: {
                history: this.props.history,
                location: this.state.location,
                match: o.computeRootMatch(this.state.location.pathname),
                staticContext: this.props.staticContext
            }
        }, Ge.createElement(j8.Provider, {
            children: this.props.children || null,
            value: this.props.history
        }));
    }, o;
}(Ge.Component), ge6 = function(e) {
    f2(o, e);
    function o() {
        for(var r, t = arguments.length, i = new Array(t), s = 0; s < t; s++)i[s] = arguments[s];
        return r = e.call.apply(e, [
            this
        ].concat(i)) || this, r.history = Ae3(r.props), r;
    }
    var n = o.prototype;
    return n.render = function() {
        return Ge.createElement(B8, {
            history: this.history,
            children: this.props.children
        });
    }, o;
}(Ge.Component), A7 = function(e) {
    f2(o, e);
    function o() {
        return e.apply(this, arguments) || this;
    }
    var n = o.prototype;
    return n.componentDidMount = function() {
        this.props.onMount && this.props.onMount.call(this, this);
    }, n.componentDidUpdate = function(t) {
        this.props.onUpdate && this.props.onUpdate.call(this, this, t);
    }, n.componentWillUnmount = function() {
        this.props.onUnmount && this.props.onUnmount.call(this, this);
    }, n.render = function() {
        return null;
    }, o;
}(Ge.Component);
var T2 = {}, Q9 = 1e4, V4 = 0;
function X10(e) {
    if (T2[e]) return T2[e];
    var o = cr1.compile(e);
    return V4 < Q9 && (T2[e] = o, V4++), o;
}
function x6(e, o) {
    return e === void 0 && (e = "/"), o === void 0 && (o = {}), e === "/" ? e : X10(e)(o, {
        pretty: !0
    });
}
function Pe5(e) {
    var o = e.computedMatch, n = e.to, r = e.push, t = r === void 0 ? !1 : r;
    return Ge.createElement(h9.Consumer, null, function(i) {
        i || v5(!1);
        var s = i.history, a = i.staticContext, u = t ? s.push : s.replace, l = I3(o ? typeof n == "string" ? x6(n, o.params) : a3({}, n, {
            pathname: x6(n.pathname, o.params)
        }) : n);
        return a ? (u(l), null) : Ge.createElement(A7, {
            onMount: function() {
                u(l);
            },
            onUpdate: function(m, d) {
                var v = I3(d.to);
                Ne2(v, a3({}, l, {
                    key: v.key
                })) || u(l);
            },
            to: n
        });
    });
}
var M6 = {}, Z8 = 1e4, U6 = 0;
function ee9(e, o) {
    var n = "" + o.end + o.strict + o.sensitive, r = M6[n] || (M6[n] = {});
    if (r[e]) return r[e];
    var t = [], i = cr1(e, t, o), s = {
        regexp: i,
        keys: t
    };
    return U6 < Z8 && (r[e] = s, U6++), s;
}
function b8(e, o) {
    o === void 0 && (o = {}), (typeof o == "string" || Array.isArray(o)) && (o = {
        path: o
    });
    var n = o, r = n.path, t = n.exact, i = t === void 0 ? !1 : t, s = n.strict, a = s === void 0 ? !1 : s, u = n.sensitive, l = u === void 0 ? !1 : u, c = [].concat(r);
    return c.reduce(function(m, d) {
        if (!d && d !== "") return null;
        if (m) return m;
        var v = ee9(d, {
            end: i,
            strict: a,
            sensitive: l
        }), R = v.regexp, H = v.keys, P = R.exec(e);
        if (!P) return null;
        var _ = P[0], q = P.slice(1), O = e === _;
        return i && !O ? null : {
            path: d,
            url: d === "/" && _ === "" ? "/" : _,
            isExact: O,
            params: H.reduce(function(C, W, F) {
                return C[W.name] = q[F], C;
            }, {})
        };
    }, null);
}
function oe6(e) {
    return Ge.Children.count(e) === 0;
}
var _e6 = function(e) {
    f2(o, e);
    function o() {
        return e.apply(this, arguments) || this;
    }
    var n = o.prototype;
    return n.render = function() {
        var t = this;
        return Ge.createElement(h9.Consumer, null, function(i) {
            i || v5(!1);
            var s = t.props.location || i.location, a = t.props.computedMatch ? t.props.computedMatch : t.props.path ? b8(s.pathname, t.props) : i.match, u = a3({}, i, {
                location: s,
                match: a
            }), l = t.props, c = l.children, m = l.component, d = l.render;
            return Array.isArray(c) && oe6(c) && (c = null), Ge.createElement(h9.Provider, {
                value: u
            }, u.match ? c ? typeof c == "function" ? c(u) : c : m ? Ge.createElement(m, u) : d ? d(u) : null : typeof c == "function" ? c(u) : null);
        });
    }, o;
}(Ge.Component);
function w4(e) {
    return e.charAt(0) === "/" ? e : "/" + e;
}
function te7(e, o) {
    return e ? a3({}, o, {
        pathname: w4(e) + o.pathname
    }) : o;
}
function ne6(e, o) {
    if (!e) return o;
    var n = w4(e);
    return o.pathname.indexOf(n) !== 0 ? o : a3({}, o, {
        pathname: o.pathname.substr(n.length)
    });
}
function L6(e) {
    return typeof e == "string" ? e : D2(e);
}
function D3(e) {
    return function() {
        v5(!1);
    };
}
function S5() {}
var Te4 = function(e) {
    f2(o, e);
    function o() {
        for(var r, t = arguments.length, i = new Array(t), s = 0; s < t; s++)i[s] = arguments[s];
        return r = e.call.apply(e, [
            this
        ].concat(i)) || this, r.handlePush = function(a) {
            return r.navigateTo(a, "PUSH");
        }, r.handleReplace = function(a) {
            return r.navigateTo(a, "REPLACE");
        }, r.handleListen = function() {
            return S5;
        }, r.handleBlock = function() {
            return S5;
        }, r;
    }
    var n = o.prototype;
    return n.navigateTo = function(t, i) {
        var s = this.props, a = s.basename, u = a === void 0 ? "" : a, l = s.context, c = l === void 0 ? {} : l;
        c.action = i, c.location = te7(u, I3(t)), c.url = L6(c.location);
    }, n.render = function() {
        var t = this.props, i = t.basename, s = i === void 0 ? "" : i, a = t.context, u = a === void 0 ? {} : a, l = t.location, c = l === void 0 ? "/" : l, m = f3(t, [
            "basename",
            "context",
            "location"
        ]), d = {
            createHref: function(R) {
                return w4(s + L6(R));
            },
            action: "POP",
            location: ne6(s, I3(c)),
            push: this.handlePush,
            replace: this.handleReplace,
            go: D3("go"),
            goBack: D3("goBack"),
            goForward: D3("goForward"),
            listen: this.handleListen,
            block: this.handleBlock
        };
        return Ge.createElement(B8, a3({}, m, {
            history: d,
            staticContext: u
        }));
    }, o;
}(Ge.Component), De4 = function(e) {
    f2(o, e);
    function o() {
        return e.apply(this, arguments) || this;
    }
    var n = o.prototype;
    return n.render = function() {
        var t = this;
        return Ge.createElement(h9.Consumer, null, function(i) {
            i || v5(!1);
            var s = t.props.location || i.location, a, u;
            return Ge.Children.forEach(t.props.children, function(l) {
                if (u == null && Ge.isValidElement(l)) {
                    a = l;
                    var c = l.props.path || l.props.from;
                    u = c ? b8(s.pathname, a3({}, l.props, {
                        path: c
                    })) : i.match;
                }
            }), u ? Ge.cloneElement(a, {
                location: s,
                computedMatch: u
            }) : null;
        });
    }, o;
}(Ge.Component);
var g8 = Ge.useContext;
function we6() {
    return g8(j8);
}
function Oe3() {
    var e = g8(h9).match;
    return e ? e.params : {};
}
var ae7 = function(e) {
    f2(r, e);
    function r() {
        for(var t, i = arguments.length, a = new Array(i), n = 0; n < i; n++)a[n] = arguments[n];
        return t = e.call.apply(e, [
            this
        ].concat(a)) || this, t.history = Te3(t.props), t;
    }
    var o = r.prototype;
    return o.render = function() {
        return Ge.createElement(B8, {
            history: this.history,
            children: this.props.children
        });
    }, r;
}(Ge.Component), se5 = function(e) {
    f2(r, e);
    function r() {
        for(var t, i = arguments.length, a = new Array(i), n = 0; n < i; n++)a[n] = arguments[n];
        return t = e.call.apply(e, [
            this
        ].concat(a)) || this, t.history = Ce5(t.props), t;
    }
    var o = r.prototype;
    return o.render = function() {
        return Ge.createElement(B8, {
            history: this.history,
            children: this.props.children
        });
    }, r;
}(Ge.Component), C4 = function(r, o) {
    return typeof r == "function" ? r(o) : r;
}, b9 = function(r, o) {
    return typeof r == "string" ? I3(r, null, null, o) : r;
}, D4 = function(r) {
    return r;
}, l2 = Ge.forwardRef;
typeof l2 > "u" && (l2 = D4);
function W9(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
var F4 = l2(function(e, r) {
    var o = e.innerRef, t = e.navigate, i = e.onClick, a = f3(e, [
        "innerRef",
        "navigate",
        "onClick"
    ]), n = a.target, c = a3({}, a, {
        onClick: function(s) {
            try {
                i && i(s);
            } catch (f) {
                throw s.preventDefault(), f;
            }
            !s.defaultPrevented && s.button === 0 && (!n || n === "_self") && !W9(s) && (s.preventDefault(), t());
        }
    });
    return D4 !== l2 ? c.ref = r || o : c.ref = o, Ge.createElement("a", c);
}), G7 = l2(function(e, r) {
    var o = e.component, t = o === void 0 ? F4 : o, i = e.replace, a = e.to, n = e.innerRef, c = f3(e, [
        "component",
        "replace",
        "to",
        "innerRef"
    ]);
    return Ge.createElement(h9.Consumer, null, function(u) {
        u || v5(!1);
        var s = u.history, f = b9(C4(a, u.location), u.location), N = f ? s.createHref(f) : "", y = a3({}, c, {
            href: N,
            navigate: function() {
                var h = C4(a, u.location), m = D2(u.location) === D2(b9(h)), g = i || m ? s.replace : s.push;
                g(h);
            }
        });
        return D4 !== l2 ? y.ref = r || n : y.innerRef = n, Ge.createElement(t, y);
    });
});
var $8 = function(r) {
    return r;
}, R7 = Ge.forwardRef;
typeof R7 > "u" && (R7 = $8);
function I6() {
    for(var e = arguments.length, r = new Array(e), o = 0; o < e; o++)r[o] = arguments[o];
    return r.filter(function(t) {
        return t;
    }).join(" ");
}
R7(function(e, r) {
    var o = e["aria-current"], t = o === void 0 ? "page" : o, i = e.activeClassName, a = i === void 0 ? "active" : i, n = e.activeStyle, c = e.className, u = e.exact, s = e.isActive, f = e.location, N = e.sensitive, y = e.strict, v = e.style, h = e.to, m = e.innerRef, g = f3(e, [
        "aria-current",
        "activeClassName",
        "activeStyle",
        "className",
        "exact",
        "isActive",
        "location",
        "sensitive",
        "strict",
        "style",
        "to",
        "innerRef"
    ]);
    return Ge.createElement(h9.Consumer, null, function(k) {
        k || v5(!1);
        var d = f || k.location, A = b9(C4(h, d), d), H = A.pathname, S = H && H.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1"), V = S ? b8(d.pathname, {
            path: S,
            exact: u,
            sensitive: N,
            strict: y
        }) : null, T = !!(s ? s(V, d) : V), E = typeof c == "function" ? c(T) : c, L = typeof v == "function" ? v(T) : v;
        T && (E = I6(E, a), L = a3({}, L, n));
        var w = a3({
            "aria-current": T && t || null,
            className: E,
            style: L,
            to: A
        }, g);
        return $8 !== R7 ? w.ref = r || m : w.innerRef = m, Ge.createElement(G7, w);
    });
});
const codes = {};
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
const _isFunctionLike = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
Symbol("kHandle");
Symbol("kKeyObject");
Symbol("kKeyType");
const _getTypedArrayToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isUint8Array(value) {
    return _getTypedArrayToStringTag.call(value) === "Uint8Array";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1  } = mod;
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i6 = 0; i6 < encodings.length; ++i6){
    encodingsMap[encodings[i6]] = i6;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer1.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer1.prototype;
};
Buffer1.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer1.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer1.from(b, b.offset, b.byteLength);
    }
    if (!Buffer1.isBuffer(a) || !Buffer1.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer1.byteLength = byteLength;
Buffer1.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer1.compare(this, b) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
    Buffer1.prototype[customInspectSymbol] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer1.from(target, target.offset, target.byteLength);
    }
    if (!Buffer1.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer1.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer1.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var __global$1 = globalThis || (typeof window !== "undefined" ? window : self);
var __setImmediate$ = (cb, ...args)=>setTimeout(cb, 0, ...args);
var Be1 = Object.create;
var xe5 = Object.defineProperty;
var Re3 = Object.getOwnPropertyDescriptor;
var Te5 = Object.getOwnPropertyNames;
var De5 = Object.getPrototypeOf, Fe4 = Object.prototype.hasOwnProperty;
var _e7 = ((c)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(c, {
        get: (R, y)=>(typeof require < "u" ? require : R)[y]
    }) : c)(function(c) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + c + '" is not supported');
});
var Ne4 = (c, R)=>()=>(R || c((R = {
            exports: {}
        }).exports, R), R.exports);
var Ue3 = (c, R, y, o)=>{
    if (R && typeof R == "object" || typeof R == "function") for (let f of Te5(R))!Fe4.call(c, f) && f !== y && xe5(c, f, {
        get: ()=>R[f],
        enumerable: !(o = Re3(R, f)) || o.enumerable
    });
    return c;
};
var Pe6 = (c, R, y)=>(y = c != null ? Be1(De5(c)) : {}, Ue3(R || !c || !c.__esModule ? xe5(y, "default", {
        value: c,
        enumerable: !0
    }) : y, c));
var ze2 = Ne4((Se, ye)=>{
    (function(c) {
        typeof Se == "object" && typeof ye < "u" ? ye.exports = c() : typeof define == "function" && define.amd ? define([], c) : (typeof document < "u" ? window : typeof __global$1 < "u" ? __global$1 : typeof self < "u" ? self : this).JSZip = c();
    })(function() {
        return (function c(R, y, o) {
            function f(b, v) {
                if (!y[b]) {
                    if (!R[b]) {
                        var _ = typeof _e7 == "function" && _e7;
                        if (!v && _) return _(b, !0);
                        if (t) return t(b, !0);
                        var g = new Error("Cannot find module '" + b + "'");
                        throw g.code = "MODULE_NOT_FOUND", g;
                    }
                    var i = y[b] = {
                        exports: {}
                    };
                    R[b][0].call(i.exports, function(d) {
                        var p = R[b][1][d];
                        return f(p || d);
                    }, i, i.exports, c, R, y, o);
                }
                return y[b].exports;
            }
            for(var t = typeof _e7 == "function" && _e7, u = 0; u < o.length; u++)f(o[u]);
            return f;
        })({
            1: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./utils"), f = c("./support"), t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    y.encode = function(u) {
                        for(var b, v, _, g, i, d, p, n = [], a = 0, l = u.length, w = l, O = o.getTypeOf(u) !== "string"; a < u.length;)w = l - a, _ = O ? (b = u[a++], v = a < l ? u[a++] : 0, a < l ? u[a++] : 0) : (b = u.charCodeAt(a++), v = a < l ? u.charCodeAt(a++) : 0, a < l ? u.charCodeAt(a++) : 0), g = b >> 2, i = (3 & b) << 4 | v >> 4, d = 1 < w ? (15 & v) << 2 | _ >> 6 : 64, p = 2 < w ? 63 & _ : 64, n.push(t.charAt(g) + t.charAt(i) + t.charAt(d) + t.charAt(p));
                        return n.join("");
                    }, y.decode = function(u) {
                        var b, v, _, g, i, d, p = 0, n = 0, a = "data:";
                        if (u.substr(0, a.length) === a) throw new Error("Invalid base64 input, it looks like a data url.");
                        var l, w = 3 * (u = u.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
                        if (u.charAt(u.length - 1) === t.charAt(64) && w--, u.charAt(u.length - 2) === t.charAt(64) && w--, w % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
                        for(l = f.uint8array ? new Uint8Array(0 | w) : new Array(0 | w); p < u.length;)b = t.indexOf(u.charAt(p++)) << 2 | (g = t.indexOf(u.charAt(p++))) >> 4, v = (15 & g) << 4 | (i = t.indexOf(u.charAt(p++))) >> 2, _ = (3 & i) << 6 | (d = t.indexOf(u.charAt(p++))), l[n++] = b, i !== 64 && (l[n++] = v), d !== 64 && (l[n++] = _);
                        return l;
                    };
                },
                {
                    "./support": 30,
                    "./utils": 32
                }
            ],
            2: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./external"), f = c("./stream/DataWorker"), t = c("./stream/Crc32Probe"), u = c("./stream/DataLengthProbe");
                    function b(v, _, g, i, d) {
                        this.compressedSize = v, this.uncompressedSize = _, this.crc32 = g, this.compression = i, this.compressedContent = d;
                    }
                    b.prototype = {
                        getContentWorker: function() {
                            var v = new f(o.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), _ = this;
                            return v.on("end", function() {
                                if (this.streamInfo.data_length !== _.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
                            }), v;
                        },
                        getCompressedWorker: function() {
                            return new f(o.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                        }
                    }, b.createWorkerFrom = function(v, _, g) {
                        return v.pipe(new t).pipe(new u("uncompressedSize")).pipe(_.compressWorker(g)).pipe(new u("compressedSize")).withStreamInfo("compression", _);
                    }, R.exports = b;
                },
                {
                    "./external": 6,
                    "./stream/Crc32Probe": 25,
                    "./stream/DataLengthProbe": 26,
                    "./stream/DataWorker": 27
                }
            ],
            3: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./stream/GenericWorker");
                    y.STORE = {
                        magic: "\0\0",
                        compressWorker: function(f) {
                            return new o("STORE compression");
                        },
                        uncompressWorker: function() {
                            return new o("STORE decompression");
                        }
                    }, y.DEFLATE = c("./flate");
                },
                {
                    "./flate": 7,
                    "./stream/GenericWorker": 28
                }
            ],
            4: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./utils"), f = function() {
                        for(var t, u = [], b = 0; b < 256; b++){
                            t = b;
                            for(var v = 0; v < 8; v++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
                            u[b] = t;
                        }
                        return u;
                    }();
                    R.exports = function(t, u) {
                        return t !== void 0 && t.length ? o.getTypeOf(t) !== "string" ? function(b, v, _, g) {
                            var i = f, d = g + _;
                            b ^= -1;
                            for(var p = g; p < d; p++)b = b >>> 8 ^ i[255 & (b ^ v[p])];
                            return -1 ^ b;
                        }(0 | u, t, t.length, 0) : function(b, v, _, g) {
                            var i = f, d = g + _;
                            b ^= -1;
                            for(var p = g; p < d; p++)b = b >>> 8 ^ i[255 & (b ^ v.charCodeAt(p))];
                            return -1 ^ b;
                        }(0 | u, t, t.length, 0) : 0;
                    };
                },
                {
                    "./utils": 32
                }
            ],
            5: [
                function(c, R, y) {
                    "use strict";
                    y.base64 = !1, y.binary = !1, y.dir = !1, y.createFolders = !0, y.date = null, y.compression = null, y.compressionOptions = null, y.comment = null, y.unixPermissions = null, y.dosPermissions = null;
                },
                {}
            ],
            6: [
                function(c, R, y) {
                    "use strict";
                    var o = null;
                    o = typeof Promise < "u" ? Promise : c("lie"), R.exports = {
                        Promise: o
                    };
                },
                {
                    lie: 37
                }
            ],
            7: [
                function(c, R, y) {
                    "use strict";
                    var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", f = c("pako"), t = c("./utils"), u = c("./stream/GenericWorker"), b = o ? "uint8array" : "array";
                    function v(_, g) {
                        u.call(this, "FlateWorker/" + _), this._pako = null, this._pakoAction = _, this._pakoOptions = g, this.meta = {};
                    }
                    y.magic = "\b\0", t.inherits(v, u), v.prototype.processChunk = function(_) {
                        this.meta = _.meta, this._pako === null && this._createPako(), this._pako.push(t.transformTo(b, _.data), !1);
                    }, v.prototype.flush = function() {
                        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
                    }, v.prototype.cleanUp = function() {
                        u.prototype.cleanUp.call(this), this._pako = null;
                    }, v.prototype._createPako = function() {
                        this._pako = new f[this._pakoAction]({
                            raw: !0,
                            level: this._pakoOptions.level || -1
                        });
                        var _ = this;
                        this._pako.onData = function(g) {
                            _.push({
                                data: g,
                                meta: _.meta
                            });
                        };
                    }, y.compressWorker = function(_) {
                        return new v("Deflate", _);
                    }, y.uncompressWorker = function() {
                        return new v("Inflate", {});
                    };
                },
                {
                    "./stream/GenericWorker": 28,
                    "./utils": 32,
                    pako: 38
                }
            ],
            8: [
                function(c, R, y) {
                    "use strict";
                    function o(i, d) {
                        var p, n = "";
                        for(p = 0; p < d; p++)n += String.fromCharCode(255 & i), i >>>= 8;
                        return n;
                    }
                    function f(i, d, p, n, a, l) {
                        var w, O, x = i.file, U = i.compression, T = l !== b.utf8encode, M = t.transformTo("string", l(x.name)), A = t.transformTo("string", b.utf8encode(x.name)), W = x.comment, V = t.transformTo("string", l(W)), m = t.transformTo("string", b.utf8encode(W)), I = A.length !== x.name.length, r = m.length !== W.length, D = "", J = "", P = "", Q = x.dir, L = x.date, q = {
                            crc32: 0,
                            compressedSize: 0,
                            uncompressedSize: 0
                        };
                        d && !p || (q.crc32 = i.crc32, q.compressedSize = i.compressedSize, q.uncompressedSize = i.uncompressedSize);
                        var C = 0;
                        d && (C |= 8), T || !I && !r || (C |= 2048);
                        var z = 0, X = 0;
                        Q && (z |= 16), a === "UNIX" ? (X = 798, z |= function(H, ne) {
                            var oe = H;
                            return H || (oe = ne ? 16893 : 33204), (65535 & oe) << 16;
                        }(x.unixPermissions, Q)) : (X = 20, z |= function(H) {
                            return 63 & (H || 0);
                        }(x.dosPermissions)), w = L.getUTCHours(), w <<= 6, w |= L.getUTCMinutes(), w <<= 5, w |= L.getUTCSeconds() / 2, O = L.getUTCFullYear() - 1980, O <<= 4, O |= L.getUTCMonth() + 1, O <<= 5, O |= L.getUTCDate(), I && (J = o(1, 1) + o(v(M), 4) + A, D += "up" + o(J.length, 2) + J), r && (P = o(1, 1) + o(v(V), 4) + m, D += "uc" + o(P.length, 2) + P);
                        var G = "";
                        return G += `
\0`, G += o(C, 2), G += U.magic, G += o(w, 2), G += o(O, 2), G += o(q.crc32, 4), G += o(q.compressedSize, 4), G += o(q.uncompressedSize, 4), G += o(M.length, 2), G += o(D.length, 2), {
                            fileRecord: _.LOCAL_FILE_HEADER + G + M + D,
                            dirRecord: _.CENTRAL_FILE_HEADER + o(X, 2) + G + o(V.length, 2) + "\0\0\0\0" + o(z, 4) + o(n, 4) + M + D + V
                        };
                    }
                    var t = c("../utils"), u = c("../stream/GenericWorker"), b = c("../utf8"), v = c("../crc32"), _ = c("../signature");
                    function g(i, d, p, n) {
                        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = d, this.zipPlatform = p, this.encodeFileName = n, this.streamFiles = i, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                    }
                    t.inherits(g, u), g.prototype.push = function(i) {
                        var d = i.meta.percent || 0, p = this.entriesCount, n = this._sources.length;
                        this.accumulate ? this.contentBuffer.push(i) : (this.bytesWritten += i.data.length, u.prototype.push.call(this, {
                            data: i.data,
                            meta: {
                                currentFile: this.currentFile,
                                percent: p ? (d + 100 * (p - n - 1)) / p : 100
                            }
                        }));
                    }, g.prototype.openedSource = function(i) {
                        this.currentSourceOffset = this.bytesWritten, this.currentFile = i.file.name;
                        var d = this.streamFiles && !i.file.dir;
                        if (d) {
                            var p = f(i, d, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                            this.push({
                                data: p.fileRecord,
                                meta: {
                                    percent: 0
                                }
                            });
                        } else this.accumulate = !0;
                    }, g.prototype.closedSource = function(i) {
                        this.accumulate = !1;
                        var d = this.streamFiles && !i.file.dir, p = f(i, d, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                        if (this.dirRecords.push(p.dirRecord), d) this.push({
                            data: function(n) {
                                return _.DATA_DESCRIPTOR + o(n.crc32, 4) + o(n.compressedSize, 4) + o(n.uncompressedSize, 4);
                            }(i),
                            meta: {
                                percent: 100
                            }
                        });
                        else for(this.push({
                            data: p.fileRecord,
                            meta: {
                                percent: 0
                            }
                        }); this.contentBuffer.length;)this.push(this.contentBuffer.shift());
                        this.currentFile = null;
                    }, g.prototype.flush = function() {
                        for(var i = this.bytesWritten, d = 0; d < this.dirRecords.length; d++)this.push({
                            data: this.dirRecords[d],
                            meta: {
                                percent: 100
                            }
                        });
                        var p = this.bytesWritten - i, n = function(a, l, w, O, x) {
                            var U = t.transformTo("string", x(O));
                            return _.CENTRAL_DIRECTORY_END + "\0\0\0\0" + o(a, 2) + o(a, 2) + o(l, 4) + o(w, 4) + o(U.length, 2) + U;
                        }(this.dirRecords.length, p, i, this.zipComment, this.encodeFileName);
                        this.push({
                            data: n,
                            meta: {
                                percent: 100
                            }
                        });
                    }, g.prototype.prepareNextSource = function() {
                        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                    }, g.prototype.registerPrevious = function(i) {
                        this._sources.push(i);
                        var d = this;
                        return i.on("data", function(p) {
                            d.processChunk(p);
                        }), i.on("end", function() {
                            d.closedSource(d.previous.streamInfo), d._sources.length ? d.prepareNextSource() : d.end();
                        }), i.on("error", function(p) {
                            d.error(p);
                        }), this;
                    }, g.prototype.resume = function() {
                        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
                    }, g.prototype.error = function(i) {
                        var d = this._sources;
                        if (!u.prototype.error.call(this, i)) return !1;
                        for(var p = 0; p < d.length; p++)try {
                            d[p].error(i);
                        } catch  {}
                        return !0;
                    }, g.prototype.lock = function() {
                        u.prototype.lock.call(this);
                        for(var i = this._sources, d = 0; d < i.length; d++)i[d].lock();
                    }, R.exports = g;
                },
                {
                    "../crc32": 4,
                    "../signature": 23,
                    "../stream/GenericWorker": 28,
                    "../utf8": 31,
                    "../utils": 32
                }
            ],
            9: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../compressions"), f = c("./ZipFileWorker");
                    y.generateWorker = function(t, u, b) {
                        var v = new f(u.streamFiles, b, u.platform, u.encodeFileName), _ = 0;
                        try {
                            t.forEach(function(g, i) {
                                _++;
                                var d = function(l, w) {
                                    var O = l || w, x = o[O];
                                    if (!x) throw new Error(O + " is not a valid compression method !");
                                    return x;
                                }(i.options.compression, u.compression), p = i.options.compressionOptions || u.compressionOptions || {}, n = i.dir, a = i.date;
                                i._compressWorker(d, p).withStreamInfo("file", {
                                    name: g,
                                    dir: n,
                                    date: a,
                                    comment: i.comment || "",
                                    unixPermissions: i.unixPermissions,
                                    dosPermissions: i.dosPermissions
                                }).pipe(v);
                            }), v.entriesCount = _;
                        } catch (g) {
                            v.error(g);
                        }
                        return v;
                    };
                },
                {
                    "../compressions": 3,
                    "./ZipFileWorker": 8
                }
            ],
            10: [
                function(c, R, y) {
                    "use strict";
                    function o() {
                        if (!(this instanceof o)) return new o;
                        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                        this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                            var f = new o;
                            for(var t in this)typeof this[t] != "function" && (f[t] = this[t]);
                            return f;
                        };
                    }
                    (o.prototype = c("./object")).loadAsync = c("./load"), o.support = c("./support"), o.defaults = c("./defaults"), o.version = "3.7.1", o.loadAsync = function(f, t) {
                        return new o().loadAsync(f, t);
                    }, o.external = c("./external"), R.exports = o;
                },
                {
                    "./defaults": 5,
                    "./external": 6,
                    "./load": 11,
                    "./object": 15,
                    "./support": 30
                }
            ],
            11: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./utils"), f = c("./external"), t = c("./utf8"), u = c("./zipEntries"), b = c("./stream/Crc32Probe"), v = c("./nodejsUtils");
                    function _(g) {
                        return new f.Promise(function(i, d) {
                            var p = g.decompressed.getContentWorker().pipe(new b);
                            p.on("error", function(n) {
                                d(n);
                            }).on("end", function() {
                                p.streamInfo.crc32 !== g.decompressed.crc32 ? d(new Error("Corrupted zip : CRC32 mismatch")) : i();
                            }).resume();
                        });
                    }
                    R.exports = function(g, i) {
                        var d = this;
                        return i = o.extend(i || {}, {
                            base64: !1,
                            checkCRC32: !1,
                            optimizedBinaryString: !1,
                            createFolders: !1,
                            decodeFileName: t.utf8decode
                        }), v.isNode && v.isStream(g) ? f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : o.prepareContent("the loaded zip file", g, !0, i.optimizedBinaryString, i.base64).then(function(p) {
                            var n = new u(i);
                            return n.load(p), n;
                        }).then(function(p) {
                            var n = [
                                f.Promise.resolve(p)
                            ], a = p.files;
                            if (i.checkCRC32) for(var l = 0; l < a.length; l++)n.push(_(a[l]));
                            return f.Promise.all(n);
                        }).then(function(p) {
                            for(var n = p.shift(), a = n.files, l = 0; l < a.length; l++){
                                var w = a[l];
                                d.file(w.fileNameStr, w.decompressed, {
                                    binary: !0,
                                    optimizedBinaryString: !0,
                                    date: w.date,
                                    dir: w.dir,
                                    comment: w.fileCommentStr.length ? w.fileCommentStr : null,
                                    unixPermissions: w.unixPermissions,
                                    dosPermissions: w.dosPermissions,
                                    createFolders: i.createFolders
                                });
                            }
                            return n.zipComment.length && (d.comment = n.zipComment), d;
                        });
                    };
                },
                {
                    "./external": 6,
                    "./nodejsUtils": 14,
                    "./stream/Crc32Probe": 25,
                    "./utf8": 31,
                    "./utils": 32,
                    "./zipEntries": 33
                }
            ],
            12: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils"), f = c("../stream/GenericWorker");
                    function t(u, b) {
                        f.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(b);
                    }
                    o.inherits(t, f), t.prototype._bindStream = function(u) {
                        var b = this;
                        (this._stream = u).pause(), u.on("data", function(v) {
                            b.push({
                                data: v,
                                meta: {
                                    percent: 0
                                }
                            });
                        }).on("error", function(v) {
                            b.isPaused ? this.generatedError = v : b.error(v);
                        }).on("end", function() {
                            b.isPaused ? b._upstreamEnded = !0 : b.end();
                        });
                    }, t.prototype.pause = function() {
                        return !!f.prototype.pause.call(this) && (this._stream.pause(), !0);
                    }, t.prototype.resume = function() {
                        return !!f.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
                    }, R.exports = t;
                },
                {
                    "../stream/GenericWorker": 28,
                    "../utils": 32
                }
            ],
            13: [
                function(c, R, y) {
                    "use strict";
                    var o = c("readable-stream").Readable;
                    function f(t, u, b) {
                        o.call(this, u), this._helper = t;
                        var v = this;
                        t.on("data", function(_, g) {
                            v.push(_) || v._helper.pause(), b && b(g);
                        }).on("error", function(_) {
                            v.emit("error", _);
                        }).on("end", function() {
                            v.push(null);
                        });
                    }
                    c("../utils").inherits(f, o), f.prototype._read = function() {
                        this._helper.resume();
                    }, R.exports = f;
                },
                {
                    "../utils": 32,
                    "readable-stream": 16
                }
            ],
            14: [
                function(c, R, y) {
                    "use strict";
                    R.exports = {
                        isNode: typeof Buffer1 < "u",
                        newBufferFrom: function(o, f) {
                            if (Buffer1.from && Buffer1.from !== Uint8Array.from) return Buffer1.from(o, f);
                            if (typeof o == "number") throw new Error('The "data" argument must not be a number');
                            return new Buffer1(o, f);
                        },
                        allocBuffer: function(o) {
                            if (Buffer1.alloc) return Buffer1.alloc(o);
                            var f = new Buffer1(o);
                            return f.fill(0), f;
                        },
                        isBuffer: function(o) {
                            return Buffer1.isBuffer(o);
                        },
                        isStream: function(o) {
                            return o && typeof o.on == "function" && typeof o.pause == "function" && typeof o.resume == "function";
                        }
                    };
                },
                {}
            ],
            15: [
                function(c, R, y) {
                    "use strict";
                    function o(x, U, T) {
                        var M, A = t.getTypeOf(U), W = t.extend(T || {}, v);
                        W.date = W.date || new Date, W.compression !== null && (W.compression = W.compression.toUpperCase()), typeof W.unixPermissions == "string" && (W.unixPermissions = parseInt(W.unixPermissions, 8)), W.unixPermissions && 16384 & W.unixPermissions && (W.dir = !0), W.dosPermissions && 16 & W.dosPermissions && (W.dir = !0), W.dir && (x = a(x)), W.createFolders && (M = n(x)) && l.call(this, M, !0);
                        var V = A === "string" && W.binary === !1 && W.base64 === !1;
                        T && T.binary !== void 0 || (W.binary = !V), (U instanceof _ && U.uncompressedSize === 0 || W.dir || !U || U.length === 0) && (W.base64 = !1, W.binary = !0, U = "", W.compression = "STORE", A = "string");
                        var m = null;
                        m = U instanceof _ || U instanceof u ? U : d.isNode && d.isStream(U) ? new p(x, U) : t.prepareContent(x, U, W.binary, W.optimizedBinaryString, W.base64);
                        var I = new g(x, m, W);
                        this.files[x] = I;
                    }
                    var f = c("./utf8"), t = c("./utils"), u = c("./stream/GenericWorker"), b = c("./stream/StreamHelper"), v = c("./defaults"), _ = c("./compressedObject"), g = c("./zipObject"), i = c("./generate"), d = c("./nodejsUtils"), p = c("./nodejs/NodejsStreamInputAdapter"), n = function(x) {
                        x.slice(-1) === "/" && (x = x.substring(0, x.length - 1));
                        var U = x.lastIndexOf("/");
                        return 0 < U ? x.substring(0, U) : "";
                    }, a = function(x) {
                        return x.slice(-1) !== "/" && (x += "/"), x;
                    }, l = function(x, U) {
                        return U = U !== void 0 ? U : v.createFolders, x = a(x), this.files[x] || o.call(this, x, null, {
                            dir: !0,
                            createFolders: U
                        }), this.files[x];
                    };
                    function w(x) {
                        return Object.prototype.toString.call(x) === "[object RegExp]";
                    }
                    var O = {
                        load: function() {
                            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                        },
                        forEach: function(x) {
                            var U, T, M;
                            for(U in this.files)M = this.files[U], (T = U.slice(this.root.length, U.length)) && U.slice(0, this.root.length) === this.root && x(T, M);
                        },
                        filter: function(x) {
                            var U = [];
                            return this.forEach(function(T, M) {
                                x(T, M) && U.push(M);
                            }), U;
                        },
                        file: function(x, U, T) {
                            if (arguments.length !== 1) return x = this.root + x, o.call(this, x, U, T), this;
                            if (w(x)) {
                                var M = x;
                                return this.filter(function(W, V) {
                                    return !V.dir && M.test(W);
                                });
                            }
                            var A = this.files[this.root + x];
                            return A && !A.dir ? A : null;
                        },
                        folder: function(x) {
                            if (!x) return this;
                            if (w(x)) return this.filter(function(A, W) {
                                return W.dir && x.test(A);
                            });
                            var U = this.root + x, T = l.call(this, U), M = this.clone();
                            return M.root = T.name, M;
                        },
                        remove: function(x) {
                            x = this.root + x;
                            var U = this.files[x];
                            if (U || (x.slice(-1) !== "/" && (x += "/"), U = this.files[x]), U && !U.dir) delete this.files[x];
                            else for(var T = this.filter(function(A, W) {
                                return W.name.slice(0, x.length) === x;
                            }), M = 0; M < T.length; M++)delete this.files[T[M].name];
                            return this;
                        },
                        generate: function(x) {
                            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                        },
                        generateInternalStream: function(x) {
                            var U, T = {};
                            try {
                                if ((T = t.extend(x || {}, {
                                    streamFiles: !1,
                                    compression: "STORE",
                                    compressionOptions: null,
                                    type: "",
                                    platform: "DOS",
                                    comment: null,
                                    mimeType: "application/zip",
                                    encodeFileName: f.utf8encode
                                })).type = T.type.toLowerCase(), T.compression = T.compression.toUpperCase(), T.type === "binarystring" && (T.type = "string"), !T.type) throw new Error("No output type specified.");
                                t.checkSupport(T.type), T.platform !== "darwin" && T.platform !== "freebsd" && T.platform !== "linux" && T.platform !== "sunos" || (T.platform = "UNIX"), T.platform === "win32" && (T.platform = "DOS");
                                var M = T.comment || this.comment || "";
                                U = i.generateWorker(this, T, M);
                            } catch (A) {
                                (U = new u("error")).error(A);
                            }
                            return new b(U, T.type || "string", T.mimeType);
                        },
                        generateAsync: function(x, U) {
                            return this.generateInternalStream(x).accumulate(U);
                        },
                        generateNodeStream: function(x, U) {
                            return (x = x || {}).type || (x.type = "nodebuffer"), this.generateInternalStream(x).toNodejsStream(U);
                        }
                    };
                    R.exports = O;
                },
                {
                    "./compressedObject": 2,
                    "./defaults": 5,
                    "./generate": 9,
                    "./nodejs/NodejsStreamInputAdapter": 12,
                    "./nodejsUtils": 14,
                    "./stream/GenericWorker": 28,
                    "./stream/StreamHelper": 29,
                    "./utf8": 31,
                    "./utils": 32,
                    "./zipObject": 35
                }
            ],
            16: [
                function(c, R, y) {
                    R.exports = c("stream");
                },
                {
                    stream: void 0
                }
            ],
            17: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./DataReader");
                    function f(t) {
                        o.call(this, t);
                        for(var u = 0; u < this.data.length; u++)t[u] = 255 & t[u];
                    }
                    c("../utils").inherits(f, o), f.prototype.byteAt = function(t) {
                        return this.data[this.zero + t];
                    }, f.prototype.lastIndexOfSignature = function(t) {
                        for(var u = t.charCodeAt(0), b = t.charCodeAt(1), v = t.charCodeAt(2), _ = t.charCodeAt(3), g = this.length - 4; 0 <= g; --g)if (this.data[g] === u && this.data[g + 1] === b && this.data[g + 2] === v && this.data[g + 3] === _) return g - this.zero;
                        return -1;
                    }, f.prototype.readAndCheckSignature = function(t) {
                        var u = t.charCodeAt(0), b = t.charCodeAt(1), v = t.charCodeAt(2), _ = t.charCodeAt(3), g = this.readData(4);
                        return u === g[0] && b === g[1] && v === g[2] && _ === g[3];
                    }, f.prototype.readData = function(t) {
                        if (this.checkOffset(t), t === 0) return [];
                        var u = this.data.slice(this.zero + this.index, this.zero + this.index + t);
                        return this.index += t, u;
                    }, R.exports = f;
                },
                {
                    "../utils": 32,
                    "./DataReader": 18
                }
            ],
            18: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils");
                    function f(t) {
                        this.data = t, this.length = t.length, this.index = 0, this.zero = 0;
                    }
                    f.prototype = {
                        checkOffset: function(t) {
                            this.checkIndex(this.index + t);
                        },
                        checkIndex: function(t) {
                            if (this.length < this.zero + t || t < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t + "). Corrupted zip ?");
                        },
                        setIndex: function(t) {
                            this.checkIndex(t), this.index = t;
                        },
                        skip: function(t) {
                            this.setIndex(this.index + t);
                        },
                        byteAt: function(t) {},
                        readInt: function(t) {
                            var u, b = 0;
                            for(this.checkOffset(t), u = this.index + t - 1; u >= this.index; u--)b = (b << 8) + this.byteAt(u);
                            return this.index += t, b;
                        },
                        readString: function(t) {
                            return o.transformTo("string", this.readData(t));
                        },
                        readData: function(t) {},
                        lastIndexOfSignature: function(t) {},
                        readAndCheckSignature: function(t) {},
                        readDate: function() {
                            var t = this.readInt(4);
                            return new Date(Date.UTC(1980 + (t >> 25 & 127), (t >> 21 & 15) - 1, t >> 16 & 31, t >> 11 & 31, t >> 5 & 63, (31 & t) << 1));
                        }
                    }, R.exports = f;
                },
                {
                    "../utils": 32
                }
            ],
            19: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./Uint8ArrayReader");
                    function f(t) {
                        o.call(this, t);
                    }
                    c("../utils").inherits(f, o), f.prototype.readData = function(t) {
                        this.checkOffset(t);
                        var u = this.data.slice(this.zero + this.index, this.zero + this.index + t);
                        return this.index += t, u;
                    }, R.exports = f;
                },
                {
                    "../utils": 32,
                    "./Uint8ArrayReader": 21
                }
            ],
            20: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./DataReader");
                    function f(t) {
                        o.call(this, t);
                    }
                    c("../utils").inherits(f, o), f.prototype.byteAt = function(t) {
                        return this.data.charCodeAt(this.zero + t);
                    }, f.prototype.lastIndexOfSignature = function(t) {
                        return this.data.lastIndexOf(t) - this.zero;
                    }, f.prototype.readAndCheckSignature = function(t) {
                        return t === this.readData(4);
                    }, f.prototype.readData = function(t) {
                        this.checkOffset(t);
                        var u = this.data.slice(this.zero + this.index, this.zero + this.index + t);
                        return this.index += t, u;
                    }, R.exports = f;
                },
                {
                    "../utils": 32,
                    "./DataReader": 18
                }
            ],
            21: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./ArrayReader");
                    function f(t) {
                        o.call(this, t);
                    }
                    c("../utils").inherits(f, o), f.prototype.readData = function(t) {
                        if (this.checkOffset(t), t === 0) return new Uint8Array(0);
                        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + t);
                        return this.index += t, u;
                    }, R.exports = f;
                },
                {
                    "../utils": 32,
                    "./ArrayReader": 17
                }
            ],
            22: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils"), f = c("../support"), t = c("./ArrayReader"), u = c("./StringReader"), b = c("./NodeBufferReader"), v = c("./Uint8ArrayReader");
                    R.exports = function(_) {
                        var g = o.getTypeOf(_);
                        return o.checkSupport(g), g !== "string" || f.uint8array ? g === "nodebuffer" ? new b(_) : f.uint8array ? new v(o.transformTo("uint8array", _)) : new t(o.transformTo("array", _)) : new u(_);
                    };
                },
                {
                    "../support": 30,
                    "../utils": 32,
                    "./ArrayReader": 17,
                    "./NodeBufferReader": 19,
                    "./StringReader": 20,
                    "./Uint8ArrayReader": 21
                }
            ],
            23: [
                function(c, R, y) {
                    "use strict";
                    y.LOCAL_FILE_HEADER = "PK", y.CENTRAL_FILE_HEADER = "PK", y.CENTRAL_DIRECTORY_END = "PK", y.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", y.ZIP64_CENTRAL_DIRECTORY_END = "PK", y.DATA_DESCRIPTOR = "PK\x07\b";
                },
                {}
            ],
            24: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./GenericWorker"), f = c("../utils");
                    function t(u) {
                        o.call(this, "ConvertWorker to " + u), this.destType = u;
                    }
                    f.inherits(t, o), t.prototype.processChunk = function(u) {
                        this.push({
                            data: f.transformTo(this.destType, u.data),
                            meta: u.meta
                        });
                    }, R.exports = t;
                },
                {
                    "../utils": 32,
                    "./GenericWorker": 28
                }
            ],
            25: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./GenericWorker"), f = c("../crc32");
                    function t() {
                        o.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                    }
                    c("../utils").inherits(t, o), t.prototype.processChunk = function(u) {
                        this.streamInfo.crc32 = f(u.data, this.streamInfo.crc32 || 0), this.push(u);
                    }, R.exports = t;
                },
                {
                    "../crc32": 4,
                    "../utils": 32,
                    "./GenericWorker": 28
                }
            ],
            26: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils"), f = c("./GenericWorker");
                    function t(u) {
                        f.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
                    }
                    o.inherits(t, f), t.prototype.processChunk = function(u) {
                        if (u) {
                            var b = this.streamInfo[this.propName] || 0;
                            this.streamInfo[this.propName] = b + u.data.length;
                        }
                        f.prototype.processChunk.call(this, u);
                    }, R.exports = t;
                },
                {
                    "../utils": 32,
                    "./GenericWorker": 28
                }
            ],
            27: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils"), f = c("./GenericWorker");
                    function t(u) {
                        f.call(this, "DataWorker");
                        var b = this;
                        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(v) {
                            b.dataIsReady = !0, b.data = v, b.max = v && v.length || 0, b.type = o.getTypeOf(v), b.isPaused || b._tickAndRepeat();
                        }, function(v) {
                            b.error(v);
                        });
                    }
                    o.inherits(t, f), t.prototype.cleanUp = function() {
                        f.prototype.cleanUp.call(this), this.data = null;
                    }, t.prototype.resume = function() {
                        return !!f.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, o.delay(this._tickAndRepeat, [], this)), !0);
                    }, t.prototype._tickAndRepeat = function() {
                        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (o.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
                    }, t.prototype._tick = function() {
                        if (this.isPaused || this.isFinished) return !1;
                        var u = null, b = Math.min(this.max, this.index + 16384);
                        if (this.index >= this.max) return this.end();
                        switch(this.type){
                            case "string":
                                u = this.data.substring(this.index, b);
                                break;
                            case "uint8array":
                                u = this.data.subarray(this.index, b);
                                break;
                            case "array":
                            case "nodebuffer":
                                u = this.data.slice(this.index, b);
                        }
                        return this.index = b, this.push({
                            data: u,
                            meta: {
                                percent: this.max ? this.index / this.max * 100 : 0
                            }
                        });
                    }, R.exports = t;
                },
                {
                    "../utils": 32,
                    "./GenericWorker": 28
                }
            ],
            28: [
                function(c, R, y) {
                    "use strict";
                    function o(f) {
                        this.name = f || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
                            data: [],
                            end: [],
                            error: []
                        }, this.previous = null;
                    }
                    o.prototype = {
                        push: function(f) {
                            this.emit("data", f);
                        },
                        end: function() {
                            if (this.isFinished) return !1;
                            this.flush();
                            try {
                                this.emit("end"), this.cleanUp(), this.isFinished = !0;
                            } catch (f) {
                                this.emit("error", f);
                            }
                            return !0;
                        },
                        error: function(f) {
                            return !this.isFinished && (this.isPaused ? this.generatedError = f : (this.isFinished = !0, this.emit("error", f), this.previous && this.previous.error(f), this.cleanUp()), !0);
                        },
                        on: function(f, t) {
                            return this._listeners[f].push(t), this;
                        },
                        cleanUp: function() {
                            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                        },
                        emit: function(f, t) {
                            if (this._listeners[f]) for(var u = 0; u < this._listeners[f].length; u++)this._listeners[f][u].call(this, t);
                        },
                        pipe: function(f) {
                            return f.registerPrevious(this);
                        },
                        registerPrevious: function(f) {
                            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                            this.streamInfo = f.streamInfo, this.mergeStreamInfo(), this.previous = f;
                            var t = this;
                            return f.on("data", function(u) {
                                t.processChunk(u);
                            }), f.on("end", function() {
                                t.end();
                            }), f.on("error", function(u) {
                                t.error(u);
                            }), this;
                        },
                        pause: function() {
                            return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
                        },
                        resume: function() {
                            if (!this.isPaused || this.isFinished) return !1;
                            var f = this.isPaused = !1;
                            return this.generatedError && (this.error(this.generatedError), f = !0), this.previous && this.previous.resume(), !f;
                        },
                        flush: function() {},
                        processChunk: function(f) {
                            this.push(f);
                        },
                        withStreamInfo: function(f, t) {
                            return this.extraStreamInfo[f] = t, this.mergeStreamInfo(), this;
                        },
                        mergeStreamInfo: function() {
                            for(var f in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(f) && (this.streamInfo[f] = this.extraStreamInfo[f]);
                        },
                        lock: function() {
                            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                            this.isLocked = !0, this.previous && this.previous.lock();
                        },
                        toString: function() {
                            var f = "Worker " + this.name;
                            return this.previous ? this.previous + " -> " + f : f;
                        }
                    }, R.exports = o;
                },
                {}
            ],
            29: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils"), f = c("./ConvertWorker"), t = c("./GenericWorker"), u = c("../base64"), b = c("../support"), v = c("../external"), _ = null;
                    if (b.nodestream) try {
                        _ = c("../nodejs/NodejsStreamOutputAdapter");
                    } catch  {}
                    function g(d, p) {
                        return new v.Promise(function(n, a) {
                            var l = [], w = d._internalType, O = d._outputType, x = d._mimeType;
                            d.on("data", function(U, T) {
                                l.push(U), p && p(T);
                            }).on("error", function(U) {
                                l = [], a(U);
                            }).on("end", function() {
                                try {
                                    var U = function(T, M, A) {
                                        switch(T){
                                            case "blob":
                                                return o.newBlob(o.transformTo("arraybuffer", M), A);
                                            case "base64":
                                                return u.encode(M);
                                            default:
                                                return o.transformTo(T, M);
                                        }
                                    }(O, function(T, M) {
                                        var A, W = 0, V = null, m = 0;
                                        for(A = 0; A < M.length; A++)m += M[A].length;
                                        switch(T){
                                            case "string":
                                                return M.join("");
                                            case "array":
                                                return Array.prototype.concat.apply([], M);
                                            case "uint8array":
                                                for(V = new Uint8Array(m), A = 0; A < M.length; A++)V.set(M[A], W), W += M[A].length;
                                                return V;
                                            case "nodebuffer":
                                                return Buffer1.concat(M);
                                            default:
                                                throw new Error("concat : unsupported type '" + T + "'");
                                        }
                                    }(w, l), x);
                                    n(U);
                                } catch (T) {
                                    a(T);
                                }
                                l = [];
                            }).resume();
                        });
                    }
                    function i(d, p, n) {
                        var a = p;
                        switch(p){
                            case "blob":
                            case "arraybuffer":
                                a = "uint8array";
                                break;
                            case "base64":
                                a = "string";
                        }
                        try {
                            this._internalType = a, this._outputType = p, this._mimeType = n, o.checkSupport(a), this._worker = d.pipe(new f(a)), d.lock();
                        } catch (l) {
                            this._worker = new t("error"), this._worker.error(l);
                        }
                    }
                    i.prototype = {
                        accumulate: function(d) {
                            return g(this, d);
                        },
                        on: function(d, p) {
                            var n = this;
                            return d === "data" ? this._worker.on(d, function(a) {
                                p.call(n, a.data, a.meta);
                            }) : this._worker.on(d, function() {
                                o.delay(p, arguments, n);
                            }), this;
                        },
                        resume: function() {
                            return o.delay(this._worker.resume, [], this._worker), this;
                        },
                        pause: function() {
                            return this._worker.pause(), this;
                        },
                        toNodejsStream: function(d) {
                            if (o.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
                            return new _(this, {
                                objectMode: this._outputType !== "nodebuffer"
                            }, d);
                        }
                    }, R.exports = i;
                },
                {
                    "../base64": 1,
                    "../external": 6,
                    "../nodejs/NodejsStreamOutputAdapter": 13,
                    "../support": 30,
                    "../utils": 32,
                    "./ConvertWorker": 24,
                    "./GenericWorker": 28
                }
            ],
            30: [
                function(c, R, y) {
                    "use strict";
                    if (y.base64 = !0, y.array = !0, y.string = !0, y.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", y.nodebuffer = typeof Buffer1 < "u", y.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") y.blob = !1;
                    else {
                        var o = new ArrayBuffer(0);
                        try {
                            y.blob = new Blob([
                                o
                            ], {
                                type: "application/zip"
                            }).size === 0;
                        } catch  {
                            try {
                                var f = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                                f.append(o), y.blob = f.getBlob("application/zip").size === 0;
                            } catch  {
                                y.blob = !1;
                            }
                        }
                    }
                    try {
                        y.nodestream = !!c("readable-stream").Readable;
                    } catch  {
                        y.nodestream = !1;
                    }
                },
                {
                    "readable-stream": 16
                }
            ],
            31: [
                function(c, R, y) {
                    "use strict";
                    for(var o = c("./utils"), f = c("./support"), t = c("./nodejsUtils"), u = c("./stream/GenericWorker"), b = new Array(256), v = 0; v < 256; v++)b[v] = 252 <= v ? 6 : 248 <= v ? 5 : 240 <= v ? 4 : 224 <= v ? 3 : 192 <= v ? 2 : 1;
                    b[254] = b[254] = 1;
                    function _() {
                        u.call(this, "utf-8 decode"), this.leftOver = null;
                    }
                    function g() {
                        u.call(this, "utf-8 encode");
                    }
                    y.utf8encode = function(i) {
                        return f.nodebuffer ? t.newBufferFrom(i, "utf-8") : function(d) {
                            var p, n, a, l, w, O = d.length, x = 0;
                            for(l = 0; l < O; l++)(64512 & (n = d.charCodeAt(l))) == 55296 && l + 1 < O && (64512 & (a = d.charCodeAt(l + 1))) == 56320 && (n = 65536 + (n - 55296 << 10) + (a - 56320), l++), x += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
                            for(p = f.uint8array ? new Uint8Array(x) : new Array(x), l = w = 0; w < x; l++)(64512 & (n = d.charCodeAt(l))) == 55296 && l + 1 < O && (64512 & (a = d.charCodeAt(l + 1))) == 56320 && (n = 65536 + (n - 55296 << 10) + (a - 56320), l++), n < 128 ? p[w++] = n : (n < 2048 ? p[w++] = 192 | n >>> 6 : (n < 65536 ? p[w++] = 224 | n >>> 12 : (p[w++] = 240 | n >>> 18, p[w++] = 128 | n >>> 12 & 63), p[w++] = 128 | n >>> 6 & 63), p[w++] = 128 | 63 & n);
                            return p;
                        }(i);
                    }, y.utf8decode = function(i) {
                        return f.nodebuffer ? o.transformTo("nodebuffer", i).toString("utf-8") : function(d) {
                            var p, n, a, l, w = d.length, O = new Array(2 * w);
                            for(p = n = 0; p < w;)if ((a = d[p++]) < 128) O[n++] = a;
                            else if (4 < (l = b[a])) O[n++] = 65533, p += l - 1;
                            else {
                                for(a &= l === 2 ? 31 : l === 3 ? 15 : 7; 1 < l && p < w;)a = a << 6 | 63 & d[p++], l--;
                                1 < l ? O[n++] = 65533 : a < 65536 ? O[n++] = a : (a -= 65536, O[n++] = 55296 | a >> 10 & 1023, O[n++] = 56320 | 1023 & a);
                            }
                            return O.length !== n && (O.subarray ? O = O.subarray(0, n) : O.length = n), o.applyFromCharCode(O);
                        }(i = o.transformTo(f.uint8array ? "uint8array" : "array", i));
                    }, o.inherits(_, u), _.prototype.processChunk = function(i) {
                        var d = o.transformTo(f.uint8array ? "uint8array" : "array", i.data);
                        if (this.leftOver && this.leftOver.length) {
                            if (f.uint8array) {
                                var p = d;
                                (d = new Uint8Array(p.length + this.leftOver.length)).set(this.leftOver, 0), d.set(p, this.leftOver.length);
                            } else d = this.leftOver.concat(d);
                            this.leftOver = null;
                        }
                        var n = function(l, w) {
                            var O;
                            for((w = w || l.length) > l.length && (w = l.length), O = w - 1; 0 <= O && (192 & l[O]) == 128;)O--;
                            return O < 0 || O === 0 ? w : O + b[l[O]] > w ? O : w;
                        }(d), a = d;
                        n !== d.length && (f.uint8array ? (a = d.subarray(0, n), this.leftOver = d.subarray(n, d.length)) : (a = d.slice(0, n), this.leftOver = d.slice(n, d.length))), this.push({
                            data: y.utf8decode(a),
                            meta: i.meta
                        });
                    }, _.prototype.flush = function() {
                        this.leftOver && this.leftOver.length && (this.push({
                            data: y.utf8decode(this.leftOver),
                            meta: {}
                        }), this.leftOver = null);
                    }, y.Utf8DecodeWorker = _, o.inherits(g, u), g.prototype.processChunk = function(i) {
                        this.push({
                            data: y.utf8encode(i.data),
                            meta: i.meta
                        });
                    }, y.Utf8EncodeWorker = g;
                },
                {
                    "./nodejsUtils": 14,
                    "./stream/GenericWorker": 28,
                    "./support": 30,
                    "./utils": 32
                }
            ],
            32: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./support"), f = c("./base64"), t = c("./nodejsUtils"), u = c("set-immediate-shim"), b = c("./external");
                    function v(n) {
                        return n;
                    }
                    function _(n, a) {
                        for(var l = 0; l < n.length; ++l)a[l] = 255 & n.charCodeAt(l);
                        return a;
                    }
                    y.newBlob = function(n, a) {
                        y.checkSupport("blob");
                        try {
                            return new Blob([
                                n
                            ], {
                                type: a
                            });
                        } catch  {
                            try {
                                var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                                return l.append(n), l.getBlob(a);
                            } catch  {
                                throw new Error("Bug : can't construct the Blob.");
                            }
                        }
                    };
                    var g = {
                        stringifyByChunk: function(n, a, l) {
                            var w = [], O = 0, x = n.length;
                            if (x <= l) return String.fromCharCode.apply(null, n);
                            for(; O < x;)a === "array" || a === "nodebuffer" ? w.push(String.fromCharCode.apply(null, n.slice(O, Math.min(O + l, x)))) : w.push(String.fromCharCode.apply(null, n.subarray(O, Math.min(O + l, x)))), O += l;
                            return w.join("");
                        },
                        stringifyByChar: function(n) {
                            for(var a = "", l = 0; l < n.length; l++)a += String.fromCharCode(n[l]);
                            return a;
                        },
                        applyCanBeUsed: {
                            uint8array: function() {
                                try {
                                    return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                                } catch  {
                                    return !1;
                                }
                            }(),
                            nodebuffer: function() {
                                try {
                                    return o.nodebuffer && String.fromCharCode.apply(null, t.allocBuffer(1)).length === 1;
                                } catch  {
                                    return !1;
                                }
                            }()
                        }
                    };
                    function i(n) {
                        var a = 65536, l = y.getTypeOf(n), w = !0;
                        if (l === "uint8array" ? w = g.applyCanBeUsed.uint8array : l === "nodebuffer" && (w = g.applyCanBeUsed.nodebuffer), w) for(; 1 < a;)try {
                            return g.stringifyByChunk(n, l, a);
                        } catch  {
                            a = Math.floor(a / 2);
                        }
                        return g.stringifyByChar(n);
                    }
                    function d(n, a) {
                        for(var l = 0; l < n.length; l++)a[l] = n[l];
                        return a;
                    }
                    y.applyFromCharCode = i;
                    var p = {};
                    p.string = {
                        string: v,
                        array: function(n) {
                            return _(n, new Array(n.length));
                        },
                        arraybuffer: function(n) {
                            return p.string.uint8array(n).buffer;
                        },
                        uint8array: function(n) {
                            return _(n, new Uint8Array(n.length));
                        },
                        nodebuffer: function(n) {
                            return _(n, t.allocBuffer(n.length));
                        }
                    }, p.array = {
                        string: i,
                        array: v,
                        arraybuffer: function(n) {
                            return new Uint8Array(n).buffer;
                        },
                        uint8array: function(n) {
                            return new Uint8Array(n);
                        },
                        nodebuffer: function(n) {
                            return t.newBufferFrom(n);
                        }
                    }, p.arraybuffer = {
                        string: function(n) {
                            return i(new Uint8Array(n));
                        },
                        array: function(n) {
                            return d(new Uint8Array(n), new Array(n.byteLength));
                        },
                        arraybuffer: v,
                        uint8array: function(n) {
                            return new Uint8Array(n);
                        },
                        nodebuffer: function(n) {
                            return t.newBufferFrom(new Uint8Array(n));
                        }
                    }, p.uint8array = {
                        string: i,
                        array: function(n) {
                            return d(n, new Array(n.length));
                        },
                        arraybuffer: function(n) {
                            return n.buffer;
                        },
                        uint8array: v,
                        nodebuffer: function(n) {
                            return t.newBufferFrom(n);
                        }
                    }, p.nodebuffer = {
                        string: i,
                        array: function(n) {
                            return d(n, new Array(n.length));
                        },
                        arraybuffer: function(n) {
                            return p.nodebuffer.uint8array(n).buffer;
                        },
                        uint8array: function(n) {
                            return d(n, new Uint8Array(n.length));
                        },
                        nodebuffer: v
                    }, y.transformTo = function(n, a) {
                        if (a = a || "", !n) return a;
                        y.checkSupport(n);
                        var l = y.getTypeOf(a);
                        return p[l][n](a);
                    }, y.getTypeOf = function(n) {
                        return typeof n == "string" ? "string" : Object.prototype.toString.call(n) === "[object Array]" ? "array" : o.nodebuffer && t.isBuffer(n) ? "nodebuffer" : o.uint8array && n instanceof Uint8Array ? "uint8array" : o.arraybuffer && n instanceof ArrayBuffer ? "arraybuffer" : void 0;
                    }, y.checkSupport = function(n) {
                        if (!o[n.toLowerCase()]) throw new Error(n + " is not supported by this platform");
                    }, y.MAX_VALUE_16BITS = 65535, y.MAX_VALUE_32BITS = -1, y.pretty = function(n) {
                        var a, l, w = "";
                        for(l = 0; l < (n || "").length; l++)w += "\\x" + ((a = n.charCodeAt(l)) < 16 ? "0" : "") + a.toString(16).toUpperCase();
                        return w;
                    }, y.delay = function(n, a, l) {
                        u(function() {
                            n.apply(l || null, a || []);
                        });
                    }, y.inherits = function(n, a) {
                        function l() {}
                        l.prototype = a.prototype, n.prototype = new l;
                    }, y.extend = function() {
                        var n, a, l = {};
                        for(n = 0; n < arguments.length; n++)for(a in arguments[n])arguments[n].hasOwnProperty(a) && l[a] === void 0 && (l[a] = arguments[n][a]);
                        return l;
                    }, y.prepareContent = function(n, a, l, w, O) {
                        return b.Promise.resolve(a).then(function(x) {
                            return o.blob && (x instanceof Blob || [
                                "[object File]",
                                "[object Blob]"
                            ].indexOf(Object.prototype.toString.call(x)) !== -1) && typeof FileReader < "u" ? new b.Promise(function(U, T) {
                                var M = new FileReader;
                                M.onload = function(A) {
                                    U(A.target.result);
                                }, M.onerror = function(A) {
                                    T(A.target.error);
                                }, M.readAsArrayBuffer(x);
                            }) : x;
                        }).then(function(x) {
                            var U = y.getTypeOf(x);
                            return U ? (U === "arraybuffer" ? x = y.transformTo("uint8array", x) : U === "string" && (O ? x = f.decode(x) : l && w !== !0 && (x = function(T) {
                                return _(T, o.uint8array ? new Uint8Array(T.length) : new Array(T.length));
                            }(x))), x) : b.Promise.reject(new Error("Can't read the data of '" + n + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                        });
                    };
                },
                {
                    "./base64": 1,
                    "./external": 6,
                    "./nodejsUtils": 14,
                    "./support": 30,
                    "set-immediate-shim": 54
                }
            ],
            33: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./reader/readerFor"), f = c("./utils"), t = c("./signature"), u = c("./zipEntry"), b = (c("./utf8"), c("./support"));
                    function v(_) {
                        this.files = [], this.loadOptions = _;
                    }
                    v.prototype = {
                        checkSignature: function(_) {
                            if (!this.reader.readAndCheckSignature(_)) {
                                this.reader.index -= 4;
                                var g = this.reader.readString(4);
                                throw new Error("Corrupted zip or bug: unexpected signature (" + f.pretty(g) + ", expected " + f.pretty(_) + ")");
                            }
                        },
                        isSignature: function(_, g) {
                            var i = this.reader.index;
                            this.reader.setIndex(_);
                            var d = this.reader.readString(4) === g;
                            return this.reader.setIndex(i), d;
                        },
                        readBlockEndOfCentral: function() {
                            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                            var _ = this.reader.readData(this.zipCommentLength), g = b.uint8array ? "uint8array" : "array", i = f.transformTo(g, _);
                            this.zipComment = this.loadOptions.decodeFileName(i);
                        },
                        readBlockZip64EndOfCentral: function() {
                            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                            for(var _, g, i, d = this.zip64EndOfCentralSize - 44; 0 < d;)_ = this.reader.readInt(2), g = this.reader.readInt(4), i = this.reader.readData(g), this.zip64ExtensibleData[_] = {
                                id: _,
                                length: g,
                                value: i
                            };
                        },
                        readBlockZip64EndOfCentralLocator: function() {
                            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
                        },
                        readLocalFiles: function() {
                            var _, g;
                            for(_ = 0; _ < this.files.length; _++)g = this.files[_], this.reader.setIndex(g.localHeaderOffset), this.checkSignature(t.LOCAL_FILE_HEADER), g.readLocalPart(this.reader), g.handleUTF8(), g.processAttributes();
                        },
                        readCentralDir: function() {
                            var _;
                            for(this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(t.CENTRAL_FILE_HEADER);)(_ = new u({
                                zip64: this.zip64
                            }, this.loadOptions)).readCentralPart(this.reader), this.files.push(_);
                            if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                        },
                        readEndOfCentral: function() {
                            var _ = this.reader.lastIndexOfSignature(t.CENTRAL_DIRECTORY_END);
                            if (_ < 0) throw this.isSignature(0, t.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                            this.reader.setIndex(_);
                            var g = _;
                            if (this.checkSignature(t.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === f.MAX_VALUE_16BITS || this.diskWithCentralDirStart === f.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === f.MAX_VALUE_16BITS || this.centralDirRecords === f.MAX_VALUE_16BITS || this.centralDirSize === f.MAX_VALUE_32BITS || this.centralDirOffset === f.MAX_VALUE_32BITS) {
                                if (this.zip64 = !0, (_ = this.reader.lastIndexOfSignature(t.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                                if (this.reader.setIndex(_), this.checkSignature(t.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, t.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(t.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(t.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                            }
                            var i = this.centralDirOffset + this.centralDirSize;
                            this.zip64 && (i += 20, i += 12 + this.zip64EndOfCentralSize);
                            var d = g - i;
                            if (0 < d) this.isSignature(g, t.CENTRAL_FILE_HEADER) || (this.reader.zero = d);
                            else if (d < 0) throw new Error("Corrupted zip: missing " + Math.abs(d) + " bytes.");
                        },
                        prepareReader: function(_) {
                            this.reader = o(_);
                        },
                        load: function(_) {
                            this.prepareReader(_), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                        }
                    }, R.exports = v;
                },
                {
                    "./reader/readerFor": 22,
                    "./signature": 23,
                    "./support": 30,
                    "./utf8": 31,
                    "./utils": 32,
                    "./zipEntry": 34
                }
            ],
            34: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./reader/readerFor"), f = c("./utils"), t = c("./compressedObject"), u = c("./crc32"), b = c("./utf8"), v = c("./compressions"), _ = c("./support");
                    function g(i, d) {
                        this.options = i, this.loadOptions = d;
                    }
                    g.prototype = {
                        isEncrypted: function() {
                            return (1 & this.bitFlag) == 1;
                        },
                        useUTF8: function() {
                            return (2048 & this.bitFlag) == 2048;
                        },
                        readLocalPart: function(i) {
                            var d, p;
                            if (i.skip(22), this.fileNameLength = i.readInt(2), p = i.readInt(2), this.fileName = i.readData(this.fileNameLength), i.skip(p), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                            if ((d = function(n) {
                                for(var a in v)if (v.hasOwnProperty(a) && v[a].magic === n) return v[a];
                                return null;
                            }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + f.pretty(this.compressionMethod) + " unknown (inner file : " + f.transformTo("string", this.fileName) + ")");
                            this.decompressed = new t(this.compressedSize, this.uncompressedSize, this.crc32, d, i.readData(this.compressedSize));
                        },
                        readCentralPart: function(i) {
                            this.versionMadeBy = i.readInt(2), i.skip(2), this.bitFlag = i.readInt(2), this.compressionMethod = i.readString(2), this.date = i.readDate(), this.crc32 = i.readInt(4), this.compressedSize = i.readInt(4), this.uncompressedSize = i.readInt(4);
                            var d = i.readInt(2);
                            if (this.extraFieldsLength = i.readInt(2), this.fileCommentLength = i.readInt(2), this.diskNumberStart = i.readInt(2), this.internalFileAttributes = i.readInt(2), this.externalFileAttributes = i.readInt(4), this.localHeaderOffset = i.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                            i.skip(d), this.readExtraFields(i), this.parseZIP64ExtraField(i), this.fileComment = i.readData(this.fileCommentLength);
                        },
                        processAttributes: function() {
                            this.unixPermissions = null, this.dosPermissions = null;
                            var i = this.versionMadeBy >> 8;
                            this.dir = !!(16 & this.externalFileAttributes), i == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), i == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
                        },
                        parseZIP64ExtraField: function(i) {
                            if (this.extraFields[1]) {
                                var d = o(this.extraFields[1].value);
                                this.uncompressedSize === f.MAX_VALUE_32BITS && (this.uncompressedSize = d.readInt(8)), this.compressedSize === f.MAX_VALUE_32BITS && (this.compressedSize = d.readInt(8)), this.localHeaderOffset === f.MAX_VALUE_32BITS && (this.localHeaderOffset = d.readInt(8)), this.diskNumberStart === f.MAX_VALUE_32BITS && (this.diskNumberStart = d.readInt(4));
                            }
                        },
                        readExtraFields: function(i) {
                            var d, p, n, a = i.index + this.extraFieldsLength;
                            for(this.extraFields || (this.extraFields = {}); i.index + 4 < a;)d = i.readInt(2), p = i.readInt(2), n = i.readData(p), this.extraFields[d] = {
                                id: d,
                                length: p,
                                value: n
                            };
                            i.setIndex(a);
                        },
                        handleUTF8: function() {
                            var i = _.uint8array ? "uint8array" : "array";
                            if (this.useUTF8()) this.fileNameStr = b.utf8decode(this.fileName), this.fileCommentStr = b.utf8decode(this.fileComment);
                            else {
                                var d = this.findExtraFieldUnicodePath();
                                if (d !== null) this.fileNameStr = d;
                                else {
                                    var p = f.transformTo(i, this.fileName);
                                    this.fileNameStr = this.loadOptions.decodeFileName(p);
                                }
                                var n = this.findExtraFieldUnicodeComment();
                                if (n !== null) this.fileCommentStr = n;
                                else {
                                    var a = f.transformTo(i, this.fileComment);
                                    this.fileCommentStr = this.loadOptions.decodeFileName(a);
                                }
                            }
                        },
                        findExtraFieldUnicodePath: function() {
                            var i = this.extraFields[28789];
                            if (i) {
                                var d = o(i.value);
                                return d.readInt(1) !== 1 || u(this.fileName) !== d.readInt(4) ? null : b.utf8decode(d.readData(i.length - 5));
                            }
                            return null;
                        },
                        findExtraFieldUnicodeComment: function() {
                            var i = this.extraFields[25461];
                            if (i) {
                                var d = o(i.value);
                                return d.readInt(1) !== 1 || u(this.fileComment) !== d.readInt(4) ? null : b.utf8decode(d.readData(i.length - 5));
                            }
                            return null;
                        }
                    }, R.exports = g;
                },
                {
                    "./compressedObject": 2,
                    "./compressions": 3,
                    "./crc32": 4,
                    "./reader/readerFor": 22,
                    "./support": 30,
                    "./utf8": 31,
                    "./utils": 32
                }
            ],
            35: [
                function(c, R, y) {
                    "use strict";
                    function o(d, p, n) {
                        this.name = d, this.dir = n.dir, this.date = n.date, this.comment = n.comment, this.unixPermissions = n.unixPermissions, this.dosPermissions = n.dosPermissions, this._data = p, this._dataBinary = n.binary, this.options = {
                            compression: n.compression,
                            compressionOptions: n.compressionOptions
                        };
                    }
                    var f = c("./stream/StreamHelper"), t = c("./stream/DataWorker"), u = c("./utf8"), b = c("./compressedObject"), v = c("./stream/GenericWorker");
                    o.prototype = {
                        internalStream: function(d) {
                            var p = null, n = "string";
                            try {
                                if (!d) throw new Error("No output type specified.");
                                var a = (n = d.toLowerCase()) === "string" || n === "text";
                                n !== "binarystring" && n !== "text" || (n = "string"), p = this._decompressWorker();
                                var l = !this._dataBinary;
                                l && !a && (p = p.pipe(new u.Utf8EncodeWorker)), !l && a && (p = p.pipe(new u.Utf8DecodeWorker));
                            } catch (w) {
                                (p = new v("error")).error(w);
                            }
                            return new f(p, n, "");
                        },
                        async: function(d, p) {
                            return this.internalStream(d).accumulate(p);
                        },
                        nodeStream: function(d, p) {
                            return this.internalStream(d || "nodebuffer").toNodejsStream(p);
                        },
                        _compressWorker: function(d, p) {
                            if (this._data instanceof b && this._data.compression.magic === d.magic) return this._data.getCompressedWorker();
                            var n = this._decompressWorker();
                            return this._dataBinary || (n = n.pipe(new u.Utf8EncodeWorker)), b.createWorkerFrom(n, d, p);
                        },
                        _decompressWorker: function() {
                            return this._data instanceof b ? this._data.getContentWorker() : this._data instanceof v ? this._data : new t(this._data);
                        }
                    };
                    for(var _ = [
                        "asText",
                        "asBinary",
                        "asNodeBuffer",
                        "asUint8Array",
                        "asArrayBuffer"
                    ], g = function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                    }, i = 0; i < _.length; i++)o.prototype[_[i]] = g;
                    R.exports = o;
                },
                {
                    "./compressedObject": 2,
                    "./stream/DataWorker": 27,
                    "./stream/GenericWorker": 28,
                    "./stream/StreamHelper": 29,
                    "./utf8": 31
                }
            ],
            36: [
                function(c, R, y) {
                    (function(o) {
                        "use strict";
                        var f, t, u = o.MutationObserver || o.WebKitMutationObserver;
                        if (u) {
                            var b = 0, v = new u(d), _ = o.document.createTextNode("");
                            v.observe(_, {
                                characterData: !0
                            }), f = function() {
                                _.data = b = ++b % 2;
                            };
                        } else if (o.setImmediate || o.MessageChannel === void 0) f = "document" in o && "onreadystatechange" in o.document.createElement("script") ? function() {
                            var p = o.document.createElement("script");
                            p.onreadystatechange = function() {
                                d(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
                            }, o.document.documentElement.appendChild(p);
                        } : function() {
                            setTimeout(d, 0);
                        };
                        else {
                            var g = new o.MessageChannel;
                            g.port1.onmessage = d, f = function() {
                                g.port2.postMessage(0);
                            };
                        }
                        var i = [];
                        function d() {
                            var p, n;
                            t = !0;
                            for(var a = i.length; a;){
                                for(n = i, i = [], p = -1; ++p < a;)n[p]();
                                a = i.length;
                            }
                            t = !1;
                        }
                        R.exports = function(p) {
                            i.push(p) !== 1 || t || f();
                        };
                    }).call(this, typeof __global$1 < "u" ? __global$1 : typeof self < "u" ? self : typeof document < "u" ? window : {});
                },
                {}
            ],
            37: [
                function(c, R, y) {
                    "use strict";
                    var o = c("immediate");
                    function f() {}
                    var t = {}, u = [
                        "REJECTED"
                    ], b = [
                        "FULFILLED"
                    ], v = [
                        "PENDING"
                    ];
                    function _(a) {
                        if (typeof a != "function") throw new TypeError("resolver must be a function");
                        this.state = v, this.queue = [], this.outcome = void 0, a !== f && p(this, a);
                    }
                    function g(a, l, w) {
                        this.promise = a, typeof l == "function" && (this.onFulfilled = l, this.callFulfilled = this.otherCallFulfilled), typeof w == "function" && (this.onRejected = w, this.callRejected = this.otherCallRejected);
                    }
                    function i(a, l, w) {
                        o(function() {
                            var O;
                            try {
                                O = l(w);
                            } catch (x) {
                                return t.reject(a, x);
                            }
                            O === a ? t.reject(a, new TypeError("Cannot resolve promise with itself")) : t.resolve(a, O);
                        });
                    }
                    function d(a) {
                        var l = a && a.then;
                        if (a && (typeof a == "object" || typeof a == "function") && typeof l == "function") return function() {
                            l.apply(a, arguments);
                        };
                    }
                    function p(a, l) {
                        var w = !1;
                        function O(T) {
                            w || (w = !0, t.reject(a, T));
                        }
                        function x(T) {
                            w || (w = !0, t.resolve(a, T));
                        }
                        var U = n(function() {
                            l(x, O);
                        });
                        U.status === "error" && O(U.value);
                    }
                    function n(a, l) {
                        var w = {};
                        try {
                            w.value = a(l), w.status = "success";
                        } catch (O) {
                            w.status = "error", w.value = O;
                        }
                        return w;
                    }
                    (R.exports = _).prototype.finally = function(a) {
                        if (typeof a != "function") return this;
                        var l = this.constructor;
                        return this.then(function(w) {
                            return l.resolve(a()).then(function() {
                                return w;
                            });
                        }, function(w) {
                            return l.resolve(a()).then(function() {
                                throw w;
                            });
                        });
                    }, _.prototype.catch = function(a) {
                        return this.then(null, a);
                    }, _.prototype.then = function(a, l) {
                        if (typeof a != "function" && this.state === b || typeof l != "function" && this.state === u) return this;
                        var w = new this.constructor(f);
                        return this.state !== v ? i(w, this.state === b ? a : l, this.outcome) : this.queue.push(new g(w, a, l)), w;
                    }, g.prototype.callFulfilled = function(a) {
                        t.resolve(this.promise, a);
                    }, g.prototype.otherCallFulfilled = function(a) {
                        i(this.promise, this.onFulfilled, a);
                    }, g.prototype.callRejected = function(a) {
                        t.reject(this.promise, a);
                    }, g.prototype.otherCallRejected = function(a) {
                        i(this.promise, this.onRejected, a);
                    }, t.resolve = function(a, l) {
                        var w = n(d, l);
                        if (w.status === "error") return t.reject(a, w.value);
                        var O = w.value;
                        if (O) p(a, O);
                        else {
                            a.state = b, a.outcome = l;
                            for(var x = -1, U = a.queue.length; ++x < U;)a.queue[x].callFulfilled(l);
                        }
                        return a;
                    }, t.reject = function(a, l) {
                        a.state = u, a.outcome = l;
                        for(var w = -1, O = a.queue.length; ++w < O;)a.queue[w].callRejected(l);
                        return a;
                    }, _.resolve = function(a) {
                        return a instanceof this ? a : t.resolve(new this(f), a);
                    }, _.reject = function(a) {
                        var l = new this(f);
                        return t.reject(l, a);
                    }, _.all = function(a) {
                        var l = this;
                        if (Object.prototype.toString.call(a) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                        var w = a.length, O = !1;
                        if (!w) return this.resolve([]);
                        for(var x = new Array(w), U = 0, T = -1, M = new this(f); ++T < w;)A(a[T], T);
                        return M;
                        function A(W, V) {
                            l.resolve(W).then(function(m) {
                                x[V] = m, ++U !== w || O || (O = !0, t.resolve(M, x));
                            }, function(m) {
                                O || (O = !0, t.reject(M, m));
                            });
                        }
                    }, _.race = function(a) {
                        var l = this;
                        if (Object.prototype.toString.call(a) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                        var w = a.length, O = !1;
                        if (!w) return this.resolve([]);
                        for(var x = -1, U = new this(f); ++x < w;)T = a[x], l.resolve(T).then(function(M) {
                            O || (O = !0, t.resolve(U, M));
                        }, function(M) {
                            O || (O = !0, t.reject(U, M));
                        });
                        var T;
                        return U;
                    };
                },
                {
                    immediate: 36
                }
            ],
            38: [
                function(c, R, y) {
                    "use strict";
                    var o = {};
                    (0, c("./lib/utils/common").assign)(o, c("./lib/deflate"), c("./lib/inflate"), c("./lib/zlib/constants")), R.exports = o;
                },
                {
                    "./lib/deflate": 39,
                    "./lib/inflate": 40,
                    "./lib/utils/common": 41,
                    "./lib/zlib/constants": 44
                }
            ],
            39: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./zlib/deflate"), f = c("./utils/common"), t = c("./utils/strings"), u = c("./zlib/messages"), b = c("./zlib/zstream"), v = Object.prototype.toString, _ = 0, g = -1, i = 0, d = 8;
                    function p(a) {
                        if (!(this instanceof p)) return new p(a);
                        this.options = f.assign({
                            level: g,
                            method: d,
                            chunkSize: 16384,
                            windowBits: 15,
                            memLevel: 8,
                            strategy: i,
                            to: ""
                        }, a || {});
                        var l = this.options;
                        l.raw && 0 < l.windowBits ? l.windowBits = -l.windowBits : l.gzip && 0 < l.windowBits && l.windowBits < 16 && (l.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new b, this.strm.avail_out = 0;
                        var w = o.deflateInit2(this.strm, l.level, l.method, l.windowBits, l.memLevel, l.strategy);
                        if (w !== _) throw new Error(u[w]);
                        if (l.header && o.deflateSetHeader(this.strm, l.header), l.dictionary) {
                            var O;
                            if (O = typeof l.dictionary == "string" ? t.string2buf(l.dictionary) : v.call(l.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(l.dictionary) : l.dictionary, (w = o.deflateSetDictionary(this.strm, O)) !== _) throw new Error(u[w]);
                            this._dict_set = !0;
                        }
                    }
                    function n(a, l) {
                        var w = new p(l);
                        if (w.push(a, !0), w.err) throw w.msg || u[w.err];
                        return w.result;
                    }
                    p.prototype.push = function(a, l) {
                        var w, O, x = this.strm, U = this.options.chunkSize;
                        if (this.ended) return !1;
                        O = l === ~~l ? l : l === !0 ? 4 : 0, typeof a == "string" ? x.input = t.string2buf(a) : v.call(a) === "[object ArrayBuffer]" ? x.input = new Uint8Array(a) : x.input = a, x.next_in = 0, x.avail_in = x.input.length;
                        do {
                            if (x.avail_out === 0 && (x.output = new f.Buf8(U), x.next_out = 0, x.avail_out = U), (w = o.deflate(x, O)) !== 1 && w !== _) return this.onEnd(w), !(this.ended = !0);
                            x.avail_out !== 0 && (x.avail_in !== 0 || O !== 4 && O !== 2) || (this.options.to === "string" ? this.onData(t.buf2binstring(f.shrinkBuf(x.output, x.next_out))) : this.onData(f.shrinkBuf(x.output, x.next_out)));
                        }while ((0 < x.avail_in || x.avail_out === 0) && w !== 1)
                        return O === 4 ? (w = o.deflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === _) : O !== 2 || (this.onEnd(_), !(x.avail_out = 0));
                    }, p.prototype.onData = function(a) {
                        this.chunks.push(a);
                    }, p.prototype.onEnd = function(a) {
                        a === _ && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg;
                    }, y.Deflate = p, y.deflate = n, y.deflateRaw = function(a, l) {
                        return (l = l || {}).raw = !0, n(a, l);
                    }, y.gzip = function(a, l) {
                        return (l = l || {}).gzip = !0, n(a, l);
                    };
                },
                {
                    "./utils/common": 41,
                    "./utils/strings": 42,
                    "./zlib/deflate": 46,
                    "./zlib/messages": 51,
                    "./zlib/zstream": 53
                }
            ],
            40: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./zlib/inflate"), f = c("./utils/common"), t = c("./utils/strings"), u = c("./zlib/constants"), b = c("./zlib/messages"), v = c("./zlib/zstream"), _ = c("./zlib/gzheader"), g = Object.prototype.toString;
                    function i(p) {
                        if (!(this instanceof i)) return new i(p);
                        this.options = f.assign({
                            chunkSize: 16384,
                            windowBits: 0,
                            to: ""
                        }, p || {});
                        var n = this.options;
                        n.raw && 0 <= n.windowBits && n.windowBits < 16 && (n.windowBits = -n.windowBits, n.windowBits === 0 && (n.windowBits = -15)), !(0 <= n.windowBits && n.windowBits < 16) || p && p.windowBits || (n.windowBits += 32), 15 < n.windowBits && n.windowBits < 48 && (15 & n.windowBits) == 0 && (n.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new v, this.strm.avail_out = 0;
                        var a = o.inflateInit2(this.strm, n.windowBits);
                        if (a !== u.Z_OK) throw new Error(b[a]);
                        this.header = new _, o.inflateGetHeader(this.strm, this.header);
                    }
                    function d(p, n) {
                        var a = new i(n);
                        if (a.push(p, !0), a.err) throw a.msg || b[a.err];
                        return a.result;
                    }
                    i.prototype.push = function(p, n) {
                        var a, l, w, O, x, U, T = this.strm, M = this.options.chunkSize, A = this.options.dictionary, W = !1;
                        if (this.ended) return !1;
                        l = n === ~~n ? n : n === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof p == "string" ? T.input = t.binstring2buf(p) : g.call(p) === "[object ArrayBuffer]" ? T.input = new Uint8Array(p) : T.input = p, T.next_in = 0, T.avail_in = T.input.length;
                        do {
                            if (T.avail_out === 0 && (T.output = new f.Buf8(M), T.next_out = 0, T.avail_out = M), (a = o.inflate(T, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && A && (U = typeof A == "string" ? t.string2buf(A) : g.call(A) === "[object ArrayBuffer]" ? new Uint8Array(A) : A, a = o.inflateSetDictionary(this.strm, U)), a === u.Z_BUF_ERROR && W === !0 && (a = u.Z_OK, W = !1), a !== u.Z_STREAM_END && a !== u.Z_OK) return this.onEnd(a), !(this.ended = !0);
                            T.next_out && (T.avail_out !== 0 && a !== u.Z_STREAM_END && (T.avail_in !== 0 || l !== u.Z_FINISH && l !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = t.utf8border(T.output, T.next_out), O = T.next_out - w, x = t.buf2string(T.output, w), T.next_out = O, T.avail_out = M - O, O && f.arraySet(T.output, T.output, w, O, 0), this.onData(x)) : this.onData(f.shrinkBuf(T.output, T.next_out)))), T.avail_in === 0 && T.avail_out === 0 && (W = !0);
                        }while ((0 < T.avail_in || T.avail_out === 0) && a !== u.Z_STREAM_END)
                        return a === u.Z_STREAM_END && (l = u.Z_FINISH), l === u.Z_FINISH ? (a = o.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === u.Z_OK) : l !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(T.avail_out = 0));
                    }, i.prototype.onData = function(p) {
                        this.chunks.push(p);
                    }, i.prototype.onEnd = function(p) {
                        p === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
                    }, y.Inflate = i, y.inflate = d, y.inflateRaw = function(p, n) {
                        return (n = n || {}).raw = !0, d(p, n);
                    }, y.ungzip = d;
                },
                {
                    "./utils/common": 41,
                    "./utils/strings": 42,
                    "./zlib/constants": 44,
                    "./zlib/gzheader": 47,
                    "./zlib/inflate": 49,
                    "./zlib/messages": 51,
                    "./zlib/zstream": 53
                }
            ],
            41: [
                function(c, R, y) {
                    "use strict";
                    var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
                    y.assign = function(u) {
                        for(var b = Array.prototype.slice.call(arguments, 1); b.length;){
                            var v = b.shift();
                            if (v) {
                                if (typeof v != "object") throw new TypeError(v + "must be non-object");
                                for(var _ in v)v.hasOwnProperty(_) && (u[_] = v[_]);
                            }
                        }
                        return u;
                    }, y.shrinkBuf = function(u, b) {
                        return u.length === b ? u : u.subarray ? u.subarray(0, b) : (u.length = b, u);
                    };
                    var f = {
                        arraySet: function(u, b, v, _, g) {
                            if (b.subarray && u.subarray) u.set(b.subarray(v, v + _), g);
                            else for(var i = 0; i < _; i++)u[g + i] = b[v + i];
                        },
                        flattenChunks: function(u) {
                            var b, v, _, g, i, d;
                            for(b = _ = 0, v = u.length; b < v; b++)_ += u[b].length;
                            for(d = new Uint8Array(_), b = g = 0, v = u.length; b < v; b++)i = u[b], d.set(i, g), g += i.length;
                            return d;
                        }
                    }, t = {
                        arraySet: function(u, b, v, _, g) {
                            for(var i = 0; i < _; i++)u[g + i] = b[v + i];
                        },
                        flattenChunks: function(u) {
                            return [].concat.apply([], u);
                        }
                    };
                    y.setTyped = function(u) {
                        u ? (y.Buf8 = Uint8Array, y.Buf16 = Uint16Array, y.Buf32 = Int32Array, y.assign(y, f)) : (y.Buf8 = Array, y.Buf16 = Array, y.Buf32 = Array, y.assign(y, t));
                    }, y.setTyped(o);
                },
                {}
            ],
            42: [
                function(c, R, y) {
                    "use strict";
                    var o = c("./common"), f = !0, t = !0;
                    try {
                        String.fromCharCode.apply(null, [
                            0
                        ]);
                    } catch  {
                        f = !1;
                    }
                    try {
                        String.fromCharCode.apply(null, new Uint8Array(1));
                    } catch  {
                        t = !1;
                    }
                    for(var u = new o.Buf8(256), b = 0; b < 256; b++)u[b] = 252 <= b ? 6 : 248 <= b ? 5 : 240 <= b ? 4 : 224 <= b ? 3 : 192 <= b ? 2 : 1;
                    function v(_, g) {
                        if (g < 65537 && (_.subarray && t || !_.subarray && f)) return String.fromCharCode.apply(null, o.shrinkBuf(_, g));
                        for(var i = "", d = 0; d < g; d++)i += String.fromCharCode(_[d]);
                        return i;
                    }
                    u[254] = u[254] = 1, y.string2buf = function(_) {
                        var g, i, d, p, n, a = _.length, l = 0;
                        for(p = 0; p < a; p++)(64512 & (i = _.charCodeAt(p))) == 55296 && p + 1 < a && (64512 & (d = _.charCodeAt(p + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (d - 56320), p++), l += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
                        for(g = new o.Buf8(l), p = n = 0; n < l; p++)(64512 & (i = _.charCodeAt(p))) == 55296 && p + 1 < a && (64512 & (d = _.charCodeAt(p + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (d - 56320), p++), i < 128 ? g[n++] = i : (i < 2048 ? g[n++] = 192 | i >>> 6 : (i < 65536 ? g[n++] = 224 | i >>> 12 : (g[n++] = 240 | i >>> 18, g[n++] = 128 | i >>> 12 & 63), g[n++] = 128 | i >>> 6 & 63), g[n++] = 128 | 63 & i);
                        return g;
                    }, y.buf2binstring = function(_) {
                        return v(_, _.length);
                    }, y.binstring2buf = function(_) {
                        for(var g = new o.Buf8(_.length), i = 0, d = g.length; i < d; i++)g[i] = _.charCodeAt(i);
                        return g;
                    }, y.buf2string = function(_, g) {
                        var i, d, p, n, a = g || _.length, l = new Array(2 * a);
                        for(i = d = 0; i < a;)if ((p = _[i++]) < 128) l[d++] = p;
                        else if (4 < (n = u[p])) l[d++] = 65533, i += n - 1;
                        else {
                            for(p &= n === 2 ? 31 : n === 3 ? 15 : 7; 1 < n && i < a;)p = p << 6 | 63 & _[i++], n--;
                            1 < n ? l[d++] = 65533 : p < 65536 ? l[d++] = p : (p -= 65536, l[d++] = 55296 | p >> 10 & 1023, l[d++] = 56320 | 1023 & p);
                        }
                        return v(l, d);
                    }, y.utf8border = function(_, g) {
                        var i;
                        for((g = g || _.length) > _.length && (g = _.length), i = g - 1; 0 <= i && (192 & _[i]) == 128;)i--;
                        return i < 0 || i === 0 ? g : i + u[_[i]] > g ? i : g;
                    };
                },
                {
                    "./common": 41
                }
            ],
            43: [
                function(c, R, y) {
                    "use strict";
                    R.exports = function(o, f, t, u) {
                        for(var b = 65535 & o | 0, v = o >>> 16 & 65535 | 0, _ = 0; t !== 0;){
                            for(t -= _ = 2e3 < t ? 2e3 : t; v = v + (b = b + f[u++] | 0) | 0, --_;);
                            b %= 65521, v %= 65521;
                        }
                        return b | v << 16 | 0;
                    };
                },
                {}
            ],
            44: [
                function(c, R, y) {
                    "use strict";
                    R.exports = {
                        Z_NO_FLUSH: 0,
                        Z_PARTIAL_FLUSH: 1,
                        Z_SYNC_FLUSH: 2,
                        Z_FULL_FLUSH: 3,
                        Z_FINISH: 4,
                        Z_BLOCK: 5,
                        Z_TREES: 6,
                        Z_OK: 0,
                        Z_STREAM_END: 1,
                        Z_NEED_DICT: 2,
                        Z_ERRNO: -1,
                        Z_STREAM_ERROR: -2,
                        Z_DATA_ERROR: -3,
                        Z_BUF_ERROR: -5,
                        Z_NO_COMPRESSION: 0,
                        Z_BEST_SPEED: 1,
                        Z_BEST_COMPRESSION: 9,
                        Z_DEFAULT_COMPRESSION: -1,
                        Z_FILTERED: 1,
                        Z_HUFFMAN_ONLY: 2,
                        Z_RLE: 3,
                        Z_FIXED: 4,
                        Z_DEFAULT_STRATEGY: 0,
                        Z_BINARY: 0,
                        Z_TEXT: 1,
                        Z_UNKNOWN: 2,
                        Z_DEFLATED: 8
                    };
                },
                {}
            ],
            45: [
                function(c, R, y) {
                    "use strict";
                    var o = function() {
                        for(var f, t = [], u = 0; u < 256; u++){
                            f = u;
                            for(var b = 0; b < 8; b++)f = 1 & f ? 3988292384 ^ f >>> 1 : f >>> 1;
                            t[u] = f;
                        }
                        return t;
                    }();
                    R.exports = function(f, t, u, b) {
                        var v = o, _ = b + u;
                        f ^= -1;
                        for(var g = b; g < _; g++)f = f >>> 8 ^ v[255 & (f ^ t[g])];
                        return -1 ^ f;
                    };
                },
                {}
            ],
            46: [
                function(c, R, y) {
                    "use strict";
                    var o, f = c("../utils/common"), t = c("./trees"), u = c("./adler32"), b = c("./crc32"), v = c("./messages"), _ = 0, g = 4, i = 0, d = -2, p = -1, n = 4, a = 2, l = 8, w = 9, O = 286, x = 30, U = 19, T = 2 * O + 1, M = 15, A = 3, W = 258, V = W + A + 1, m = 42, I = 113, r = 1, D = 2, J = 3, P = 4;
                    function Q(e, B) {
                        return e.msg = v[B], B;
                    }
                    function L(e) {
                        return (e << 1) - (4 < e ? 9 : 0);
                    }
                    function q(e) {
                        for(var B = e.length; 0 <= --B;)e[B] = 0;
                    }
                    function C(e) {
                        var B = e.state, E = B.pending;
                        E > e.avail_out && (E = e.avail_out), E !== 0 && (f.arraySet(e.output, B.pending_buf, B.pending_out, E, e.next_out), e.next_out += E, B.pending_out += E, e.total_out += E, e.avail_out -= E, B.pending -= E, B.pending === 0 && (B.pending_out = 0));
                    }
                    function z(e, B) {
                        t._tr_flush_block(e, 0 <= e.block_start ? e.block_start : -1, e.strstart - e.block_start, B), e.block_start = e.strstart, C(e.strm);
                    }
                    function X(e, B) {
                        e.pending_buf[e.pending++] = B;
                    }
                    function G(e, B) {
                        e.pending_buf[e.pending++] = B >>> 8 & 255, e.pending_buf[e.pending++] = 255 & B;
                    }
                    function H(e, B) {
                        var E, h, s = e.max_chain_length, k = e.strstart, F = e.prev_length, N = e.nice_match, S = e.strstart > e.w_size - V ? e.strstart - (e.w_size - V) : 0, j = e.window, K = e.w_mask, Z = e.prev, Y = e.strstart + W, te = j[k + F - 1], ee = j[k + F];
                        e.prev_length >= e.good_match && (s >>= 2), N > e.lookahead && (N = e.lookahead);
                        do if (j[(E = B) + F] === ee && j[E + F - 1] === te && j[E] === j[k] && j[++E] === j[k + 1]) {
                            k += 2, E++;
                            do ;
                            while (j[++k] === j[++E] && j[++k] === j[++E] && j[++k] === j[++E] && j[++k] === j[++E] && j[++k] === j[++E] && j[++k] === j[++E] && j[++k] === j[++E] && j[++k] === j[++E] && k < Y)
                            if (h = W - (Y - k), k = Y - W, F < h) {
                                if (e.match_start = B, N <= (F = h)) break;
                                te = j[k + F - 1], ee = j[k + F];
                            }
                        }
                        while ((B = Z[B & K]) > S && --s != 0)
                        return F <= e.lookahead ? F : e.lookahead;
                    }
                    function ne(e) {
                        var B, E, h, s, k, F, N, S, j, K, Z = e.w_size;
                        do {
                            if (s = e.window_size - e.lookahead - e.strstart, e.strstart >= Z + (Z - V)) {
                                for(f.arraySet(e.window, e.window, Z, Z, 0), e.match_start -= Z, e.strstart -= Z, e.block_start -= Z, B = E = e.hash_size; h = e.head[--B], e.head[B] = Z <= h ? h - Z : 0, --E;);
                                for(B = E = Z; h = e.prev[--B], e.prev[B] = Z <= h ? h - Z : 0, --E;);
                                s += Z;
                            }
                            if (e.strm.avail_in === 0) break;
                            if (F = e.strm, N = e.window, S = e.strstart + e.lookahead, j = s, K = void 0, K = F.avail_in, j < K && (K = j), E = K === 0 ? 0 : (F.avail_in -= K, f.arraySet(N, F.input, F.next_in, K, S), F.state.wrap === 1 ? F.adler = u(F.adler, N, K, S) : F.state.wrap === 2 && (F.adler = b(F.adler, N, K, S)), F.next_in += K, F.total_in += K, K), e.lookahead += E, e.lookahead + e.insert >= A) for(k = e.strstart - e.insert, e.ins_h = e.window[k], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[k + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[k + A - 1]) & e.hash_mask, e.prev[k & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = k, k++, e.insert--, !(e.lookahead + e.insert < A)););
                        }while (e.lookahead < V && e.strm.avail_in !== 0)
                    }
                    function oe(e, B) {
                        for(var E, h;;){
                            if (e.lookahead < V) {
                                if (ne(e), e.lookahead < V && B === _) return r;
                                if (e.lookahead === 0) break;
                            }
                            if (E = 0, e.lookahead >= A && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + A - 1]) & e.hash_mask, E = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), E !== 0 && e.strstart - E <= e.w_size - V && (e.match_length = H(e, E)), e.match_length >= A) if (h = t._tr_tally(e, e.strstart - e.match_start, e.match_length - A), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= A) {
                                for(e.match_length--; e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + A - 1]) & e.hash_mask, E = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, --e.match_length != 0;);
                                e.strstart++;
                            } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
                            else h = t._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
                            if (h && (z(e, !1), e.strm.avail_out === 0)) return r;
                        }
                        return e.insert = e.strstart < A - 1 ? e.strstart : A - 1, B === g ? (z(e, !0), e.strm.avail_out === 0 ? J : P) : e.last_lit && (z(e, !1), e.strm.avail_out === 0) ? r : D;
                    }
                    function $(e, B) {
                        for(var E, h, s;;){
                            if (e.lookahead < V) {
                                if (ne(e), e.lookahead < V && B === _) return r;
                                if (e.lookahead === 0) break;
                            }
                            if (E = 0, e.lookahead >= A && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + A - 1]) & e.hash_mask, E = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = A - 1, E !== 0 && e.prev_length < e.max_lazy_match && e.strstart - E <= e.w_size - V && (e.match_length = H(e, E), e.match_length <= 5 && (e.strategy === 1 || e.match_length === A && 4096 < e.strstart - e.match_start) && (e.match_length = A - 1)), e.prev_length >= A && e.match_length <= e.prev_length) {
                                for(s = e.strstart + e.lookahead - A, h = t._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - A), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= s && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + A - 1]) & e.hash_mask, E = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), --e.prev_length != 0;);
                                if (e.match_available = 0, e.match_length = A - 1, e.strstart++, h && (z(e, !1), e.strm.avail_out === 0)) return r;
                            } else if (e.match_available) {
                                if ((h = t._tr_tally(e, 0, e.window[e.strstart - 1])) && z(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0) return r;
                            } else e.match_available = 1, e.strstart++, e.lookahead--;
                        }
                        return e.match_available && (h = t._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < A - 1 ? e.strstart : A - 1, B === g ? (z(e, !0), e.strm.avail_out === 0 ? J : P) : e.last_lit && (z(e, !1), e.strm.avail_out === 0) ? r : D;
                    }
                    function re(e, B, E, h, s) {
                        this.good_length = e, this.max_lazy = B, this.nice_length = E, this.max_chain = h, this.func = s;
                    }
                    function ae() {
                        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = l, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new f.Buf16(2 * T), this.dyn_dtree = new f.Buf16(2 * (2 * x + 1)), this.bl_tree = new f.Buf16(2 * (2 * U + 1)), q(this.dyn_ltree), q(this.dyn_dtree), q(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new f.Buf16(M + 1), this.heap = new f.Buf16(2 * O + 1), q(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new f.Buf16(2 * O + 1), q(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                    }
                    function ie(e) {
                        var B;
                        return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = a, (B = e.state).pending = 0, B.pending_out = 0, B.wrap < 0 && (B.wrap = -B.wrap), B.status = B.wrap ? m : I, e.adler = B.wrap === 2 ? 0 : 1, B.last_flush = _, t._tr_init(B), i) : Q(e, d);
                    }
                    function le(e) {
                        var B = ie(e);
                        return B === i && function(E) {
                            E.window_size = 2 * E.w_size, q(E.head), E.max_lazy_match = o[E.level].max_lazy, E.good_match = o[E.level].good_length, E.nice_match = o[E.level].nice_length, E.max_chain_length = o[E.level].max_chain, E.strstart = 0, E.block_start = 0, E.lookahead = 0, E.insert = 0, E.match_length = E.prev_length = A - 1, E.match_available = 0, E.ins_h = 0;
                        }(e.state), B;
                    }
                    function ue(e, B, E, h, s, k) {
                        if (!e) return d;
                        var F = 1;
                        if (B === p && (B = 6), h < 0 ? (F = 0, h = -h) : 15 < h && (F = 2, h -= 16), s < 1 || w < s || E !== l || h < 8 || 15 < h || B < 0 || 9 < B || k < 0 || n < k) return Q(e, d);
                        h === 8 && (h = 9);
                        var N = new ae;
                        return (e.state = N).strm = e, N.wrap = F, N.gzhead = null, N.w_bits = h, N.w_size = 1 << N.w_bits, N.w_mask = N.w_size - 1, N.hash_bits = s + 7, N.hash_size = 1 << N.hash_bits, N.hash_mask = N.hash_size - 1, N.hash_shift = ~~((N.hash_bits + A - 1) / A), N.window = new f.Buf8(2 * N.w_size), N.head = new f.Buf16(N.hash_size), N.prev = new f.Buf16(N.w_size), N.lit_bufsize = 1 << s + 6, N.pending_buf_size = 4 * N.lit_bufsize, N.pending_buf = new f.Buf8(N.pending_buf_size), N.d_buf = 1 * N.lit_bufsize, N.l_buf = 3 * N.lit_bufsize, N.level = B, N.strategy = k, N.method = E, le(e);
                    }
                    o = [
                        new re(0, 0, 0, 0, function(e, B) {
                            var E = 65535;
                            for(E > e.pending_buf_size - 5 && (E = e.pending_buf_size - 5);;){
                                if (e.lookahead <= 1) {
                                    if (ne(e), e.lookahead === 0 && B === _) return r;
                                    if (e.lookahead === 0) break;
                                }
                                e.strstart += e.lookahead, e.lookahead = 0;
                                var h = e.block_start + E;
                                if ((e.strstart === 0 || e.strstart >= h) && (e.lookahead = e.strstart - h, e.strstart = h, z(e, !1), e.strm.avail_out === 0) || e.strstart - e.block_start >= e.w_size - V && (z(e, !1), e.strm.avail_out === 0)) return r;
                            }
                            return e.insert = 0, B === g ? (z(e, !0), e.strm.avail_out === 0 ? J : P) : (e.strstart > e.block_start && (z(e, !1), e.strm.avail_out), r);
                        }),
                        new re(4, 4, 8, 4, oe),
                        new re(4, 5, 16, 8, oe),
                        new re(4, 6, 32, 32, oe),
                        new re(4, 4, 16, 16, $),
                        new re(8, 16, 32, 32, $),
                        new re(8, 16, 128, 128, $),
                        new re(8, 32, 128, 256, $),
                        new re(32, 128, 258, 1024, $),
                        new re(32, 258, 258, 4096, $)
                    ], y.deflateInit = function(e, B) {
                        return ue(e, B, l, 15, 8, 0);
                    }, y.deflateInit2 = ue, y.deflateReset = le, y.deflateResetKeep = ie, y.deflateSetHeader = function(e, B) {
                        return e && e.state ? e.state.wrap !== 2 ? d : (e.state.gzhead = B, i) : d;
                    }, y.deflate = function(e, B) {
                        var E, h, s, k;
                        if (!e || !e.state || 5 < B || B < 0) return e ? Q(e, d) : d;
                        if (h = e.state, !e.output || !e.input && e.avail_in !== 0 || h.status === 666 && B !== g) return Q(e, e.avail_out === 0 ? -5 : d);
                        if (h.strm = e, E = h.last_flush, h.last_flush = B, h.status === m) if (h.wrap === 2) e.adler = 0, X(h, 31), X(h, 139), X(h, 8), h.gzhead ? (X(h, (h.gzhead.text ? 1 : 0) + (h.gzhead.hcrc ? 2 : 0) + (h.gzhead.extra ? 4 : 0) + (h.gzhead.name ? 8 : 0) + (h.gzhead.comment ? 16 : 0)), X(h, 255 & h.gzhead.time), X(h, h.gzhead.time >> 8 & 255), X(h, h.gzhead.time >> 16 & 255), X(h, h.gzhead.time >> 24 & 255), X(h, h.level === 9 ? 2 : 2 <= h.strategy || h.level < 2 ? 4 : 0), X(h, 255 & h.gzhead.os), h.gzhead.extra && h.gzhead.extra.length && (X(h, 255 & h.gzhead.extra.length), X(h, h.gzhead.extra.length >> 8 & 255)), h.gzhead.hcrc && (e.adler = b(e.adler, h.pending_buf, h.pending, 0)), h.gzindex = 0, h.status = 69) : (X(h, 0), X(h, 0), X(h, 0), X(h, 0), X(h, 0), X(h, h.level === 9 ? 2 : 2 <= h.strategy || h.level < 2 ? 4 : 0), X(h, 3), h.status = I);
                        else {
                            var F = l + (h.w_bits - 8 << 4) << 8;
                            F |= (2 <= h.strategy || h.level < 2 ? 0 : h.level < 6 ? 1 : h.level === 6 ? 2 : 3) << 6, h.strstart !== 0 && (F |= 32), F += 31 - F % 31, h.status = I, G(h, F), h.strstart !== 0 && (G(h, e.adler >>> 16), G(h, 65535 & e.adler)), e.adler = 1;
                        }
                        if (h.status === 69) if (h.gzhead.extra) {
                            for(s = h.pending; h.gzindex < (65535 & h.gzhead.extra.length) && (h.pending !== h.pending_buf_size || (h.gzhead.hcrc && h.pending > s && (e.adler = b(e.adler, h.pending_buf, h.pending - s, s)), C(e), s = h.pending, h.pending !== h.pending_buf_size));)X(h, 255 & h.gzhead.extra[h.gzindex]), h.gzindex++;
                            h.gzhead.hcrc && h.pending > s && (e.adler = b(e.adler, h.pending_buf, h.pending - s, s)), h.gzindex === h.gzhead.extra.length && (h.gzindex = 0, h.status = 73);
                        } else h.status = 73;
                        if (h.status === 73) if (h.gzhead.name) {
                            s = h.pending;
                            do {
                                if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > s && (e.adler = b(e.adler, h.pending_buf, h.pending - s, s)), C(e), s = h.pending, h.pending === h.pending_buf_size)) {
                                    k = 1;
                                    break;
                                }
                                k = h.gzindex < h.gzhead.name.length ? 255 & h.gzhead.name.charCodeAt(h.gzindex++) : 0, X(h, k);
                            }while (k !== 0)
                            h.gzhead.hcrc && h.pending > s && (e.adler = b(e.adler, h.pending_buf, h.pending - s, s)), k === 0 && (h.gzindex = 0, h.status = 91);
                        } else h.status = 91;
                        if (h.status === 91) if (h.gzhead.comment) {
                            s = h.pending;
                            do {
                                if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending > s && (e.adler = b(e.adler, h.pending_buf, h.pending - s, s)), C(e), s = h.pending, h.pending === h.pending_buf_size)) {
                                    k = 1;
                                    break;
                                }
                                k = h.gzindex < h.gzhead.comment.length ? 255 & h.gzhead.comment.charCodeAt(h.gzindex++) : 0, X(h, k);
                            }while (k !== 0)
                            h.gzhead.hcrc && h.pending > s && (e.adler = b(e.adler, h.pending_buf, h.pending - s, s)), k === 0 && (h.status = 103);
                        } else h.status = 103;
                        if (h.status === 103 && (h.gzhead.hcrc ? (h.pending + 2 > h.pending_buf_size && C(e), h.pending + 2 <= h.pending_buf_size && (X(h, 255 & e.adler), X(h, e.adler >> 8 & 255), e.adler = 0, h.status = I)) : h.status = I), h.pending !== 0) {
                            if (C(e), e.avail_out === 0) return h.last_flush = -1, i;
                        } else if (e.avail_in === 0 && L(B) <= L(E) && B !== g) return Q(e, -5);
                        if (h.status === 666 && e.avail_in !== 0) return Q(e, -5);
                        if (e.avail_in !== 0 || h.lookahead !== 0 || B !== _ && h.status !== 666) {
                            var N = h.strategy === 2 ? function(S, j) {
                                for(var K;;){
                                    if (S.lookahead === 0 && (ne(S), S.lookahead === 0)) {
                                        if (j === _) return r;
                                        break;
                                    }
                                    if (S.match_length = 0, K = t._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++, K && (z(S, !1), S.strm.avail_out === 0)) return r;
                                }
                                return S.insert = 0, j === g ? (z(S, !0), S.strm.avail_out === 0 ? J : P) : S.last_lit && (z(S, !1), S.strm.avail_out === 0) ? r : D;
                            }(h, B) : h.strategy === 3 ? function(S, j) {
                                for(var K, Z, Y, te, ee = S.window;;){
                                    if (S.lookahead <= W) {
                                        if (ne(S), S.lookahead <= W && j === _) return r;
                                        if (S.lookahead === 0) break;
                                    }
                                    if (S.match_length = 0, S.lookahead >= A && 0 < S.strstart && (Z = ee[Y = S.strstart - 1]) === ee[++Y] && Z === ee[++Y] && Z === ee[++Y]) {
                                        te = S.strstart + W;
                                        do ;
                                        while (Z === ee[++Y] && Z === ee[++Y] && Z === ee[++Y] && Z === ee[++Y] && Z === ee[++Y] && Z === ee[++Y] && Z === ee[++Y] && Z === ee[++Y] && Y < te)
                                        S.match_length = W - (te - Y), S.match_length > S.lookahead && (S.match_length = S.lookahead);
                                    }
                                    if (S.match_length >= A ? (K = t._tr_tally(S, 1, S.match_length - A), S.lookahead -= S.match_length, S.strstart += S.match_length, S.match_length = 0) : (K = t._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++), K && (z(S, !1), S.strm.avail_out === 0)) return r;
                                }
                                return S.insert = 0, j === g ? (z(S, !0), S.strm.avail_out === 0 ? J : P) : S.last_lit && (z(S, !1), S.strm.avail_out === 0) ? r : D;
                            }(h, B) : o[h.level].func(h, B);
                            if (N !== J && N !== P || (h.status = 666), N === r || N === J) return e.avail_out === 0 && (h.last_flush = -1), i;
                            if (N === D && (B === 1 ? t._tr_align(h) : B !== 5 && (t._tr_stored_block(h, 0, 0, !1), B === 3 && (q(h.head), h.lookahead === 0 && (h.strstart = 0, h.block_start = 0, h.insert = 0))), C(e), e.avail_out === 0)) return h.last_flush = -1, i;
                        }
                        return B !== g ? i : h.wrap <= 0 ? 1 : (h.wrap === 2 ? (X(h, 255 & e.adler), X(h, e.adler >> 8 & 255), X(h, e.adler >> 16 & 255), X(h, e.adler >> 24 & 255), X(h, 255 & e.total_in), X(h, e.total_in >> 8 & 255), X(h, e.total_in >> 16 & 255), X(h, e.total_in >> 24 & 255)) : (G(h, e.adler >>> 16), G(h, 65535 & e.adler)), C(e), 0 < h.wrap && (h.wrap = -h.wrap), h.pending !== 0 ? i : 1);
                    }, y.deflateEnd = function(e) {
                        var B;
                        return e && e.state ? (B = e.state.status) !== m && B !== 69 && B !== 73 && B !== 91 && B !== 103 && B !== I && B !== 666 ? Q(e, d) : (e.state = null, B === I ? Q(e, -3) : i) : d;
                    }, y.deflateSetDictionary = function(e, B) {
                        var E, h, s, k, F, N, S, j, K = B.length;
                        if (!e || !e.state || (k = (E = e.state).wrap) === 2 || k === 1 && E.status !== m || E.lookahead) return d;
                        for(k === 1 && (e.adler = u(e.adler, B, K, 0)), E.wrap = 0, K >= E.w_size && (k === 0 && (q(E.head), E.strstart = 0, E.block_start = 0, E.insert = 0), j = new f.Buf8(E.w_size), f.arraySet(j, B, K - E.w_size, E.w_size, 0), B = j, K = E.w_size), F = e.avail_in, N = e.next_in, S = e.input, e.avail_in = K, e.next_in = 0, e.input = B, ne(E); E.lookahead >= A;){
                            for(h = E.strstart, s = E.lookahead - (A - 1); E.ins_h = (E.ins_h << E.hash_shift ^ E.window[h + A - 1]) & E.hash_mask, E.prev[h & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = h, h++, --s;);
                            E.strstart = h, E.lookahead = A - 1, ne(E);
                        }
                        return E.strstart += E.lookahead, E.block_start = E.strstart, E.insert = E.lookahead, E.lookahead = 0, E.match_length = E.prev_length = A - 1, E.match_available = 0, e.next_in = N, e.input = S, e.avail_in = F, E.wrap = k, i;
                    }, y.deflateInfo = "pako deflate (from Nodeca project)";
                },
                {
                    "../utils/common": 41,
                    "./adler32": 43,
                    "./crc32": 45,
                    "./messages": 51,
                    "./trees": 52
                }
            ],
            47: [
                function(c, R, y) {
                    "use strict";
                    R.exports = function() {
                        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
                    };
                },
                {}
            ],
            48: [
                function(c, R, y) {
                    "use strict";
                    R.exports = function(o, f) {
                        var t, u, b, v, _, g, i, d, p, n, a, l, w, O, x, U, T, M, A, W, V, m, I, r, D;
                        t = o.state, u = o.next_in, r = o.input, b = u + (o.avail_in - 5), v = o.next_out, D = o.output, _ = v - (f - o.avail_out), g = v + (o.avail_out - 257), i = t.dmax, d = t.wsize, p = t.whave, n = t.wnext, a = t.window, l = t.hold, w = t.bits, O = t.lencode, x = t.distcode, U = (1 << t.lenbits) - 1, T = (1 << t.distbits) - 1;
                        e: do {
                            w < 15 && (l += r[u++] << w, w += 8, l += r[u++] << w, w += 8), M = O[l & U];
                            r: for(;;){
                                if (l >>>= A = M >>> 24, w -= A, (A = M >>> 16 & 255) === 0) D[v++] = 65535 & M;
                                else {
                                    if (!(16 & A)) {
                                        if ((64 & A) == 0) {
                                            M = O[(65535 & M) + (l & (1 << A) - 1)];
                                            continue r;
                                        }
                                        if (32 & A) {
                                            t.mode = 12;
                                            break e;
                                        }
                                        o.msg = "invalid literal/length code", t.mode = 30;
                                        break e;
                                    }
                                    W = 65535 & M, (A &= 15) && (w < A && (l += r[u++] << w, w += 8), W += l & (1 << A) - 1, l >>>= A, w -= A), w < 15 && (l += r[u++] << w, w += 8, l += r[u++] << w, w += 8), M = x[l & T];
                                    t: for(;;){
                                        if (l >>>= A = M >>> 24, w -= A, !(16 & (A = M >>> 16 & 255))) {
                                            if ((64 & A) == 0) {
                                                M = x[(65535 & M) + (l & (1 << A) - 1)];
                                                continue t;
                                            }
                                            o.msg = "invalid distance code", t.mode = 30;
                                            break e;
                                        }
                                        if (V = 65535 & M, w < (A &= 15) && (l += r[u++] << w, (w += 8) < A && (l += r[u++] << w, w += 8)), i < (V += l & (1 << A) - 1)) {
                                            o.msg = "invalid distance too far back", t.mode = 30;
                                            break e;
                                        }
                                        if (l >>>= A, w -= A, (A = v - _) < V) {
                                            if (p < (A = V - A) && t.sane) {
                                                o.msg = "invalid distance too far back", t.mode = 30;
                                                break e;
                                            }
                                            if (I = a, (m = 0) === n) {
                                                if (m += d - A, A < W) {
                                                    for(W -= A; D[v++] = a[m++], --A;);
                                                    m = v - V, I = D;
                                                }
                                            } else if (n < A) {
                                                if (m += d + n - A, (A -= n) < W) {
                                                    for(W -= A; D[v++] = a[m++], --A;);
                                                    if (m = 0, n < W) {
                                                        for(W -= A = n; D[v++] = a[m++], --A;);
                                                        m = v - V, I = D;
                                                    }
                                                }
                                            } else if (m += n - A, A < W) {
                                                for(W -= A; D[v++] = a[m++], --A;);
                                                m = v - V, I = D;
                                            }
                                            for(; 2 < W;)D[v++] = I[m++], D[v++] = I[m++], D[v++] = I[m++], W -= 3;
                                            W && (D[v++] = I[m++], 1 < W && (D[v++] = I[m++]));
                                        } else {
                                            for(m = v - V; D[v++] = D[m++], D[v++] = D[m++], D[v++] = D[m++], 2 < (W -= 3););
                                            W && (D[v++] = D[m++], 1 < W && (D[v++] = D[m++]));
                                        }
                                        break;
                                    }
                                }
                                break;
                            }
                        }while (u < b && v < g)
                        u -= W = w >> 3, l &= (1 << (w -= W << 3)) - 1, o.next_in = u, o.next_out = v, o.avail_in = u < b ? b - u + 5 : 5 - (u - b), o.avail_out = v < g ? g - v + 257 : 257 - (v - g), t.hold = l, t.bits = w;
                    };
                },
                {}
            ],
            49: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils/common"), f = c("./adler32"), t = c("./crc32"), u = c("./inffast"), b = c("./inftrees"), v = 1, _ = 2, g = 0, i = -2, d = 1, p = 852, n = 592;
                    function a(m) {
                        return (m >>> 24 & 255) + (m >>> 8 & 65280) + ((65280 & m) << 8) + ((255 & m) << 24);
                    }
                    function l() {
                        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                    }
                    function w(m) {
                        var I;
                        return m && m.state ? (I = m.state, m.total_in = m.total_out = I.total = 0, m.msg = "", I.wrap && (m.adler = 1 & I.wrap), I.mode = d, I.last = 0, I.havedict = 0, I.dmax = 32768, I.head = null, I.hold = 0, I.bits = 0, I.lencode = I.lendyn = new o.Buf32(p), I.distcode = I.distdyn = new o.Buf32(n), I.sane = 1, I.back = -1, g) : i;
                    }
                    function O(m) {
                        var I;
                        return m && m.state ? ((I = m.state).wsize = 0, I.whave = 0, I.wnext = 0, w(m)) : i;
                    }
                    function x(m, I) {
                        var r, D;
                        return m && m.state ? (D = m.state, I < 0 ? (r = 0, I = -I) : (r = 1 + (I >> 4), I < 48 && (I &= 15)), I && (I < 8 || 15 < I) ? i : (D.window !== null && D.wbits !== I && (D.window = null), D.wrap = r, D.wbits = I, O(m))) : i;
                    }
                    function U(m, I) {
                        var r, D;
                        return m ? (D = new l, (m.state = D).window = null, (r = x(m, I)) !== g && (m.state = null), r) : i;
                    }
                    var T, M, A = !0;
                    function W(m) {
                        if (A) {
                            var I;
                            for(T = new o.Buf32(512), M = new o.Buf32(32), I = 0; I < 144;)m.lens[I++] = 8;
                            for(; I < 256;)m.lens[I++] = 9;
                            for(; I < 280;)m.lens[I++] = 7;
                            for(; I < 288;)m.lens[I++] = 8;
                            for(b(v, m.lens, 0, 288, T, 0, m.work, {
                                bits: 9
                            }), I = 0; I < 32;)m.lens[I++] = 5;
                            b(_, m.lens, 0, 32, M, 0, m.work, {
                                bits: 5
                            }), A = !1;
                        }
                        m.lencode = T, m.lenbits = 9, m.distcode = M, m.distbits = 5;
                    }
                    function V(m, I, r, D) {
                        var J, P = m.state;
                        return P.window === null && (P.wsize = 1 << P.wbits, P.wnext = 0, P.whave = 0, P.window = new o.Buf8(P.wsize)), D >= P.wsize ? (o.arraySet(P.window, I, r - P.wsize, P.wsize, 0), P.wnext = 0, P.whave = P.wsize) : (D < (J = P.wsize - P.wnext) && (J = D), o.arraySet(P.window, I, r - D, J, P.wnext), (D -= J) ? (o.arraySet(P.window, I, r - D, D, 0), P.wnext = D, P.whave = P.wsize) : (P.wnext += J, P.wnext === P.wsize && (P.wnext = 0), P.whave < P.wsize && (P.whave += J))), 0;
                    }
                    y.inflateReset = O, y.inflateReset2 = x, y.inflateResetKeep = w, y.inflateInit = function(m) {
                        return U(m, 15);
                    }, y.inflateInit2 = U, y.inflate = function(m, I) {
                        var r, D, J, P, Q, L, q, C, z, X, G, H, ne, oe, $, re, ae, ie, le, ue, e, B, E, h, s = 0, k = new o.Buf8(4), F = [
                            16,
                            17,
                            18,
                            0,
                            8,
                            7,
                            9,
                            6,
                            10,
                            5,
                            11,
                            4,
                            12,
                            3,
                            13,
                            2,
                            14,
                            1,
                            15
                        ];
                        if (!m || !m.state || !m.output || !m.input && m.avail_in !== 0) return i;
                        (r = m.state).mode === 12 && (r.mode = 13), Q = m.next_out, J = m.output, q = m.avail_out, P = m.next_in, D = m.input, L = m.avail_in, C = r.hold, z = r.bits, X = L, G = q, B = g;
                        e: for(;;)switch(r.mode){
                            case d:
                                if (r.wrap === 0) {
                                    r.mode = 13;
                                    break;
                                }
                                for(; z < 16;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                if (2 & r.wrap && C === 35615) {
                                    k[r.check = 0] = 255 & C, k[1] = C >>> 8 & 255, r.check = t(r.check, k, 2, 0), z = C = 0, r.mode = 2;
                                    break;
                                }
                                if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & C) << 8) + (C >> 8)) % 31) {
                                    m.msg = "incorrect header check", r.mode = 30;
                                    break;
                                }
                                if ((15 & C) != 8) {
                                    m.msg = "unknown compression method", r.mode = 30;
                                    break;
                                }
                                if (z -= 4, e = 8 + (15 & (C >>>= 4)), r.wbits === 0) r.wbits = e;
                                else if (e > r.wbits) {
                                    m.msg = "invalid window size", r.mode = 30;
                                    break;
                                }
                                r.dmax = 1 << e, m.adler = r.check = 1, r.mode = 512 & C ? 10 : 12, z = C = 0;
                                break;
                            case 2:
                                for(; z < 16;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                if (r.flags = C, (255 & r.flags) != 8) {
                                    m.msg = "unknown compression method", r.mode = 30;
                                    break;
                                }
                                if (57344 & r.flags) {
                                    m.msg = "unknown header flags set", r.mode = 30;
                                    break;
                                }
                                r.head && (r.head.text = C >> 8 & 1), 512 & r.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, r.check = t(r.check, k, 2, 0)), z = C = 0, r.mode = 3;
                            case 3:
                                for(; z < 32;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                r.head && (r.head.time = C), 512 & r.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, k[2] = C >>> 16 & 255, k[3] = C >>> 24 & 255, r.check = t(r.check, k, 4, 0)), z = C = 0, r.mode = 4;
                            case 4:
                                for(; z < 16;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                r.head && (r.head.xflags = 255 & C, r.head.os = C >> 8), 512 & r.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, r.check = t(r.check, k, 2, 0)), z = C = 0, r.mode = 5;
                            case 5:
                                if (1024 & r.flags) {
                                    for(; z < 16;){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    r.length = C, r.head && (r.head.extra_len = C), 512 & r.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, r.check = t(r.check, k, 2, 0)), z = C = 0;
                                } else r.head && (r.head.extra = null);
                                r.mode = 6;
                            case 6:
                                if (1024 & r.flags && (L < (H = r.length) && (H = L), H && (r.head && (e = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), o.arraySet(r.head.extra, D, P, H, e)), 512 & r.flags && (r.check = t(r.check, D, H, P)), L -= H, P += H, r.length -= H), r.length)) break e;
                                r.length = 0, r.mode = 7;
                            case 7:
                                if (2048 & r.flags) {
                                    if (L === 0) break e;
                                    for(H = 0; e = D[P + H++], r.head && e && r.length < 65536 && (r.head.name += String.fromCharCode(e)), e && H < L;);
                                    if (512 & r.flags && (r.check = t(r.check, D, H, P)), L -= H, P += H, e) break e;
                                } else r.head && (r.head.name = null);
                                r.length = 0, r.mode = 8;
                            case 8:
                                if (4096 & r.flags) {
                                    if (L === 0) break e;
                                    for(H = 0; e = D[P + H++], r.head && e && r.length < 65536 && (r.head.comment += String.fromCharCode(e)), e && H < L;);
                                    if (512 & r.flags && (r.check = t(r.check, D, H, P)), L -= H, P += H, e) break e;
                                } else r.head && (r.head.comment = null);
                                r.mode = 9;
                            case 9:
                                if (512 & r.flags) {
                                    for(; z < 16;){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    if (C !== (65535 & r.check)) {
                                        m.msg = "header crc mismatch", r.mode = 30;
                                        break;
                                    }
                                    z = C = 0;
                                }
                                r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), m.adler = r.check = 0, r.mode = 12;
                                break;
                            case 10:
                                for(; z < 32;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                m.adler = r.check = a(C), z = C = 0, r.mode = 11;
                            case 11:
                                if (r.havedict === 0) return m.next_out = Q, m.avail_out = q, m.next_in = P, m.avail_in = L, r.hold = C, r.bits = z, 2;
                                m.adler = r.check = 1, r.mode = 12;
                            case 12:
                                if (I === 5 || I === 6) break e;
                            case 13:
                                if (r.last) {
                                    C >>>= 7 & z, z -= 7 & z, r.mode = 27;
                                    break;
                                }
                                for(; z < 3;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                switch(r.last = 1 & C, z -= 1, 3 & (C >>>= 1)){
                                    case 0:
                                        r.mode = 14;
                                        break;
                                    case 1:
                                        if (W(r), r.mode = 20, I !== 6) break;
                                        C >>>= 2, z -= 2;
                                        break e;
                                    case 2:
                                        r.mode = 17;
                                        break;
                                    case 3:
                                        m.msg = "invalid block type", r.mode = 30;
                                }
                                C >>>= 2, z -= 2;
                                break;
                            case 14:
                                for(C >>>= 7 & z, z -= 7 & z; z < 32;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                if ((65535 & C) != (C >>> 16 ^ 65535)) {
                                    m.msg = "invalid stored block lengths", r.mode = 30;
                                    break;
                                }
                                if (r.length = 65535 & C, z = C = 0, r.mode = 15, I === 6) break e;
                            case 15:
                                r.mode = 16;
                            case 16:
                                if (H = r.length) {
                                    if (L < H && (H = L), q < H && (H = q), H === 0) break e;
                                    o.arraySet(J, D, P, H, Q), L -= H, P += H, q -= H, Q += H, r.length -= H;
                                    break;
                                }
                                r.mode = 12;
                                break;
                            case 17:
                                for(; z < 14;){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                if (r.nlen = 257 + (31 & C), C >>>= 5, z -= 5, r.ndist = 1 + (31 & C), C >>>= 5, z -= 5, r.ncode = 4 + (15 & C), C >>>= 4, z -= 4, 286 < r.nlen || 30 < r.ndist) {
                                    m.msg = "too many length or distance symbols", r.mode = 30;
                                    break;
                                }
                                r.have = 0, r.mode = 18;
                            case 18:
                                for(; r.have < r.ncode;){
                                    for(; z < 3;){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    r.lens[F[r.have++]] = 7 & C, C >>>= 3, z -= 3;
                                }
                                for(; r.have < 19;)r.lens[F[r.have++]] = 0;
                                if (r.lencode = r.lendyn, r.lenbits = 7, E = {
                                    bits: r.lenbits
                                }, B = b(0, r.lens, 0, 19, r.lencode, 0, r.work, E), r.lenbits = E.bits, B) {
                                    m.msg = "invalid code lengths set", r.mode = 30;
                                    break;
                                }
                                r.have = 0, r.mode = 19;
                            case 19:
                                for(; r.have < r.nlen + r.ndist;){
                                    for(; re = (s = r.lencode[C & (1 << r.lenbits) - 1]) >>> 16 & 255, ae = 65535 & s, !(($ = s >>> 24) <= z);){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    if (ae < 16) C >>>= $, z -= $, r.lens[r.have++] = ae;
                                    else {
                                        if (ae === 16) {
                                            for(h = $ + 2; z < h;){
                                                if (L === 0) break e;
                                                L--, C += D[P++] << z, z += 8;
                                            }
                                            if (C >>>= $, z -= $, r.have === 0) {
                                                m.msg = "invalid bit length repeat", r.mode = 30;
                                                break;
                                            }
                                            e = r.lens[r.have - 1], H = 3 + (3 & C), C >>>= 2, z -= 2;
                                        } else if (ae === 17) {
                                            for(h = $ + 3; z < h;){
                                                if (L === 0) break e;
                                                L--, C += D[P++] << z, z += 8;
                                            }
                                            z -= $, e = 0, H = 3 + (7 & (C >>>= $)), C >>>= 3, z -= 3;
                                        } else {
                                            for(h = $ + 7; z < h;){
                                                if (L === 0) break e;
                                                L--, C += D[P++] << z, z += 8;
                                            }
                                            z -= $, e = 0, H = 11 + (127 & (C >>>= $)), C >>>= 7, z -= 7;
                                        }
                                        if (r.have + H > r.nlen + r.ndist) {
                                            m.msg = "invalid bit length repeat", r.mode = 30;
                                            break;
                                        }
                                        for(; H--;)r.lens[r.have++] = e;
                                    }
                                }
                                if (r.mode === 30) break;
                                if (r.lens[256] === 0) {
                                    m.msg = "invalid code -- missing end-of-block", r.mode = 30;
                                    break;
                                }
                                if (r.lenbits = 9, E = {
                                    bits: r.lenbits
                                }, B = b(v, r.lens, 0, r.nlen, r.lencode, 0, r.work, E), r.lenbits = E.bits, B) {
                                    m.msg = "invalid literal/lengths set", r.mode = 30;
                                    break;
                                }
                                if (r.distbits = 6, r.distcode = r.distdyn, E = {
                                    bits: r.distbits
                                }, B = b(_, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, E), r.distbits = E.bits, B) {
                                    m.msg = "invalid distances set", r.mode = 30;
                                    break;
                                }
                                if (r.mode = 20, I === 6) break e;
                            case 20:
                                r.mode = 21;
                            case 21:
                                if (6 <= L && 258 <= q) {
                                    m.next_out = Q, m.avail_out = q, m.next_in = P, m.avail_in = L, r.hold = C, r.bits = z, u(m, G), Q = m.next_out, J = m.output, q = m.avail_out, P = m.next_in, D = m.input, L = m.avail_in, C = r.hold, z = r.bits, r.mode === 12 && (r.back = -1);
                                    break;
                                }
                                for(r.back = 0; re = (s = r.lencode[C & (1 << r.lenbits) - 1]) >>> 16 & 255, ae = 65535 & s, !(($ = s >>> 24) <= z);){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                if (re && (240 & re) == 0) {
                                    for(ie = $, le = re, ue = ae; re = (s = r.lencode[ue + ((C & (1 << ie + le) - 1) >> ie)]) >>> 16 & 255, ae = 65535 & s, !(ie + ($ = s >>> 24) <= z);){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    C >>>= ie, z -= ie, r.back += ie;
                                }
                                if (C >>>= $, z -= $, r.back += $, r.length = ae, re === 0) {
                                    r.mode = 26;
                                    break;
                                }
                                if (32 & re) {
                                    r.back = -1, r.mode = 12;
                                    break;
                                }
                                if (64 & re) {
                                    m.msg = "invalid literal/length code", r.mode = 30;
                                    break;
                                }
                                r.extra = 15 & re, r.mode = 22;
                            case 22:
                                if (r.extra) {
                                    for(h = r.extra; z < h;){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    r.length += C & (1 << r.extra) - 1, C >>>= r.extra, z -= r.extra, r.back += r.extra;
                                }
                                r.was = r.length, r.mode = 23;
                            case 23:
                                for(; re = (s = r.distcode[C & (1 << r.distbits) - 1]) >>> 16 & 255, ae = 65535 & s, !(($ = s >>> 24) <= z);){
                                    if (L === 0) break e;
                                    L--, C += D[P++] << z, z += 8;
                                }
                                if ((240 & re) == 0) {
                                    for(ie = $, le = re, ue = ae; re = (s = r.distcode[ue + ((C & (1 << ie + le) - 1) >> ie)]) >>> 16 & 255, ae = 65535 & s, !(ie + ($ = s >>> 24) <= z);){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    C >>>= ie, z -= ie, r.back += ie;
                                }
                                if (C >>>= $, z -= $, r.back += $, 64 & re) {
                                    m.msg = "invalid distance code", r.mode = 30;
                                    break;
                                }
                                r.offset = ae, r.extra = 15 & re, r.mode = 24;
                            case 24:
                                if (r.extra) {
                                    for(h = r.extra; z < h;){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    r.offset += C & (1 << r.extra) - 1, C >>>= r.extra, z -= r.extra, r.back += r.extra;
                                }
                                if (r.offset > r.dmax) {
                                    m.msg = "invalid distance too far back", r.mode = 30;
                                    break;
                                }
                                r.mode = 25;
                            case 25:
                                if (q === 0) break e;
                                if (H = G - q, r.offset > H) {
                                    if ((H = r.offset - H) > r.whave && r.sane) {
                                        m.msg = "invalid distance too far back", r.mode = 30;
                                        break;
                                    }
                                    ne = H > r.wnext ? (H -= r.wnext, r.wsize - H) : r.wnext - H, H > r.length && (H = r.length), oe = r.window;
                                } else oe = J, ne = Q - r.offset, H = r.length;
                                for(q < H && (H = q), q -= H, r.length -= H; J[Q++] = oe[ne++], --H;);
                                r.length === 0 && (r.mode = 21);
                                break;
                            case 26:
                                if (q === 0) break e;
                                J[Q++] = r.length, q--, r.mode = 21;
                                break;
                            case 27:
                                if (r.wrap) {
                                    for(; z < 32;){
                                        if (L === 0) break e;
                                        L--, C |= D[P++] << z, z += 8;
                                    }
                                    if (G -= q, m.total_out += G, r.total += G, G && (m.adler = r.check = r.flags ? t(r.check, J, G, Q - G) : f(r.check, J, G, Q - G)), G = q, (r.flags ? C : a(C)) !== r.check) {
                                        m.msg = "incorrect data check", r.mode = 30;
                                        break;
                                    }
                                    z = C = 0;
                                }
                                r.mode = 28;
                            case 28:
                                if (r.wrap && r.flags) {
                                    for(; z < 32;){
                                        if (L === 0) break e;
                                        L--, C += D[P++] << z, z += 8;
                                    }
                                    if (C !== (4294967295 & r.total)) {
                                        m.msg = "incorrect length check", r.mode = 30;
                                        break;
                                    }
                                    z = C = 0;
                                }
                                r.mode = 29;
                            case 29:
                                B = 1;
                                break e;
                            case 30:
                                B = -3;
                                break e;
                            case 31:
                                return -4;
                            case 32:
                            default:
                                return i;
                        }
                        return m.next_out = Q, m.avail_out = q, m.next_in = P, m.avail_in = L, r.hold = C, r.bits = z, (r.wsize || G !== m.avail_out && r.mode < 30 && (r.mode < 27 || I !== 4)) && V(m, m.output, m.next_out, G - m.avail_out) ? (r.mode = 31, -4) : (X -= m.avail_in, G -= m.avail_out, m.total_in += X, m.total_out += G, r.total += G, r.wrap && G && (m.adler = r.check = r.flags ? t(r.check, J, G, m.next_out - G) : f(r.check, J, G, m.next_out - G)), m.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === 12 ? 128 : 0) + (r.mode === 20 || r.mode === 15 ? 256 : 0), (X == 0 && G === 0 || I === 4) && B === g && (B = -5), B);
                    }, y.inflateEnd = function(m) {
                        if (!m || !m.state) return i;
                        var I = m.state;
                        return I.window && (I.window = null), m.state = null, g;
                    }, y.inflateGetHeader = function(m, I) {
                        var r;
                        return m && m.state ? (2 & (r = m.state).wrap) == 0 ? i : ((r.head = I).done = !1, g) : i;
                    }, y.inflateSetDictionary = function(m, I) {
                        var r, D = I.length;
                        return m && m.state ? (r = m.state).wrap !== 0 && r.mode !== 11 ? i : r.mode === 11 && f(1, I, D, 0) !== r.check ? -3 : V(m, I, D, D) ? (r.mode = 31, -4) : (r.havedict = 1, g) : i;
                    }, y.inflateInfo = "pako inflate (from Nodeca project)";
                },
                {
                    "../utils/common": 41,
                    "./adler32": 43,
                    "./crc32": 45,
                    "./inffast": 48,
                    "./inftrees": 50
                }
            ],
            50: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils/common"), f = [
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        13,
                        15,
                        17,
                        19,
                        23,
                        27,
                        31,
                        35,
                        43,
                        51,
                        59,
                        67,
                        83,
                        99,
                        115,
                        131,
                        163,
                        195,
                        227,
                        258,
                        0,
                        0
                    ], t = [
                        16,
                        16,
                        16,
                        16,
                        16,
                        16,
                        16,
                        16,
                        17,
                        17,
                        17,
                        17,
                        18,
                        18,
                        18,
                        18,
                        19,
                        19,
                        19,
                        19,
                        20,
                        20,
                        20,
                        20,
                        21,
                        21,
                        21,
                        21,
                        16,
                        72,
                        78
                    ], u = [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        9,
                        13,
                        17,
                        25,
                        33,
                        49,
                        65,
                        97,
                        129,
                        193,
                        257,
                        385,
                        513,
                        769,
                        1025,
                        1537,
                        2049,
                        3073,
                        4097,
                        6145,
                        8193,
                        12289,
                        16385,
                        24577,
                        0,
                        0
                    ], b = [
                        16,
                        16,
                        16,
                        16,
                        17,
                        17,
                        18,
                        18,
                        19,
                        19,
                        20,
                        20,
                        21,
                        21,
                        22,
                        22,
                        23,
                        23,
                        24,
                        24,
                        25,
                        25,
                        26,
                        26,
                        27,
                        27,
                        28,
                        28,
                        29,
                        29,
                        64,
                        64
                    ];
                    R.exports = function(v, _, g, i, d, p, n, a) {
                        var l, w, O, x, U, T, M, A, W, V = a.bits, m = 0, I = 0, r = 0, D = 0, J = 0, P = 0, Q = 0, L = 0, q = 0, C = 0, z = null, X = 0, G = new o.Buf16(16), H = new o.Buf16(16), ne = null, oe = 0;
                        for(m = 0; m <= 15; m++)G[m] = 0;
                        for(I = 0; I < i; I++)G[_[g + I]]++;
                        for(J = V, D = 15; 1 <= D && G[D] === 0; D--);
                        if (D < J && (J = D), D === 0) return d[p++] = 20971520, d[p++] = 20971520, a.bits = 1, 0;
                        for(r = 1; r < D && G[r] === 0; r++);
                        for(J < r && (J = r), m = L = 1; m <= 15; m++)if (L <<= 1, (L -= G[m]) < 0) return -1;
                        if (0 < L && (v === 0 || D !== 1)) return -1;
                        for(H[1] = 0, m = 1; m < 15; m++)H[m + 1] = H[m] + G[m];
                        for(I = 0; I < i; I++)_[g + I] !== 0 && (n[H[_[g + I]]++] = I);
                        if (T = v === 0 ? (z = ne = n, 19) : v === 1 ? (z = f, X -= 257, ne = t, oe -= 257, 256) : (z = u, ne = b, -1), m = r, U = p, Q = I = C = 0, O = -1, x = (q = 1 << (P = J)) - 1, v === 1 && 852 < q || v === 2 && 592 < q) return 1;
                        for(;;){
                            for(M = m - Q, W = n[I] < T ? (A = 0, n[I]) : n[I] > T ? (A = ne[oe + n[I]], z[X + n[I]]) : (A = 96, 0), l = 1 << m - Q, r = w = 1 << P; d[U + (C >> Q) + (w -= l)] = M << 24 | A << 16 | W | 0, w !== 0;);
                            for(l = 1 << m - 1; C & l;)l >>= 1;
                            if (l !== 0 ? (C &= l - 1, C += l) : C = 0, I++, --G[m] == 0) {
                                if (m === D) break;
                                m = _[g + n[I]];
                            }
                            if (J < m && (C & x) !== O) {
                                for(Q === 0 && (Q = J), U += r, L = 1 << (P = m - Q); P + Q < D && !((L -= G[P + Q]) <= 0);)P++, L <<= 1;
                                if (q += 1 << P, v === 1 && 852 < q || v === 2 && 592 < q) return 1;
                                d[O = C & x] = J << 24 | P << 16 | U - p | 0;
                            }
                        }
                        return C !== 0 && (d[U + C] = m - Q << 24 | 64 << 16 | 0), a.bits = J, 0;
                    };
                },
                {
                    "../utils/common": 41
                }
            ],
            51: [
                function(c, R, y) {
                    "use strict";
                    R.exports = {
                        2: "need dictionary",
                        1: "stream end",
                        0: "",
                        "-1": "file error",
                        "-2": "stream error",
                        "-3": "data error",
                        "-4": "insufficient memory",
                        "-5": "buffer error",
                        "-6": "incompatible version"
                    };
                },
                {}
            ],
            52: [
                function(c, R, y) {
                    "use strict";
                    var o = c("../utils/common"), f = 0, t = 1;
                    function u(s) {
                        for(var k = s.length; 0 <= --k;)s[k] = 0;
                    }
                    var b = 0, v = 29, _ = 256, g = _ + 1 + v, i = 30, d = 19, p = 2 * g + 1, n = 15, a = 16, l = 7, w = 256, O = 16, x = 17, U = 18, T = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1,
                        1,
                        1,
                        1,
                        2,
                        2,
                        2,
                        2,
                        3,
                        3,
                        3,
                        3,
                        4,
                        4,
                        4,
                        4,
                        5,
                        5,
                        5,
                        5,
                        0
                    ], M = [
                        0,
                        0,
                        0,
                        0,
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5,
                        6,
                        6,
                        7,
                        7,
                        8,
                        8,
                        9,
                        9,
                        10,
                        10,
                        11,
                        11,
                        12,
                        12,
                        13,
                        13
                    ], A = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        2,
                        3,
                        7
                    ], W = [
                        16,
                        17,
                        18,
                        0,
                        8,
                        7,
                        9,
                        6,
                        10,
                        5,
                        11,
                        4,
                        12,
                        3,
                        13,
                        2,
                        14,
                        1,
                        15
                    ], V = new Array(2 * (g + 2));
                    u(V);
                    var m = new Array(2 * i);
                    u(m);
                    var I = new Array(512);
                    u(I);
                    var r = new Array(256);
                    u(r);
                    var D = new Array(v);
                    u(D);
                    var J, P, Q, L = new Array(i);
                    function q(s, k, F, N, S) {
                        this.static_tree = s, this.extra_bits = k, this.extra_base = F, this.elems = N, this.max_length = S, this.has_stree = s && s.length;
                    }
                    function C(s, k) {
                        this.dyn_tree = s, this.max_code = 0, this.stat_desc = k;
                    }
                    function z(s) {
                        return s < 256 ? I[s] : I[256 + (s >>> 7)];
                    }
                    function X(s, k) {
                        s.pending_buf[s.pending++] = 255 & k, s.pending_buf[s.pending++] = k >>> 8 & 255;
                    }
                    function G(s, k, F) {
                        s.bi_valid > a - F ? (s.bi_buf |= k << s.bi_valid & 65535, X(s, s.bi_buf), s.bi_buf = k >> a - s.bi_valid, s.bi_valid += F - a) : (s.bi_buf |= k << s.bi_valid & 65535, s.bi_valid += F);
                    }
                    function H(s, k, F) {
                        G(s, F[2 * k], F[2 * k + 1]);
                    }
                    function ne(s, k) {
                        for(var F = 0; F |= 1 & s, s >>>= 1, F <<= 1, 0 < --k;);
                        return F >>> 1;
                    }
                    function oe(s, k, F) {
                        var N, S, j = new Array(n + 1), K = 0;
                        for(N = 1; N <= n; N++)j[N] = K = K + F[N - 1] << 1;
                        for(S = 0; S <= k; S++){
                            var Z = s[2 * S + 1];
                            Z !== 0 && (s[2 * S] = ne(j[Z]++, Z));
                        }
                    }
                    function $(s) {
                        var k;
                        for(k = 0; k < g; k++)s.dyn_ltree[2 * k] = 0;
                        for(k = 0; k < i; k++)s.dyn_dtree[2 * k] = 0;
                        for(k = 0; k < d; k++)s.bl_tree[2 * k] = 0;
                        s.dyn_ltree[2 * w] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;
                    }
                    function re(s) {
                        8 < s.bi_valid ? X(s, s.bi_buf) : 0 < s.bi_valid && (s.pending_buf[s.pending++] = s.bi_buf), s.bi_buf = 0, s.bi_valid = 0;
                    }
                    function ae(s, k, F, N) {
                        var S = 2 * k, j = 2 * F;
                        return s[S] < s[j] || s[S] === s[j] && N[k] <= N[F];
                    }
                    function ie(s, k, F) {
                        for(var N = s.heap[F], S = F << 1; S <= s.heap_len && (S < s.heap_len && ae(k, s.heap[S + 1], s.heap[S], s.depth) && S++, !ae(k, N, s.heap[S], s.depth));)s.heap[F] = s.heap[S], F = S, S <<= 1;
                        s.heap[F] = N;
                    }
                    function le(s, k, F) {
                        var N, S, j, K, Z = 0;
                        if (s.last_lit !== 0) for(; N = s.pending_buf[s.d_buf + 2 * Z] << 8 | s.pending_buf[s.d_buf + 2 * Z + 1], S = s.pending_buf[s.l_buf + Z], Z++, N === 0 ? H(s, S, k) : (H(s, (j = r[S]) + _ + 1, k), (K = T[j]) !== 0 && G(s, S -= D[j], K), H(s, j = z(--N), F), (K = M[j]) !== 0 && G(s, N -= L[j], K)), Z < s.last_lit;);
                        H(s, w, k);
                    }
                    function ue(s, k) {
                        var F, N, S, j = k.dyn_tree, K = k.stat_desc.static_tree, Z = k.stat_desc.has_stree, Y = k.stat_desc.elems, te = -1;
                        for(s.heap_len = 0, s.heap_max = p, F = 0; F < Y; F++)j[2 * F] !== 0 ? (s.heap[++s.heap_len] = te = F, s.depth[F] = 0) : j[2 * F + 1] = 0;
                        for(; s.heap_len < 2;)j[2 * (S = s.heap[++s.heap_len] = te < 2 ? ++te : 0)] = 1, s.depth[S] = 0, s.opt_len--, Z && (s.static_len -= K[2 * S + 1]);
                        for(k.max_code = te, F = s.heap_len >> 1; 1 <= F; F--)ie(s, j, F);
                        for(S = Y; F = s.heap[1], s.heap[1] = s.heap[s.heap_len--], ie(s, j, 1), N = s.heap[1], s.heap[--s.heap_max] = F, s.heap[--s.heap_max] = N, j[2 * S] = j[2 * F] + j[2 * N], s.depth[S] = (s.depth[F] >= s.depth[N] ? s.depth[F] : s.depth[N]) + 1, j[2 * F + 1] = j[2 * N + 1] = S, s.heap[1] = S++, ie(s, j, 1), 2 <= s.heap_len;);
                        s.heap[--s.heap_max] = s.heap[1], function(ee, he) {
                            var ce, fe, pe, se, ge, ve, de = he.dyn_tree, we = he.max_code, Ae = he.stat_desc.static_tree, Ie = he.stat_desc.has_stree, Oe = he.stat_desc.extra_bits, ke = he.stat_desc.extra_base, me = he.stat_desc.max_length, be = 0;
                            for(se = 0; se <= n; se++)ee.bl_count[se] = 0;
                            for(de[2 * ee.heap[ee.heap_max] + 1] = 0, ce = ee.heap_max + 1; ce < p; ce++)me < (se = de[2 * de[2 * (fe = ee.heap[ce]) + 1] + 1] + 1) && (se = me, be++), de[2 * fe + 1] = se, we < fe || (ee.bl_count[se]++, ge = 0, ke <= fe && (ge = Oe[fe - ke]), ve = de[2 * fe], ee.opt_len += ve * (se + ge), Ie && (ee.static_len += ve * (Ae[2 * fe + 1] + ge)));
                            if (be !== 0) {
                                do {
                                    for(se = me - 1; ee.bl_count[se] === 0;)se--;
                                    ee.bl_count[se]--, ee.bl_count[se + 1] += 2, ee.bl_count[me]--, be -= 2;
                                }while (0 < be)
                                for(se = me; se !== 0; se--)for(fe = ee.bl_count[se]; fe !== 0;)we < (pe = ee.heap[--ce]) || (de[2 * pe + 1] !== se && (ee.opt_len += (se - de[2 * pe + 1]) * de[2 * pe], de[2 * pe + 1] = se), fe--);
                            }
                        }(s, k), oe(j, te, s.bl_count);
                    }
                    function e(s, k, F) {
                        var N, S, j = -1, K = k[1], Z = 0, Y = 7, te = 4;
                        for(K === 0 && (Y = 138, te = 3), k[2 * (F + 1) + 1] = 65535, N = 0; N <= F; N++)S = K, K = k[2 * (N + 1) + 1], ++Z < Y && S === K || (Z < te ? s.bl_tree[2 * S] += Z : S !== 0 ? (S !== j && s.bl_tree[2 * S]++, s.bl_tree[2 * O]++) : Z <= 10 ? s.bl_tree[2 * x]++ : s.bl_tree[2 * U]++, j = S, te = (Z = 0) === K ? (Y = 138, 3) : S === K ? (Y = 6, 3) : (Y = 7, 4));
                    }
                    function B(s, k, F) {
                        var N, S, j = -1, K = k[1], Z = 0, Y = 7, te = 4;
                        for(K === 0 && (Y = 138, te = 3), N = 0; N <= F; N++)if (S = K, K = k[2 * (N + 1) + 1], !(++Z < Y && S === K)) {
                            if (Z < te) for(; H(s, S, s.bl_tree), --Z != 0;);
                            else S !== 0 ? (S !== j && (H(s, S, s.bl_tree), Z--), H(s, O, s.bl_tree), G(s, Z - 3, 2)) : Z <= 10 ? (H(s, x, s.bl_tree), G(s, Z - 3, 3)) : (H(s, U, s.bl_tree), G(s, Z - 11, 7));
                            j = S, te = (Z = 0) === K ? (Y = 138, 3) : S === K ? (Y = 6, 3) : (Y = 7, 4);
                        }
                    }
                    u(L);
                    var E = !1;
                    function h(s, k, F, N) {
                        G(s, (b << 1) + (N ? 1 : 0), 3), function(S, j, K, Z) {
                            re(S), Z && (X(S, K), X(S, ~K)), o.arraySet(S.pending_buf, S.window, j, K, S.pending), S.pending += K;
                        }(s, k, F, !0);
                    }
                    y._tr_init = function(s) {
                        E || (function() {
                            var k, F, N, S, j, K = new Array(n + 1);
                            for(S = N = 0; S < v - 1; S++)for(D[S] = N, k = 0; k < 1 << T[S]; k++)r[N++] = S;
                            for(r[N - 1] = S, S = j = 0; S < 16; S++)for(L[S] = j, k = 0; k < 1 << M[S]; k++)I[j++] = S;
                            for(j >>= 7; S < i; S++)for(L[S] = j << 7, k = 0; k < 1 << M[S] - 7; k++)I[256 + j++] = S;
                            for(F = 0; F <= n; F++)K[F] = 0;
                            for(k = 0; k <= 143;)V[2 * k + 1] = 8, k++, K[8]++;
                            for(; k <= 255;)V[2 * k + 1] = 9, k++, K[9]++;
                            for(; k <= 279;)V[2 * k + 1] = 7, k++, K[7]++;
                            for(; k <= 287;)V[2 * k + 1] = 8, k++, K[8]++;
                            for(oe(V, g + 1, K), k = 0; k < i; k++)m[2 * k + 1] = 5, m[2 * k] = ne(k, 5);
                            J = new q(V, T, _ + 1, g, n), P = new q(m, M, 0, i, n), Q = new q(new Array(0), A, 0, d, l);
                        }(), E = !0), s.l_desc = new C(s.dyn_ltree, J), s.d_desc = new C(s.dyn_dtree, P), s.bl_desc = new C(s.bl_tree, Q), s.bi_buf = 0, s.bi_valid = 0, $(s);
                    }, y._tr_stored_block = h, y._tr_flush_block = function(s, k, F, N) {
                        var S, j, K = 0;
                        0 < s.level ? (s.strm.data_type === 2 && (s.strm.data_type = function(Z) {
                            var Y, te = 4093624447;
                            for(Y = 0; Y <= 31; Y++, te >>>= 1)if (1 & te && Z.dyn_ltree[2 * Y] !== 0) return f;
                            if (Z.dyn_ltree[18] !== 0 || Z.dyn_ltree[20] !== 0 || Z.dyn_ltree[26] !== 0) return t;
                            for(Y = 32; Y < _; Y++)if (Z.dyn_ltree[2 * Y] !== 0) return t;
                            return f;
                        }(s)), ue(s, s.l_desc), ue(s, s.d_desc), K = function(Z) {
                            var Y;
                            for(e(Z, Z.dyn_ltree, Z.l_desc.max_code), e(Z, Z.dyn_dtree, Z.d_desc.max_code), ue(Z, Z.bl_desc), Y = d - 1; 3 <= Y && Z.bl_tree[2 * W[Y] + 1] === 0; Y--);
                            return Z.opt_len += 3 * (Y + 1) + 5 + 5 + 4, Y;
                        }(s), S = s.opt_len + 3 + 7 >>> 3, (j = s.static_len + 3 + 7 >>> 3) <= S && (S = j)) : S = j = F + 5, F + 4 <= S && k !== -1 ? h(s, k, F, N) : s.strategy === 4 || j === S ? (G(s, 2 + (N ? 1 : 0), 3), le(s, V, m)) : (G(s, 4 + (N ? 1 : 0), 3), function(Z, Y, te, ee) {
                            var he;
                            for(G(Z, Y - 257, 5), G(Z, te - 1, 5), G(Z, ee - 4, 4), he = 0; he < ee; he++)G(Z, Z.bl_tree[2 * W[he] + 1], 3);
                            B(Z, Z.dyn_ltree, Y - 1), B(Z, Z.dyn_dtree, te - 1);
                        }(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, K + 1), le(s, s.dyn_ltree, s.dyn_dtree)), $(s), N && re(s);
                    }, y._tr_tally = function(s, k, F) {
                        return s.pending_buf[s.d_buf + 2 * s.last_lit] = k >>> 8 & 255, s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 255 & k, s.pending_buf[s.l_buf + s.last_lit] = 255 & F, s.last_lit++, k === 0 ? s.dyn_ltree[2 * F]++ : (s.matches++, k--, s.dyn_ltree[2 * (r[F] + _ + 1)]++, s.dyn_dtree[2 * z(k)]++), s.last_lit === s.lit_bufsize - 1;
                    }, y._tr_align = function(s) {
                        G(s, 2, 3), H(s, w, V), function(k) {
                            k.bi_valid === 16 ? (X(k, k.bi_buf), k.bi_buf = 0, k.bi_valid = 0) : 8 <= k.bi_valid && (k.pending_buf[k.pending++] = 255 & k.bi_buf, k.bi_buf >>= 8, k.bi_valid -= 8);
                        }(s);
                    };
                },
                {
                    "../utils/common": 41
                }
            ],
            53: [
                function(c, R, y) {
                    "use strict";
                    R.exports = function() {
                        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                    };
                },
                {}
            ],
            54: [
                function(c, R, y) {
                    "use strict";
                    R.exports = typeof __setImmediate$ == "function" ? __setImmediate$ : function() {
                        var o = [].slice.apply(arguments);
                        o.splice(1, 0, 0), setTimeout.apply(null, o);
                    };
                },
                {}
            ]
        }, {}, [
            10
        ])(10);
    });
});
var Ee4 = Pe6(ze2()), { prototype: We1 , support: Me6 , defaults: He1 , version: Ge1 , loadAsync: Ke1 , external: Ye2  } = Ee4, { default: Ce8 , ...Le3 } = Ee4, Xe = Ce8 !== void 0 ? Ce8 : Le3;
var __global$2 = globalThis || (typeof window !== "undefined" ? window : self);
var $r = Object.create;
var Ye3 = Object.defineProperty;
var Vr = Object.getOwnPropertyDescriptor;
var Kr = Object.getOwnPropertyNames;
var Qr = Object.getPrototypeOf, Hr = Object.prototype.hasOwnProperty;
var ne7 = ((E)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(E, {
        get: (S, H)=>(typeof require < "u" ? require : S)[H]
    }) : E)(function(E) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + E + '" is not supported');
});
var Gr = (E, S)=>()=>(S || E((S = {
            exports: {}
        }).exports, S), S.exports);
var Xr = (E, S, H, z)=>{
    if (S && typeof S == "object" || typeof S == "function") for (let B of Kr(S))!Hr.call(E, B) && B !== H && Ye3(E, B, {
        get: ()=>S[B],
        enumerable: !(z = Vr(S, B)) || z.enumerable
    });
    return E;
};
var Jr = (E, S, H)=>(H = E != null ? $r(Qr(E)) : {}, Xr(S || !E || !E.__esModule ? Ye3(H, "default", {
        value: E,
        enumerable: !0
    }) : H, E));
var We2 = Gr((ze, pe)=>{
    (function(E) {
        if (typeof ze == "object" && typeof pe < "u") pe.exports = E();
        else if (typeof define == "function" && define.amd) define([], E);
        else {
            var S;
            typeof document < "u" ? S = window : typeof __global$2 < "u" ? S = __global$2 : typeof self < "u" ? S = self : S = this, S.localforage = E();
        }
    })(function() {
        return (function z(B, G, I) {
            function P(C, W) {
                if (!G[C]) {
                    if (!B[C]) {
                        var d = typeof ne7 == "function" && ne7;
                        if (!W && d) return d(C, !0);
                        if (b) return b(C, !0);
                        var h = new Error("Cannot find module '" + C + "'");
                        throw h.code = "MODULE_NOT_FOUND", h;
                    }
                    var A = G[C] = {
                        exports: {}
                    };
                    B[C][0].call(A.exports, function(D) {
                        var $ = B[C][1][D];
                        return P($ || D);
                    }, A, A.exports, z, B, G, I);
                }
                return G[C].exports;
            }
            for(var b = typeof ne7 == "function" && ne7, L = 0; L < I.length; L++)P(I[L]);
            return P;
        })({
            1: [
                function(z, B, G) {
                    (function(I) {
                        "use strict";
                        var P = I.MutationObserver || I.WebKitMutationObserver, b;
                        if (P) {
                            var L = 0, C = new P(D), W = I.document.createTextNode("");
                            C.observe(W, {
                                characterData: !0
                            }), b = function() {
                                W.data = L = ++L % 2;
                            };
                        } else if (!I.setImmediate && typeof I.MessageChannel < "u") {
                            var d = new I.MessageChannel;
                            d.port1.onmessage = D, b = function() {
                                d.port2.postMessage(0);
                            };
                        } else "document" in I && "onreadystatechange" in I.document.createElement("script") ? b = function() {
                            var T = I.document.createElement("script");
                            T.onreadystatechange = function() {
                                D(), T.onreadystatechange = null, T.parentNode.removeChild(T), T = null;
                            }, I.document.documentElement.appendChild(T);
                        } : b = function() {
                            setTimeout(D, 0);
                        };
                        var h, A = [];
                        function D() {
                            h = !0;
                            for(var T, V, x = A.length; x;){
                                for(V = A, A = [], T = -1; ++T < x;)V[T]();
                                x = A.length;
                            }
                            h = !1;
                        }
                        B.exports = $;
                        function $(T) {
                            A.push(T) === 1 && !h && b();
                        }
                    }).call(this, typeof __global$2 < "u" ? __global$2 : typeof self < "u" ? self : typeof document < "u" ? window : {});
                },
                {}
            ],
            2: [
                function(z, B, G) {
                    "use strict";
                    var I = z(1);
                    function P() {}
                    var b = {}, L = [
                        "REJECTED"
                    ], C = [
                        "FULFILLED"
                    ], W = [
                        "PENDING"
                    ];
                    B.exports = d;
                    function d(l) {
                        if (typeof l != "function") throw new TypeError("resolver must be a function");
                        this.state = W, this.queue = [], this.outcome = void 0, l !== P && $(this, l);
                    }
                    d.prototype.catch = function(l) {
                        return this.then(null, l);
                    }, d.prototype.then = function(l, p) {
                        if (typeof l != "function" && this.state === C || typeof p != "function" && this.state === L) return this;
                        var y = new this.constructor(P);
                        if (this.state !== W) {
                            var w = this.state === C ? l : p;
                            A(y, w, this.outcome);
                        } else this.queue.push(new h(y, l, p));
                        return y;
                    };
                    function h(l, p, y) {
                        this.promise = l, typeof p == "function" && (this.onFulfilled = p, this.callFulfilled = this.otherCallFulfilled), typeof y == "function" && (this.onRejected = y, this.callRejected = this.otherCallRejected);
                    }
                    h.prototype.callFulfilled = function(l) {
                        b.resolve(this.promise, l);
                    }, h.prototype.otherCallFulfilled = function(l) {
                        A(this.promise, this.onFulfilled, l);
                    }, h.prototype.callRejected = function(l) {
                        b.reject(this.promise, l);
                    }, h.prototype.otherCallRejected = function(l) {
                        A(this.promise, this.onRejected, l);
                    };
                    function A(l, p, y) {
                        I(function() {
                            var w;
                            try {
                                w = p(y);
                            } catch (O) {
                                return b.reject(l, O);
                            }
                            w === l ? b.reject(l, new TypeError("Cannot resolve promise with itself")) : b.resolve(l, w);
                        });
                    }
                    b.resolve = function(l, p) {
                        var y = T(D, p);
                        if (y.status === "error") return b.reject(l, y.value);
                        var w = y.value;
                        if (w) $(l, w);
                        else {
                            l.state = C, l.outcome = p;
                            for(var O = -1, F = l.queue.length; ++O < F;)l.queue[O].callFulfilled(p);
                        }
                        return l;
                    }, b.reject = function(l, p) {
                        l.state = L, l.outcome = p;
                        for(var y = -1, w = l.queue.length; ++y < w;)l.queue[y].callRejected(p);
                        return l;
                    };
                    function D(l) {
                        var p = l && l.then;
                        if (l && (typeof l == "object" || typeof l == "function") && typeof p == "function") return function() {
                            p.apply(l, arguments);
                        };
                    }
                    function $(l, p) {
                        var y = !1;
                        function w(U) {
                            y || (y = !0, b.reject(l, U));
                        }
                        function O(U) {
                            y || (y = !0, b.resolve(l, U));
                        }
                        function F() {
                            p(O, w);
                        }
                        var M = T(F);
                        M.status === "error" && w(M.value);
                    }
                    function T(l, p) {
                        var y = {};
                        try {
                            y.value = l(p), y.status = "success";
                        } catch (w) {
                            y.status = "error", y.value = w;
                        }
                        return y;
                    }
                    d.resolve = V;
                    function V(l) {
                        return l instanceof this ? l : b.resolve(new this(P), l);
                    }
                    d.reject = x;
                    function x(l) {
                        var p = new this(P);
                        return b.reject(p, l);
                    }
                    d.all = ie;
                    function ie(l) {
                        var p = this;
                        if (Object.prototype.toString.call(l) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                        var y = l.length, w = !1;
                        if (!y) return this.resolve([]);
                        for(var O = new Array(y), F = 0, M = -1, U = new this(P); ++M < y;)K(l[M], M);
                        return U;
                        function K(k, te) {
                            p.resolve(k).then(fe, function(j) {
                                w || (w = !0, b.reject(U, j));
                            });
                            function fe(j) {
                                O[te] = j, ++F === y && !w && (w = !0, b.resolve(U, O));
                            }
                        }
                    }
                    d.race = Z;
                    function Z(l) {
                        var p = this;
                        if (Object.prototype.toString.call(l) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                        var y = l.length, w = !1;
                        if (!y) return this.resolve([]);
                        for(var O = -1, F = new this(P); ++O < y;)M(l[O]);
                        return F;
                        function M(U) {
                            p.resolve(U).then(function(K) {
                                w || (w = !0, b.resolve(F, K));
                            }, function(K) {
                                w || (w = !0, b.reject(F, K));
                            });
                        }
                    }
                },
                {
                    1: 1
                }
            ],
            3: [
                function(z, B, G) {
                    (function(I) {
                        "use strict";
                        typeof I.Promise != "function" && (I.Promise = z(2));
                    }).call(this, typeof __global$2 < "u" ? __global$2 : typeof self < "u" ? self : typeof document < "u" ? window : {});
                },
                {
                    2: 2
                }
            ],
            4: [
                function(z, B, G) {
                    "use strict";
                    var I = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
                        return typeof e;
                    } : function(e) {
                        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                    };
                    function P(e, n) {
                        if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function");
                    }
                    function b() {
                        try {
                            if (typeof indexedDB < "u") return indexedDB;
                            if (typeof webkitIndexedDB < "u") return webkitIndexedDB;
                            if (typeof mozIndexedDB < "u") return mozIndexedDB;
                            if (typeof OIndexedDB < "u") return OIndexedDB;
                            if (typeof msIndexedDB < "u") return msIndexedDB;
                        } catch  {
                            return;
                        }
                    }
                    var L = b();
                    function C() {
                        try {
                            if (!L || !L.open) return !1;
                            var e = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), n = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
                            return (!e || n) && typeof indexedDB < "u" && typeof IDBKeyRange < "u";
                        } catch  {
                            return !1;
                        }
                    }
                    function W(e, n) {
                        e = e || [], n = n || {};
                        try {
                            return new Blob(e, n);
                        } catch (t) {
                            if (t.name !== "TypeError") throw t;
                            for(var r = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, o = new r, a = 0; a < e.length; a += 1)o.append(e[a]);
                            return o.getBlob(n.type);
                        }
                    }
                    typeof Promise > "u" && z(3);
                    var d = Promise;
                    function h(e, n) {
                        n && e.then(function(r) {
                            n(null, r);
                        }, function(r) {
                            n(r);
                        });
                    }
                    function A(e, n, r) {
                        typeof n == "function" && e.then(n), typeof r == "function" && e.catch(r);
                    }
                    function D(e) {
                        return typeof e != "string" && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e;
                    }
                    function $() {
                        if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
                    }
                    var T = "local-forage-detect-blob-support", V = void 0, x = {}, ie = Object.prototype.toString, Z = "readonly", l = "readwrite";
                    function p(e) {
                        for(var n = e.length, r = new ArrayBuffer(n), o = new Uint8Array(r), a = 0; a < n; a++)o[a] = e.charCodeAt(a);
                        return r;
                    }
                    function y(e) {
                        return new d(function(n) {
                            var r = e.transaction(T, l), o = W([
                                ""
                            ]);
                            r.objectStore(T).put(o, "key"), r.onabort = function(a) {
                                a.preventDefault(), a.stopPropagation(), n(!1);
                            }, r.oncomplete = function() {
                                var a = navigator.userAgent.match(/Chrome\/(\d+)/), t = navigator.userAgent.match(/Edge\//);
                                n(t || !a || parseInt(a[1], 10) >= 43);
                            };
                        }).catch(function() {
                            return !1;
                        });
                    }
                    function w(e) {
                        return typeof V == "boolean" ? d.resolve(V) : y(e).then(function(n) {
                            return V = n, V;
                        });
                    }
                    function O(e) {
                        var n = x[e.name], r = {};
                        r.promise = new d(function(o, a) {
                            r.resolve = o, r.reject = a;
                        }), n.deferredOperations.push(r), n.dbReady ? n.dbReady = n.dbReady.then(function() {
                            return r.promise;
                        }) : n.dbReady = r.promise;
                    }
                    function F(e) {
                        var n = x[e.name], r = n.deferredOperations.pop();
                        if (r) return r.resolve(), r.promise;
                    }
                    function M(e, n) {
                        var r = x[e.name], o = r.deferredOperations.pop();
                        if (o) return o.reject(n), o.promise;
                    }
                    function U(e, n) {
                        return new d(function(r, o) {
                            if (x[e.name] = x[e.name] || _e(), e.db) if (n) O(e), e.db.close();
                            else return r(e.db);
                            var a = [
                                e.name
                            ];
                            n && a.push(e.version);
                            var t = L.open.apply(L, a);
                            n && (t.onupgradeneeded = function(i) {
                                var f = t.result;
                                try {
                                    f.createObjectStore(e.storeName), i.oldVersion <= 1 && f.createObjectStore(T);
                                } catch (u) {
                                    if (u.name === "ConstraintError") console.warn('The database "' + e.name + '" has been upgraded from version ' + i.oldVersion + " to version " + i.newVersion + ', but the storage "' + e.storeName + '" already exists.');
                                    else throw u;
                                }
                            }), t.onerror = function(i) {
                                i.preventDefault(), o(t.error);
                            }, t.onsuccess = function() {
                                var i = t.result;
                                i.onversionchange = function(f) {
                                    f.target.close();
                                }, r(i), F(e);
                            };
                        });
                    }
                    function K(e) {
                        return U(e, !1);
                    }
                    function k(e) {
                        return U(e, !0);
                    }
                    function te(e, n) {
                        if (!e.db) return !0;
                        var r = !e.db.objectStoreNames.contains(e.storeName), o = e.version < e.db.version, a = e.version > e.db.version;
                        if (o && (e.version !== n && console.warn('The database "' + e.name + `" can't be downgraded from version ` + e.db.version + " to version " + e.version + "."), e.version = e.db.version), a || r) {
                            if (r) {
                                var t = e.db.version + 1;
                                t > e.version && (e.version = t);
                            }
                            return !0;
                        }
                        return !1;
                    }
                    function fe(e) {
                        return new d(function(n, r) {
                            var o = new FileReader;
                            o.onerror = r, o.onloadend = function(a) {
                                var t = btoa(a.target.result || "");
                                n({
                                    __local_forage_encoded_blob: !0,
                                    data: t,
                                    type: e.type
                                });
                            }, o.readAsBinaryString(e);
                        });
                    }
                    function j(e) {
                        var n = p(atob(e.data));
                        return W([
                            n
                        ], {
                            type: e.type
                        });
                    }
                    function ge(e) {
                        return e && e.__local_forage_encoded_blob;
                    }
                    function Ve(e) {
                        var n = this, r = n._initReady().then(function() {
                            var o = x[n._dbInfo.name];
                            if (o && o.dbReady) return o.dbReady;
                        });
                        return A(r, e, e), r;
                    }
                    function Ke(e) {
                        O(e);
                        for(var n = x[e.name], r = n.forages, o = 0; o < r.length; o++){
                            var a = r[o];
                            a._dbInfo.db && (a._dbInfo.db.close(), a._dbInfo.db = null);
                        }
                        return e.db = null, K(e).then(function(t) {
                            return e.db = t, te(e) ? k(e) : t;
                        }).then(function(t) {
                            e.db = n.db = t;
                            for(var i = 0; i < r.length; i++)r[i]._dbInfo.db = t;
                        }).catch(function(t) {
                            throw M(e, t), t;
                        });
                    }
                    function Q(e, n, r, o) {
                        o === void 0 && (o = 1);
                        try {
                            var a = e.db.transaction(e.storeName, n);
                            r(null, a);
                        } catch (t) {
                            if (o > 0 && (!e.db || t.name === "InvalidStateError" || t.name === "NotFoundError")) return d.resolve().then(function() {
                                if (!e.db || t.name === "NotFoundError" && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version) return e.db && (e.version = e.db.version + 1), k(e);
                            }).then(function() {
                                return Ke(e).then(function() {
                                    Q(e, n, r, o - 1);
                                });
                            }).catch(r);
                            r(t);
                        }
                    }
                    function _e() {
                        return {
                            forages: [],
                            db: null,
                            dbReady: null,
                            deferredOperations: []
                        };
                    }
                    function Qe(e) {
                        var n = this, r = {
                            db: null
                        };
                        if (e) for(var o in e)r[o] = e[o];
                        var a = x[r.name];
                        a || (a = _e(), x[r.name] = a), a.forages.push(n), n._initReady || (n._initReady = n.ready, n.ready = Ve);
                        var t = [];
                        function i() {
                            return d.resolve();
                        }
                        for(var f = 0; f < a.forages.length; f++){
                            var u = a.forages[f];
                            u !== n && t.push(u._initReady().catch(i));
                        }
                        var s = a.forages.slice(0);
                        return d.all(t).then(function() {
                            return r.db = a.db, K(r);
                        }).then(function(c) {
                            return r.db = c, te(r, n._defaultConfig.version) ? k(r) : c;
                        }).then(function(c) {
                            r.db = a.db = c, n._dbInfo = r;
                            for(var v = 0; v < s.length; v++){
                                var m = s[v];
                                m !== n && (m._dbInfo.db = r.db, m._dbInfo.version = r.version);
                            }
                        });
                    }
                    function He(e, n) {
                        var r = this;
                        e = D(e);
                        var o = new d(function(a, t) {
                            r.ready().then(function() {
                                Q(r._dbInfo, Z, function(i, f) {
                                    if (i) return t(i);
                                    try {
                                        var u = f.objectStore(r._dbInfo.storeName), s = u.get(e);
                                        s.onsuccess = function() {
                                            var c = s.result;
                                            c === void 0 && (c = null), ge(c) && (c = j(c)), a(c);
                                        }, s.onerror = function() {
                                            t(s.error);
                                        };
                                    } catch (c) {
                                        t(c);
                                    }
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function Ge(e, n) {
                        var r = this, o = new d(function(a, t) {
                            r.ready().then(function() {
                                Q(r._dbInfo, Z, function(i, f) {
                                    if (i) return t(i);
                                    try {
                                        var u = f.objectStore(r._dbInfo.storeName), s = u.openCursor(), c = 1;
                                        s.onsuccess = function() {
                                            var v = s.result;
                                            if (v) {
                                                var m = v.value;
                                                ge(m) && (m = j(m));
                                                var g = e(m, v.key, c++);
                                                g !== void 0 ? a(g) : v.continue();
                                            } else a();
                                        }, s.onerror = function() {
                                            t(s.error);
                                        };
                                    } catch (v) {
                                        t(v);
                                    }
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function Xe(e, n, r) {
                        var o = this;
                        e = D(e);
                        var a = new d(function(t, i) {
                            var f;
                            o.ready().then(function() {
                                return f = o._dbInfo, ie.call(n) === "[object Blob]" ? w(f.db).then(function(u) {
                                    return u ? n : fe(n);
                                }) : n;
                            }).then(function(u) {
                                Q(o._dbInfo, l, function(s, c) {
                                    if (s) return i(s);
                                    try {
                                        var v = c.objectStore(o._dbInfo.storeName);
                                        u === null && (u = void 0);
                                        var m = v.put(u, e);
                                        c.oncomplete = function() {
                                            u === void 0 && (u = null), t(u);
                                        }, c.onabort = c.onerror = function() {
                                            var g = m.error ? m.error : m.transaction.error;
                                            i(g);
                                        };
                                    } catch (g) {
                                        i(g);
                                    }
                                });
                            }).catch(i);
                        });
                        return h(a, r), a;
                    }
                    function Je(e, n) {
                        var r = this;
                        e = D(e);
                        var o = new d(function(a, t) {
                            r.ready().then(function() {
                                Q(r._dbInfo, l, function(i, f) {
                                    if (i) return t(i);
                                    try {
                                        var u = f.objectStore(r._dbInfo.storeName), s = u.delete(e);
                                        f.oncomplete = function() {
                                            a();
                                        }, f.onerror = function() {
                                            t(s.error);
                                        }, f.onabort = function() {
                                            var c = s.error ? s.error : s.transaction.error;
                                            t(c);
                                        };
                                    } catch (c) {
                                        t(c);
                                    }
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function Ze(e) {
                        var n = this, r = new d(function(o, a) {
                            n.ready().then(function() {
                                Q(n._dbInfo, l, function(t, i) {
                                    if (t) return a(t);
                                    try {
                                        var f = i.objectStore(n._dbInfo.storeName), u = f.clear();
                                        i.oncomplete = function() {
                                            o();
                                        }, i.onabort = i.onerror = function() {
                                            var s = u.error ? u.error : u.transaction.error;
                                            a(s);
                                        };
                                    } catch (s) {
                                        a(s);
                                    }
                                });
                            }).catch(a);
                        });
                        return h(r, e), r;
                    }
                    function je(e) {
                        var n = this, r = new d(function(o, a) {
                            n.ready().then(function() {
                                Q(n._dbInfo, Z, function(t, i) {
                                    if (t) return a(t);
                                    try {
                                        var f = i.objectStore(n._dbInfo.storeName), u = f.count();
                                        u.onsuccess = function() {
                                            o(u.result);
                                        }, u.onerror = function() {
                                            a(u.error);
                                        };
                                    } catch (s) {
                                        a(s);
                                    }
                                });
                            }).catch(a);
                        });
                        return h(r, e), r;
                    }
                    function qe(e, n) {
                        var r = this, o = new d(function(a, t) {
                            if (e < 0) {
                                a(null);
                                return;
                            }
                            r.ready().then(function() {
                                Q(r._dbInfo, Z, function(i, f) {
                                    if (i) return t(i);
                                    try {
                                        var u = f.objectStore(r._dbInfo.storeName), s = !1, c = u.openKeyCursor();
                                        c.onsuccess = function() {
                                            var v = c.result;
                                            if (!v) {
                                                a(null);
                                                return;
                                            }
                                            e === 0 || s ? a(v.key) : (s = !0, v.advance(e));
                                        }, c.onerror = function() {
                                            t(c.error);
                                        };
                                    } catch (v) {
                                        t(v);
                                    }
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function ke(e) {
                        var n = this, r = new d(function(o, a) {
                            n.ready().then(function() {
                                Q(n._dbInfo, Z, function(t, i) {
                                    if (t) return a(t);
                                    try {
                                        var f = i.objectStore(n._dbInfo.storeName), u = f.openKeyCursor(), s = [];
                                        u.onsuccess = function() {
                                            var c = u.result;
                                            if (!c) {
                                                o(s);
                                                return;
                                            }
                                            s.push(c.key), c.continue();
                                        }, u.onerror = function() {
                                            a(u.error);
                                        };
                                    } catch (c) {
                                        a(c);
                                    }
                                });
                            }).catch(a);
                        });
                        return h(r, e), r;
                    }
                    function er(e, n) {
                        n = $.apply(this, arguments);
                        var r = this.config();
                        e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
                        var o = this, a;
                        if (!e.name) a = d.reject("Invalid arguments");
                        else {
                            var t = e.name === r.name && o._dbInfo.db, i = t ? d.resolve(o._dbInfo.db) : K(e).then(function(f) {
                                var u = x[e.name], s = u.forages;
                                u.db = f;
                                for(var c = 0; c < s.length; c++)s[c]._dbInfo.db = f;
                                return f;
                            });
                            e.storeName ? a = i.then(function(f) {
                                if (!!f.objectStoreNames.contains(e.storeName)) {
                                    var u = f.version + 1;
                                    O(e);
                                    var s = x[e.name], c = s.forages;
                                    f.close();
                                    for(var v = 0; v < c.length; v++){
                                        var m = c[v];
                                        m._dbInfo.db = null, m._dbInfo.version = u;
                                    }
                                    var g = new d(function(_, N) {
                                        var R = L.open(e.name, u);
                                        R.onerror = function(Y) {
                                            var re = R.result;
                                            re.close(), N(Y);
                                        }, R.onupgradeneeded = function() {
                                            var Y = R.result;
                                            Y.deleteObjectStore(e.storeName);
                                        }, R.onsuccess = function() {
                                            var Y = R.result;
                                            Y.close(), _(Y);
                                        };
                                    });
                                    return g.then(function(_) {
                                        s.db = _;
                                        for(var N = 0; N < c.length; N++){
                                            var R = c[N];
                                            R._dbInfo.db = _, F(R._dbInfo);
                                        }
                                    }).catch(function(_) {
                                        throw (M(e, _) || d.resolve()).catch(function() {}), _;
                                    });
                                }
                            }) : a = i.then(function(f) {
                                O(e);
                                var u = x[e.name], s = u.forages;
                                f.close();
                                for(var c = 0; c < s.length; c++){
                                    var v = s[c];
                                    v._dbInfo.db = null;
                                }
                                var m = new d(function(g, _) {
                                    var N = L.deleteDatabase(e.name);
                                    N.onerror = function() {
                                        var R = N.result;
                                        R && R.close(), _(N.error);
                                    }, N.onblocked = function() {
                                        console.warn('dropInstance blocked for database "' + e.name + '" until all open connections are closed');
                                    }, N.onsuccess = function() {
                                        var R = N.result;
                                        R && R.close(), g(R);
                                    };
                                });
                                return m.then(function(g) {
                                    u.db = g;
                                    for(var _ = 0; _ < s.length; _++){
                                        var N = s[_];
                                        F(N._dbInfo);
                                    }
                                }).catch(function(g) {
                                    throw (M(e, g) || d.resolve()).catch(function() {}), g;
                                });
                            });
                        }
                        return h(a, n), a;
                    }
                    var rr = {
                        _driver: "asyncStorage",
                        _initStorage: Qe,
                        _support: C(),
                        iterate: Ge,
                        getItem: He,
                        setItem: Xe,
                        removeItem: Je,
                        clear: Ze,
                        length: je,
                        key: qe,
                        keys: ke,
                        dropInstance: er
                    };
                    function nr() {
                        return typeof openDatabase == "function";
                    }
                    var X = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", tr = "~~local_forage_type~", be = /^~~local_forage_type~([^~]+)~/, oe = "__lfsc__:", ue = oe.length, se = "arbf", ce = "blob", we = "si08", Ee = "ui08", Se = "uic8", Ie = "si16", Re = "si32", Ae = "ur16", Ne = "ui32", De = "fl32", Te = "fl64", xe = ue + se.length, Be = Object.prototype.toString;
                    function Ce(e) {
                        var n = e.length * .75, r = e.length, o, a = 0, t, i, f, u;
                        e[e.length - 1] === "=" && (n--, e[e.length - 2] === "=" && n--);
                        var s = new ArrayBuffer(n), c = new Uint8Array(s);
                        for(o = 0; o < r; o += 4)t = X.indexOf(e[o]), i = X.indexOf(e[o + 1]), f = X.indexOf(e[o + 2]), u = X.indexOf(e[o + 3]), c[a++] = t << 2 | i >> 4, c[a++] = (i & 15) << 4 | f >> 2, c[a++] = (f & 3) << 6 | u & 63;
                        return s;
                    }
                    function le(e) {
                        var n = new Uint8Array(e), r = "", o;
                        for(o = 0; o < n.length; o += 3)r += X[n[o] >> 2], r += X[(n[o] & 3) << 4 | n[o + 1] >> 4], r += X[(n[o + 1] & 15) << 2 | n[o + 2] >> 6], r += X[n[o + 2] & 63];
                        return n.length % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : n.length % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
                    }
                    function or(e, n) {
                        var r = "";
                        if (e && (r = Be.call(e)), e && (r === "[object ArrayBuffer]" || e.buffer && Be.call(e.buffer) === "[object ArrayBuffer]")) {
                            var o, a = oe;
                            e instanceof ArrayBuffer ? (o = e, a += se) : (o = e.buffer, r === "[object Int8Array]" ? a += we : r === "[object Uint8Array]" ? a += Ee : r === "[object Uint8ClampedArray]" ? a += Se : r === "[object Int16Array]" ? a += Ie : r === "[object Uint16Array]" ? a += Ae : r === "[object Int32Array]" ? a += Re : r === "[object Uint32Array]" ? a += Ne : r === "[object Float32Array]" ? a += De : r === "[object Float64Array]" ? a += Te : n(new Error("Failed to get type for BinaryArray"))), n(a + le(o));
                        } else if (r === "[object Blob]") {
                            var t = new FileReader;
                            t.onload = function() {
                                var i = tr + e.type + "~" + le(this.result);
                                n(oe + ce + i);
                            }, t.readAsArrayBuffer(e);
                        } else try {
                            n(JSON.stringify(e));
                        } catch (i) {
                            console.error("Couldn't convert value into a JSON string: ", e), n(null, i);
                        }
                    }
                    function ar(e) {
                        if (e.substring(0, ue) !== oe) return JSON.parse(e);
                        var n = e.substring(xe), r = e.substring(ue, xe), o;
                        if (r === ce && be.test(n)) {
                            var a = n.match(be);
                            o = a[1], n = n.substring(a[0].length);
                        }
                        var t = Ce(n);
                        switch(r){
                            case se:
                                return t;
                            case ce:
                                return W([
                                    t
                                ], {
                                    type: o
                                });
                            case we:
                                return new Int8Array(t);
                            case Ee:
                                return new Uint8Array(t);
                            case Se:
                                return new Uint8ClampedArray(t);
                            case Ie:
                                return new Int16Array(t);
                            case Ae:
                                return new Uint16Array(t);
                            case Re:
                                return new Int32Array(t);
                            case Ne:
                                return new Uint32Array(t);
                            case De:
                                return new Float32Array(t);
                            case Te:
                                return new Float64Array(t);
                            default:
                                throw new Error("Unkown type: " + r);
                        }
                    }
                    var de = {
                        serialize: or,
                        deserialize: ar,
                        stringToBuffer: Ce,
                        bufferToString: le
                    };
                    function Oe(e, n, r, o) {
                        e.executeSql("CREATE TABLE IF NOT EXISTS " + n.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], r, o);
                    }
                    function ir(e) {
                        var n = this, r = {
                            db: null
                        };
                        if (e) for(var o in e)r[o] = typeof e[o] != "string" ? e[o].toString() : e[o];
                        var a = new d(function(t, i) {
                            try {
                                r.db = openDatabase(r.name, String(r.version), r.description, r.size);
                            } catch (f) {
                                return i(f);
                            }
                            r.db.transaction(function(f) {
                                Oe(f, r, function() {
                                    n._dbInfo = r, t();
                                }, function(u, s) {
                                    i(s);
                                });
                            }, i);
                        });
                        return r.serializer = de, a;
                    }
                    function J(e, n, r, o, a, t) {
                        e.executeSql(r, o, a, function(i, f) {
                            f.code === f.SYNTAX_ERR ? i.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [
                                n.storeName
                            ], function(u, s) {
                                s.rows.length ? t(u, f) : Oe(u, n, function() {
                                    u.executeSql(r, o, a, t);
                                }, t);
                            }, t) : t(i, f);
                        }, t);
                    }
                    function fr(e, n) {
                        var r = this;
                        e = D(e);
                        var o = new d(function(a, t) {
                            r.ready().then(function() {
                                var i = r._dbInfo;
                                i.db.transaction(function(f) {
                                    J(f, i, "SELECT * FROM " + i.storeName + " WHERE key = ? LIMIT 1", [
                                        e
                                    ], function(u, s) {
                                        var c = s.rows.length ? s.rows.item(0).value : null;
                                        c && (c = i.serializer.deserialize(c)), a(c);
                                    }, function(u, s) {
                                        t(s);
                                    });
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function ur(e, n) {
                        var r = this, o = new d(function(a, t) {
                            r.ready().then(function() {
                                var i = r._dbInfo;
                                i.db.transaction(function(f) {
                                    J(f, i, "SELECT * FROM " + i.storeName, [], function(u, s) {
                                        for(var c = s.rows, v = c.length, m = 0; m < v; m++){
                                            var g = c.item(m), _ = g.value;
                                            if (_ && (_ = i.serializer.deserialize(_)), _ = e(_, g.key, m + 1), _ !== void 0) {
                                                a(_);
                                                return;
                                            }
                                        }
                                        a();
                                    }, function(u, s) {
                                        t(s);
                                    });
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function Le(e, n, r, o) {
                        var a = this;
                        e = D(e);
                        var t = new d(function(i, f) {
                            a.ready().then(function() {
                                n === void 0 && (n = null);
                                var u = n, s = a._dbInfo;
                                s.serializer.serialize(n, function(c, v) {
                                    v ? f(v) : s.db.transaction(function(m) {
                                        J(m, s, "INSERT OR REPLACE INTO " + s.storeName + " (key, value) VALUES (?, ?)", [
                                            e,
                                            c
                                        ], function() {
                                            i(u);
                                        }, function(g, _) {
                                            f(_);
                                        });
                                    }, function(m) {
                                        if (m.code === m.QUOTA_ERR) {
                                            if (o > 0) {
                                                i(Le.apply(a, [
                                                    e,
                                                    u,
                                                    r,
                                                    o - 1
                                                ]));
                                                return;
                                            }
                                            f(m);
                                        }
                                    });
                                });
                            }).catch(f);
                        });
                        return h(t, r), t;
                    }
                    function sr(e, n, r) {
                        return Le.apply(this, [
                            e,
                            n,
                            r,
                            1
                        ]);
                    }
                    function cr(e, n) {
                        var r = this;
                        e = D(e);
                        var o = new d(function(a, t) {
                            r.ready().then(function() {
                                var i = r._dbInfo;
                                i.db.transaction(function(f) {
                                    J(f, i, "DELETE FROM " + i.storeName + " WHERE key = ?", [
                                        e
                                    ], function() {
                                        a();
                                    }, function(u, s) {
                                        t(s);
                                    });
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function lr(e) {
                        var n = this, r = new d(function(o, a) {
                            n.ready().then(function() {
                                var t = n._dbInfo;
                                t.db.transaction(function(i) {
                                    J(i, t, "DELETE FROM " + t.storeName, [], function() {
                                        o();
                                    }, function(f, u) {
                                        a(u);
                                    });
                                });
                            }).catch(a);
                        });
                        return h(r, e), r;
                    }
                    function dr(e) {
                        var n = this, r = new d(function(o, a) {
                            n.ready().then(function() {
                                var t = n._dbInfo;
                                t.db.transaction(function(i) {
                                    J(i, t, "SELECT COUNT(key) as c FROM " + t.storeName, [], function(f, u) {
                                        var s = u.rows.item(0).c;
                                        o(s);
                                    }, function(f, u) {
                                        a(u);
                                    });
                                });
                            }).catch(a);
                        });
                        return h(r, e), r;
                    }
                    function vr(e, n) {
                        var r = this, o = new d(function(a, t) {
                            r.ready().then(function() {
                                var i = r._dbInfo;
                                i.db.transaction(function(f) {
                                    J(f, i, "SELECT key FROM " + i.storeName + " WHERE id = ? LIMIT 1", [
                                        e + 1
                                    ], function(u, s) {
                                        var c = s.rows.length ? s.rows.item(0).key : null;
                                        a(c);
                                    }, function(u, s) {
                                        t(s);
                                    });
                                });
                            }).catch(t);
                        });
                        return h(o, n), o;
                    }
                    function hr(e) {
                        var n = this, r = new d(function(o, a) {
                            n.ready().then(function() {
                                var t = n._dbInfo;
                                t.db.transaction(function(i) {
                                    J(i, t, "SELECT key FROM " + t.storeName, [], function(f, u) {
                                        for(var s = [], c = 0; c < u.rows.length; c++)s.push(u.rows.item(c).key);
                                        o(s);
                                    }, function(f, u) {
                                        a(u);
                                    });
                                });
                            }).catch(a);
                        });
                        return h(r, e), r;
                    }
                    function mr(e) {
                        return new d(function(n, r) {
                            e.transaction(function(o) {
                                o.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(a, t) {
                                    for(var i = [], f = 0; f < t.rows.length; f++)i.push(t.rows.item(f).name);
                                    n({
                                        db: e,
                                        storeNames: i
                                    });
                                }, function(a, t) {
                                    r(t);
                                });
                            }, function(o) {
                                r(o);
                            });
                        });
                    }
                    function yr(e, n) {
                        n = $.apply(this, arguments);
                        var r = this.config();
                        e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
                        var o = this, a;
                        return e.name ? a = new d(function(t) {
                            var i;
                            e.name === r.name ? i = o._dbInfo.db : i = openDatabase(e.name, "", "", 0), e.storeName ? t({
                                db: i,
                                storeNames: [
                                    e.storeName
                                ]
                            }) : t(mr(i));
                        }).then(function(t) {
                            return new d(function(i, f) {
                                t.db.transaction(function(u) {
                                    function s(g) {
                                        return new d(function(_, N) {
                                            u.executeSql("DROP TABLE IF EXISTS " + g, [], function() {
                                                _();
                                            }, function(R, Y) {
                                                N(Y);
                                            });
                                        });
                                    }
                                    for(var c = [], v = 0, m = t.storeNames.length; v < m; v++)c.push(s(t.storeNames[v]));
                                    d.all(c).then(function() {
                                        i();
                                    }).catch(function(g) {
                                        f(g);
                                    });
                                }, function(u) {
                                    f(u);
                                });
                            });
                        }) : a = d.reject("Invalid arguments"), h(a, n), a;
                    }
                    var pr = {
                        _driver: "webSQLStorage",
                        _initStorage: ir,
                        _support: nr(),
                        iterate: ur,
                        getItem: fr,
                        setItem: sr,
                        removeItem: cr,
                        clear: lr,
                        length: dr,
                        key: vr,
                        keys: hr,
                        dropInstance: yr
                    };
                    function gr() {
                        try {
                            return typeof localStorage < "u" && "setItem" in localStorage && !!localStorage.setItem;
                        } catch  {
                            return !1;
                        }
                    }
                    function Pe(e, n) {
                        var r = e.name + "/";
                        return e.storeName !== n.storeName && (r += e.storeName + "/"), r;
                    }
                    function _r() {
                        var e = "_localforage_support_test";
                        try {
                            return localStorage.setItem(e, !0), localStorage.removeItem(e), !1;
                        } catch  {
                            return !0;
                        }
                    }
                    function br() {
                        return !_r() || localStorage.length > 0;
                    }
                    function wr(e) {
                        var n = this, r = {};
                        if (e) for(var o in e)r[o] = e[o];
                        return r.keyPrefix = Pe(e, n._defaultConfig), br() ? (n._dbInfo = r, r.serializer = de, d.resolve()) : d.reject();
                    }
                    function Er(e) {
                        var n = this, r = n.ready().then(function() {
                            for(var o = n._dbInfo.keyPrefix, a = localStorage.length - 1; a >= 0; a--){
                                var t = localStorage.key(a);
                                t.indexOf(o) === 0 && localStorage.removeItem(t);
                            }
                        });
                        return h(r, e), r;
                    }
                    function Sr(e, n) {
                        var r = this;
                        e = D(e);
                        var o = r.ready().then(function() {
                            var a = r._dbInfo, t = localStorage.getItem(a.keyPrefix + e);
                            return t && (t = a.serializer.deserialize(t)), t;
                        });
                        return h(o, n), o;
                    }
                    function Ir(e, n) {
                        var r = this, o = r.ready().then(function() {
                            for(var a = r._dbInfo, t = a.keyPrefix, i = t.length, f = localStorage.length, u = 1, s = 0; s < f; s++){
                                var c = localStorage.key(s);
                                if (c.indexOf(t) === 0) {
                                    var v = localStorage.getItem(c);
                                    if (v && (v = a.serializer.deserialize(v)), v = e(v, c.substring(i), u++), v !== void 0) return v;
                                }
                            }
                        });
                        return h(o, n), o;
                    }
                    function Rr(e, n) {
                        var r = this, o = r.ready().then(function() {
                            var a = r._dbInfo, t;
                            try {
                                t = localStorage.key(e);
                            } catch  {
                                t = null;
                            }
                            return t && (t = t.substring(a.keyPrefix.length)), t;
                        });
                        return h(o, n), o;
                    }
                    function Ar(e) {
                        var n = this, r = n.ready().then(function() {
                            for(var o = n._dbInfo, a = localStorage.length, t = [], i = 0; i < a; i++){
                                var f = localStorage.key(i);
                                f.indexOf(o.keyPrefix) === 0 && t.push(f.substring(o.keyPrefix.length));
                            }
                            return t;
                        });
                        return h(r, e), r;
                    }
                    function Nr(e) {
                        var n = this, r = n.keys().then(function(o) {
                            return o.length;
                        });
                        return h(r, e), r;
                    }
                    function Dr(e, n) {
                        var r = this;
                        e = D(e);
                        var o = r.ready().then(function() {
                            var a = r._dbInfo;
                            localStorage.removeItem(a.keyPrefix + e);
                        });
                        return h(o, n), o;
                    }
                    function Tr(e, n, r) {
                        var o = this;
                        e = D(e);
                        var a = o.ready().then(function() {
                            n === void 0 && (n = null);
                            var t = n;
                            return new d(function(i, f) {
                                var u = o._dbInfo;
                                u.serializer.serialize(n, function(s, c) {
                                    if (c) f(c);
                                    else try {
                                        localStorage.setItem(u.keyPrefix + e, s), i(t);
                                    } catch (v) {
                                        (v.name === "QuotaExceededError" || v.name === "NS_ERROR_DOM_QUOTA_REACHED") && f(v), f(v);
                                    }
                                });
                            });
                        });
                        return h(a, r), a;
                    }
                    function xr(e, n) {
                        if (n = $.apply(this, arguments), e = typeof e != "function" && e || {}, !e.name) {
                            var r = this.config();
                            e.name = e.name || r.name, e.storeName = e.storeName || r.storeName;
                        }
                        var o = this, a;
                        return e.name ? a = new d(function(t) {
                            e.storeName ? t(Pe(e, o._defaultConfig)) : t(e.name + "/");
                        }).then(function(t) {
                            for(var i = localStorage.length - 1; i >= 0; i--){
                                var f = localStorage.key(i);
                                f.indexOf(t) === 0 && localStorage.removeItem(f);
                            }
                        }) : a = d.reject("Invalid arguments"), h(a, n), a;
                    }
                    var Br = {
                        _driver: "localStorageWrapper",
                        _initStorage: wr,
                        _support: gr(),
                        iterate: Ir,
                        getItem: Sr,
                        setItem: Tr,
                        removeItem: Dr,
                        clear: Er,
                        length: Nr,
                        key: Rr,
                        keys: Ar,
                        dropInstance: xr
                    }, Cr = function(n, r) {
                        return n === r || typeof n == "number" && typeof r == "number" && isNaN(n) && isNaN(r);
                    }, Or = function(n, r) {
                        for(var o = n.length, a = 0; a < o;){
                            if (Cr(n[a], r)) return !0;
                            a++;
                        }
                        return !1;
                    }, Fe = Array.isArray || function(e) {
                        return Object.prototype.toString.call(e) === "[object Array]";
                    }, ee = {}, Me = {}, q = {
                        INDEXEDDB: rr,
                        WEBSQL: pr,
                        LOCALSTORAGE: Br
                    }, Lr = [
                        q.INDEXEDDB._driver,
                        q.WEBSQL._driver,
                        q.LOCALSTORAGE._driver
                    ], ae = [
                        "dropInstance"
                    ], ve = [
                        "clear",
                        "getItem",
                        "iterate",
                        "key",
                        "keys",
                        "length",
                        "removeItem",
                        "setItem"
                    ].concat(ae), Pr = {
                        description: "",
                        driver: Lr.slice(),
                        name: "localforage",
                        size: 4980736,
                        storeName: "keyvaluepairs",
                        version: 1
                    };
                    function Fr(e, n) {
                        e[n] = function() {
                            var r = arguments;
                            return e.ready().then(function() {
                                return e[n].apply(e, r);
                            });
                        };
                    }
                    function he() {
                        for(var e = 1; e < arguments.length; e++){
                            var n = arguments[e];
                            if (n) for(var r in n)n.hasOwnProperty(r) && (Fe(n[r]) ? arguments[0][r] = n[r].slice() : arguments[0][r] = n[r]);
                        }
                        return arguments[0];
                    }
                    var Mr = function() {
                        function e(n) {
                            P(this, e);
                            for(var r in q)if (q.hasOwnProperty(r)) {
                                var o = q[r], a = o._driver;
                                this[r] = a, ee[a] || this.defineDriver(o);
                            }
                            this._defaultConfig = he({}, Pr), this._config = he({}, this._defaultConfig, n), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {});
                        }
                        return e.prototype.config = function(r) {
                            if ((typeof r > "u" ? "undefined" : I(r)) === "object") {
                                if (this._ready) return new Error("Can't call config() after localforage has been used.");
                                for(var o in r){
                                    if (o === "storeName" && (r[o] = r[o].replace(/\W/g, "_")), o === "version" && typeof r[o] != "number") return new Error("Database version must be a number.");
                                    this._config[o] = r[o];
                                }
                                return "driver" in r && r.driver ? this.setDriver(this._config.driver) : !0;
                            } else return typeof r == "string" ? this._config[r] : this._config;
                        }, e.prototype.defineDriver = function(r, o, a) {
                            var t = new d(function(i, f) {
                                try {
                                    var u = r._driver, s = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                                    if (!r._driver) {
                                        f(s);
                                        return;
                                    }
                                    for(var c = ve.concat("_initStorage"), v = 0, m = c.length; v < m; v++){
                                        var g = c[v], _ = !Or(ae, g);
                                        if ((_ || r[g]) && typeof r[g] != "function") {
                                            f(s);
                                            return;
                                        }
                                    }
                                    var N = function() {
                                        for(var re = function(zr) {
                                            return function() {
                                                var Wr = new Error("Method " + zr + " is not implemented by the current driver"), Ue = d.reject(Wr);
                                                return h(Ue, arguments[arguments.length - 1]), Ue;
                                            };
                                        }, me = 0, Yr = ae.length; me < Yr; me++){
                                            var ye = ae[me];
                                            r[ye] || (r[ye] = re(ye));
                                        }
                                    };
                                    N();
                                    var R = function(re) {
                                        ee[u] && console.info("Redefining LocalForage driver: " + u), ee[u] = r, Me[u] = re, i();
                                    };
                                    "_support" in r ? r._support && typeof r._support == "function" ? r._support().then(R, f) : R(!!r._support) : R(!0);
                                } catch (Y) {
                                    f(Y);
                                }
                            });
                            return A(t, o, a), t;
                        }, e.prototype.driver = function() {
                            return this._driver || null;
                        }, e.prototype.getDriver = function(r, o, a) {
                            var t = ee[r] ? d.resolve(ee[r]) : d.reject(new Error("Driver not found."));
                            return A(t, o, a), t;
                        }, e.prototype.getSerializer = function(r) {
                            var o = d.resolve(de);
                            return A(o, r), o;
                        }, e.prototype.ready = function(r) {
                            var o = this, a = o._driverSet.then(function() {
                                return o._ready === null && (o._ready = o._initDriver()), o._ready;
                            });
                            return A(a, r, r), a;
                        }, e.prototype.setDriver = function(r, o, a) {
                            var t = this;
                            Fe(r) || (r = [
                                r
                            ]);
                            var i = this._getSupportedDrivers(r);
                            function f() {
                                t._config.driver = t.driver();
                            }
                            function u(v) {
                                return t._extend(v), f(), t._ready = t._initStorage(t._config), t._ready;
                            }
                            function s(v) {
                                return function() {
                                    var m = 0;
                                    function g() {
                                        for(; m < v.length;){
                                            var _ = v[m];
                                            return m++, t._dbInfo = null, t._ready = null, t.getDriver(_).then(u).catch(g);
                                        }
                                        f();
                                        var N = new Error("No available storage method found.");
                                        return t._driverSet = d.reject(N), t._driverSet;
                                    }
                                    return g();
                                };
                            }
                            var c = this._driverSet !== null ? this._driverSet.catch(function() {
                                return d.resolve();
                            }) : d.resolve();
                            return this._driverSet = c.then(function() {
                                var v = i[0];
                                return t._dbInfo = null, t._ready = null, t.getDriver(v).then(function(m) {
                                    t._driver = m._driver, f(), t._wrapLibraryMethodsWithReady(), t._initDriver = s(i);
                                });
                            }).catch(function() {
                                f();
                                var v = new Error("No available storage method found.");
                                return t._driverSet = d.reject(v), t._driverSet;
                            }), A(this._driverSet, o, a), this._driverSet;
                        }, e.prototype.supports = function(r) {
                            return !!Me[r];
                        }, e.prototype._extend = function(r) {
                            he(this, r);
                        }, e.prototype._getSupportedDrivers = function(r) {
                            for(var o = [], a = 0, t = r.length; a < t; a++){
                                var i = r[a];
                                this.supports(i) && o.push(i);
                            }
                            return o;
                        }, e.prototype._wrapLibraryMethodsWithReady = function() {
                            for(var r = 0, o = ve.length; r < o; r++)Fr(this, ve[r]);
                        }, e.prototype.createInstance = function(r) {
                            return new e(r);
                        }, e;
                    }(), Ur = new Mr;
                    B.exports = Ur;
                },
                {
                    3: 3
                }
            ]
        }, {}, [
            4
        ])(4);
    });
});
var Zr = Jr(We2()), { default: $e5 , ...jr } = Zr, rn = $e5 !== void 0 ? $e5 : jr;
function _e8(e) {
    let i = e.length;
    for(; --i >= 0;)e[i] = 0;
}
var $i = 0, ai = 1, Ci = 2, Fi = 3, Mi1 = 258, dt = 29, Ae5 = 256, ge7 = Ae5 + 1 + dt, oe7 = 30, st = 19, ni = 2 * ge7 + 1, Q10 = 15, Ge2 = 16, Hi = 7, ct = 256, li = 16, ri = 17, fi = 18, ft = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
]), $e6 = new Uint8Array([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
]), Bi = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
]), oi = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), Ki = 512, B9 = new Array((ge7 + 2) * 2);
_e8(B9);
var ue2 = new Array(oe7 * 2);
_e8(ue2);
var pe9 = new Array(Ki);
_e8(pe9);
var xe6 = new Array(Mi1 - Fi + 1);
_e8(xe6);
var ut = new Array(dt);
_e8(ut);
var He2 = new Array(oe7);
_e8(He2);
function je4(e, i, t, n, a) {
    this.static_tree = e, this.extra_bits = i, this.extra_base = t, this.elems = n, this.max_length = a, this.has_stree = e && e.length;
}
var _i, hi, di;
function We3(e, i) {
    this.dyn_tree = e, this.max_code = 0, this.stat_desc = i;
}
var si = (e)=>e < 256 ? pe9[e] : pe9[256 + (e >>> 7)], ke4 = (e, i)=>{
    e.pending_buf[e.pending++] = i & 255, e.pending_buf[e.pending++] = i >>> 8 & 255;
}, N3 = (e, i, t)=>{
    e.bi_valid > Ge2 - t ? (e.bi_buf |= i << e.bi_valid & 65535, ke4(e, e.bi_buf), e.bi_buf = i >> Ge2 - e.bi_valid, e.bi_valid += t - Ge2) : (e.bi_buf |= i << e.bi_valid & 65535, e.bi_valid += t);
}, F5 = (e, i, t)=>{
    N3(e, t[i * 2], t[i * 2 + 1]);
}, ci = (e, i)=>{
    let t = 0;
    do t |= e & 1, e >>>= 1, t <<= 1;
    while (--i > 0)
    return t >>> 1;
}, Pi = (e)=>{
    e.bi_valid === 16 ? (ke4(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, Xi = (e, i)=>{
    let t = i.dyn_tree, n = i.max_code, a = i.stat_desc.static_tree, l = i.stat_desc.has_stree, o = i.stat_desc.extra_bits, f = i.stat_desc.extra_base, c = i.stat_desc.max_length, r, _, E, s, h, u, m = 0;
    for(s = 0; s <= Q10; s++)e.bl_count[s] = 0;
    for(t[e.heap[e.heap_max] * 2 + 1] = 0, r = e.heap_max + 1; r < ni; r++)_ = e.heap[r], s = t[t[_ * 2 + 1] * 2 + 1] + 1, s > c && (s = c, m++), t[_ * 2 + 1] = s, !(_ > n) && (e.bl_count[s]++, h = 0, _ >= f && (h = o[_ - f]), u = t[_ * 2], e.opt_len += u * (s + h), l && (e.static_len += u * (a[_ * 2 + 1] + h)));
    if (m !== 0) {
        do {
            for(s = c - 1; e.bl_count[s] === 0;)s--;
            e.bl_count[s]--, e.bl_count[s + 1] += 2, e.bl_count[c]--, m -= 2;
        }while (m > 0)
        for(s = c; s !== 0; s--)for(_ = e.bl_count[s]; _ !== 0;)E = e.heap[--r], !(E > n) && (t[E * 2 + 1] !== s && (e.opt_len += (s - t[E * 2 + 1]) * t[E * 2], t[E * 2 + 1] = s), _--);
    }
}, ui = (e, i, t)=>{
    let n = new Array(Q10 + 1), a = 0, l, o;
    for(l = 1; l <= Q10; l++)n[l] = a = a + t[l - 1] << 1;
    for(o = 0; o <= i; o++){
        let f = e[o * 2 + 1];
        f !== 0 && (e[o * 2] = ci(n[f]++, f));
    }
}, Yi = ()=>{
    let e, i, t, n, a, l = new Array(Q10 + 1);
    for(t = 0, n = 0; n < dt - 1; n++)for(ut[n] = t, e = 0; e < 1 << ft[n]; e++)xe6[t++] = n;
    for(xe6[t - 1] = n, a = 0, n = 0; n < 16; n++)for(He2[n] = a, e = 0; e < 1 << $e6[n]; e++)pe9[a++] = n;
    for(a >>= 7; n < oe7; n++)for(He2[n] = a << 7, e = 0; e < 1 << $e6[n] - 7; e++)pe9[256 + a++] = n;
    for(i = 0; i <= Q10; i++)l[i] = 0;
    for(e = 0; e <= 143;)B9[e * 2 + 1] = 8, e++, l[8]++;
    for(; e <= 255;)B9[e * 2 + 1] = 9, e++, l[9]++;
    for(; e <= 279;)B9[e * 2 + 1] = 7, e++, l[7]++;
    for(; e <= 287;)B9[e * 2 + 1] = 8, e++, l[8]++;
    for(ui(B9, ge7 + 1, l), e = 0; e < oe7; e++)ue2[e * 2 + 1] = 5, ue2[e * 2] = ci(e, 5);
    _i = new je4(B9, ft, Ae5 + 1, ge7, Q10), hi = new je4(ue2, $e6, 0, oe7, Q10), di = new je4(new Array(0), Bi, 0, st, Hi);
}, bi = (e)=>{
    let i;
    for(i = 0; i < ge7; i++)e.dyn_ltree[i * 2] = 0;
    for(i = 0; i < oe7; i++)e.dyn_dtree[i * 2] = 0;
    for(i = 0; i < st; i++)e.bl_tree[i * 2] = 0;
    e.dyn_ltree[ct * 2] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
}, wi = (e)=>{
    e.bi_valid > 8 ? ke4(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Gi = (e, i, t, n)=>{
    wi(e), n && (ke4(e, t), ke4(e, ~t)), e.pending_buf.set(e.window.subarray(i, i + t), e.pending), e.pending += t;
}, xt = (e, i, t, n)=>{
    let a = i * 2, l = t * 2;
    return e[a] < e[l] || e[a] === e[l] && n[i] <= n[t];
}, Ve1 = (e, i, t)=>{
    let n = e.heap[t], a = t << 1;
    for(; a <= e.heap_len && (a < e.heap_len && xt(i, e.heap[a + 1], e.heap[a], e.depth) && a++, !xt(i, n, e.heap[a], e.depth));)e.heap[t] = e.heap[a], t = a, a <<= 1;
    e.heap[t] = n;
}, kt = (e, i, t)=>{
    let n, a, l = 0, o, f;
    if (e.last_lit !== 0) do n = e.pending_buf[e.d_buf + l * 2] << 8 | e.pending_buf[e.d_buf + l * 2 + 1], a = e.pending_buf[e.l_buf + l], l++, n === 0 ? F5(e, a, i) : (o = xe6[a], F5(e, o + Ae5 + 1, i), f = ft[o], f !== 0 && (a -= ut[o], N3(e, a, f)), n--, o = si(n), F5(e, o, t), f = $e6[o], f !== 0 && (n -= He2[o], N3(e, n, f)));
    while (l < e.last_lit)
    F5(e, ct, i);
}, ot = (e, i)=>{
    let t = i.dyn_tree, n = i.stat_desc.static_tree, a = i.stat_desc.has_stree, l = i.stat_desc.elems, o, f, c = -1, r;
    for(e.heap_len = 0, e.heap_max = ni, o = 0; o < l; o++)t[o * 2] !== 0 ? (e.heap[++e.heap_len] = c = o, e.depth[o] = 0) : t[o * 2 + 1] = 0;
    for(; e.heap_len < 2;)r = e.heap[++e.heap_len] = c < 2 ? ++c : 0, t[r * 2] = 1, e.depth[r] = 0, e.opt_len--, a && (e.static_len -= n[r * 2 + 1]);
    for(i.max_code = c, o = e.heap_len >> 1; o >= 1; o--)Ve1(e, t, o);
    r = l;
    do o = e.heap[1], e.heap[1] = e.heap[e.heap_len--], Ve1(e, t, 1), f = e.heap[1], e.heap[--e.heap_max] = o, e.heap[--e.heap_max] = f, t[r * 2] = t[o * 2] + t[f * 2], e.depth[r] = (e.depth[o] >= e.depth[f] ? e.depth[o] : e.depth[f]) + 1, t[o * 2 + 1] = t[f * 2 + 1] = r, e.heap[1] = r++, Ve1(e, t, 1);
    while (e.heap_len >= 2)
    e.heap[--e.heap_max] = e.heap[1], Xi(e, i), ui(t, c, e.bl_count);
}, vt = (e, i, t)=>{
    let n, a = -1, l, o = i[0 * 2 + 1], f = 0, c = 7, r = 4;
    for(o === 0 && (c = 138, r = 3), i[(t + 1) * 2 + 1] = 65535, n = 0; n <= t; n++)l = o, o = i[(n + 1) * 2 + 1], !(++f < c && l === o) && (f < r ? e.bl_tree[l * 2] += f : l !== 0 ? (l !== a && e.bl_tree[l * 2]++, e.bl_tree[li * 2]++) : f <= 10 ? e.bl_tree[ri * 2]++ : e.bl_tree[fi * 2]++, f = 0, a = l, o === 0 ? (c = 138, r = 3) : l === o ? (c = 6, r = 3) : (c = 7, r = 4));
}, Et = (e, i, t)=>{
    let n, a = -1, l, o = i[0 * 2 + 1], f = 0, c = 7, r = 4;
    for(o === 0 && (c = 138, r = 3), n = 0; n <= t; n++)if (l = o, o = i[(n + 1) * 2 + 1], !(++f < c && l === o)) {
        if (f < r) do F5(e, l, e.bl_tree);
        while (--f !== 0)
        else l !== 0 ? (l !== a && (F5(e, l, e.bl_tree), f--), F5(e, li, e.bl_tree), N3(e, f - 3, 2)) : f <= 10 ? (F5(e, ri, e.bl_tree), N3(e, f - 3, 3)) : (F5(e, fi, e.bl_tree), N3(e, f - 11, 7));
        f = 0, a = l, o === 0 ? (c = 138, r = 3) : l === o ? (c = 6, r = 3) : (c = 7, r = 4);
    }
}, ji = (e)=>{
    let i;
    for(vt(e, e.dyn_ltree, e.l_desc.max_code), vt(e, e.dyn_dtree, e.d_desc.max_code), ot(e, e.bl_desc), i = st - 1; i >= 3 && e.bl_tree[oi[i] * 2 + 1] === 0; i--);
    return e.opt_len += 3 * (i + 1) + 5 + 5 + 4, i;
}, Wi = (e, i, t, n)=>{
    let a;
    for(N3(e, i - 257, 5), N3(e, t - 1, 5), N3(e, n - 4, 4), a = 0; a < n; a++)N3(e, e.bl_tree[oi[a] * 2 + 1], 3);
    Et(e, e.dyn_ltree, i - 1), Et(e, e.dyn_dtree, t - 1);
}, Vi = (e)=>{
    let i = 4093624447, t;
    for(t = 0; t <= 31; t++, i >>>= 1)if (i & 1 && e.dyn_ltree[t * 2] !== 0) return 0;
    if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0) return 1;
    for(t = 32; t < Ae5; t++)if (e.dyn_ltree[t * 2] !== 0) return 1;
    return 0;
}, yt = !1, Ji = (e)=>{
    yt || (Yi(), yt = !0), e.l_desc = new We3(e.dyn_ltree, _i), e.d_desc = new We3(e.dyn_dtree, hi), e.bl_desc = new We3(e.bl_tree, di), e.bi_buf = 0, e.bi_valid = 0, bi(e);
}, gi = (e, i, t, n)=>{
    N3(e, ($i << 1) + (n ? 1 : 0), 3), Gi(e, i, t, !0);
}, Qi = (e)=>{
    N3(e, ai << 1, 3), F5(e, ct, B9), Pi(e);
}, qi = (e, i, t, n)=>{
    let a, l, o = 0;
    e.level > 0 ? (e.strm.data_type === 2 && (e.strm.data_type = Vi(e)), ot(e, e.l_desc), ot(e, e.d_desc), o = ji(e), a = e.opt_len + 3 + 7 >>> 3, l = e.static_len + 3 + 7 >>> 3, l <= a && (a = l)) : a = l = t + 5, t + 4 <= a && i !== -1 ? gi(e, i, t, n) : e.strategy === 4 || l === a ? (N3(e, (ai << 1) + (n ? 1 : 0), 3), kt(e, B9, ue2)) : (N3(e, (Ci << 1) + (n ? 1 : 0), 3), Wi(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1), kt(e, e.dyn_ltree, e.dyn_dtree)), bi(e), n && wi(e);
}, ea = (e, i, t)=>(e.pending_buf[e.d_buf + e.last_lit * 2] = i >>> 8 & 255, e.pending_buf[e.d_buf + e.last_lit * 2 + 1] = i & 255, e.pending_buf[e.l_buf + e.last_lit] = t & 255, e.last_lit++, i === 0 ? e.dyn_ltree[t * 2]++ : (e.matches++, i--, e.dyn_ltree[(xe6[t] + Ae5 + 1) * 2]++, e.dyn_dtree[si(i) * 2]++), e.last_lit === e.lit_bufsize - 1), ta = Ji, ia = gi, aa = qi, na = ea, la = Qi, ra = {
    _tr_init: ta,
    _tr_stored_block: ia,
    _tr_flush_block: aa,
    _tr_tally: na,
    _tr_align: la
}, fa = (e, i, t, n)=>{
    let a = e & 65535 | 0, l = e >>> 16 & 65535 | 0, o = 0;
    for(; t !== 0;){
        o = t > 2e3 ? 2e3 : t, t -= o;
        do a = a + i[n++] | 0, l = l + a | 0;
        while (--o)
        a %= 65521, l %= 65521;
    }
    return a | l << 16 | 0;
}, ve5 = fa, oa = ()=>{
    let e, i = [];
    for(var t = 0; t < 256; t++){
        e = t;
        for(var n = 0; n < 8; n++)e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
        i[t] = e;
    }
    return i;
}, _a = new Uint32Array(oa()), ha = (e, i, t, n)=>{
    let a = _a, l = n + t;
    e ^= -1;
    for(let o = n; o < l; o++)e = e >>> 8 ^ a[(e ^ i[o]) & 255];
    return e ^ -1;
}, I7 = ha, ee10 = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
}, ne8 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
}, { _tr_init: da , _tr_stored_block: sa , _tr_flush_block: ca , _tr_tally: j9 , _tr_align: ua  } = ra, { Z_NO_FLUSH: le6 , Z_PARTIAL_FLUSH: ba , Z_FULL_FLUSH: wa , Z_FINISH: W10 , Z_BLOCK: St , Z_OK: M7 , Z_STREAM_END: At , Z_STREAM_ERROR: L7 , Z_DATA_ERROR: ga , Z_BUF_ERROR: Je1 , Z_DEFAULT_COMPRESSION: pa , Z_FILTERED: xa , Z_HUFFMAN_ONLY: Ie4 , Z_RLE: ka , Z_FIXED: va , Z_DEFAULT_STRATEGY: Ea , Z_UNKNOWN: ya , Z_DEFLATED: Pe7  } = ne8, Sa = 9, Aa = 15, Ra = 8, za = 29, Ta = 256, _t = Ta + 1 + za, ma = 30, Da = 19, Za = 2 * _t + 1, Ia = 15, k2 = 3, Y8 = 258, $9 = Y8 + k2 + 1, Oa = 32, Xe1 = 42, ht = 69, Ce9 = 73, Fe5 = 91, Me7 = 103, q8 = 113, se6 = 666, D5 = 1, Re4 = 2, te8 = 3, he5 = 4, Na = 3, G8 = (e, i)=>(e.msg = ee10[i], i), Rt = (e)=>(e << 1) - (e > 4 ? 9 : 0), X11 = (e)=>{
    let i = e.length;
    for(; --i >= 0;)e[i] = 0;
}, La = (e, i, t)=>(i << e.hash_shift ^ t) & e.hash_mask, V5 = La, P8 = (e)=>{
    let i = e.state, t = i.pending;
    t > e.avail_out && (t = e.avail_out), t !== 0 && (e.output.set(i.pending_buf.subarray(i.pending_out, i.pending_out + t), e.next_out), e.next_out += t, i.pending_out += t, e.total_out += t, e.avail_out -= t, i.pending -= t, i.pending === 0 && (i.pending_out = 0));
}, O11 = (e, i)=>{
    ca(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, i), e.block_start = e.strstart, P8(e.strm);
}, y4 = (e, i)=>{
    e.pending_buf[e.pending++] = i;
}, de8 = (e, i)=>{
    e.pending_buf[e.pending++] = i >>> 8 & 255, e.pending_buf[e.pending++] = i & 255;
}, Ua = (e, i, t, n)=>{
    let a = e.avail_in;
    return a > n && (a = n), a === 0 ? 0 : (e.avail_in -= a, i.set(e.input.subarray(e.next_in, e.next_in + a), t), e.state.wrap === 1 ? e.adler = ve5(e.adler, i, a, t) : e.state.wrap === 2 && (e.adler = I7(e.adler, i, a, t)), e.next_in += a, e.total_in += a, a);
}, pi = (e, i)=>{
    let t = e.max_chain_length, n = e.strstart, a, l, o = e.prev_length, f = e.nice_match, c = e.strstart > e.w_size - $9 ? e.strstart - (e.w_size - $9) : 0, r = e.window, _ = e.w_mask, E = e.prev, s = e.strstart + Y8, h = r[n + o - 1], u = r[n + o];
    e.prev_length >= e.good_match && (t >>= 2), f > e.lookahead && (f = e.lookahead);
    do if (a = i, !(r[a + o] !== u || r[a + o - 1] !== h || r[a] !== r[n] || r[++a] !== r[n + 1])) {
        n += 2, a++;
        do ;
        while (r[++n] === r[++a] && r[++n] === r[++a] && r[++n] === r[++a] && r[++n] === r[++a] && r[++n] === r[++a] && r[++n] === r[++a] && r[++n] === r[++a] && r[++n] === r[++a] && n < s)
        if (l = Y8 - (s - n), n = s - Y8, l > o) {
            if (e.match_start = i, o = l, l >= f) break;
            h = r[n + o - 1], u = r[n + o];
        }
    }
    while ((i = E[i & _]) > c && --t !== 0)
    return o <= e.lookahead ? o : e.lookahead;
}, ie6 = (e)=>{
    let i = e.w_size, t, n, a, l, o;
    do {
        if (l = e.window_size - e.lookahead - e.strstart, e.strstart >= i + (i - $9)) {
            e.window.set(e.window.subarray(i, i + i), 0), e.match_start -= i, e.strstart -= i, e.block_start -= i, n = e.hash_size, t = n;
            do a = e.head[--t], e.head[t] = a >= i ? a - i : 0;
            while (--n)
            n = i, t = n;
            do a = e.prev[--t], e.prev[t] = a >= i ? a - i : 0;
            while (--n)
            l += i;
        }
        if (e.strm.avail_in === 0) break;
        if (n = Ua(e.strm, e.window, e.strstart + e.lookahead, l), e.lookahead += n, e.lookahead + e.insert >= k2) for(o = e.strstart - e.insert, e.ins_h = e.window[o], e.ins_h = V5(e, e.ins_h, e.window[o + 1]); e.insert && (e.ins_h = V5(e, e.ins_h, e.window[o + k2 - 1]), e.prev[o & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = o, o++, e.insert--, !(e.lookahead + e.insert < k2)););
    }while (e.lookahead < $9 && e.strm.avail_in !== 0)
}, $a = (e, i)=>{
    let t = 65535;
    for(t > e.pending_buf_size - 5 && (t = e.pending_buf_size - 5);;){
        if (e.lookahead <= 1) {
            if (ie6(e), e.lookahead === 0 && i === le6) return D5;
            if (e.lookahead === 0) break;
        }
        e.strstart += e.lookahead, e.lookahead = 0;
        let n = e.block_start + t;
        if ((e.strstart === 0 || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, O11(e, !1), e.strm.avail_out === 0) || e.strstart - e.block_start >= e.w_size - $9 && (O11(e, !1), e.strm.avail_out === 0)) return D5;
    }
    return e.insert = 0, i === W10 ? (O11(e, !0), e.strm.avail_out === 0 ? te8 : he5) : (e.strstart > e.block_start && (O11(e, !1), e.strm.avail_out === 0), D5);
}, Qe = (e, i)=>{
    let t, n;
    for(;;){
        if (e.lookahead < $9) {
            if (ie6(e), e.lookahead < $9 && i === le6) return D5;
            if (e.lookahead === 0) break;
        }
        if (t = 0, e.lookahead >= k2 && (e.ins_h = V5(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), t !== 0 && e.strstart - t <= e.w_size - $9 && (e.match_length = pi(e, t)), e.match_length >= k2) if (n = j9(e, e.strstart - e.match_start, e.match_length - k2), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= k2) {
            e.match_length--;
            do e.strstart++, e.ins_h = V5(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
            while (--e.match_length !== 0)
            e.strstart++;
        } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = V5(e, e.ins_h, e.window[e.strstart + 1]);
        else n = j9(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
        if (n && (O11(e, !1), e.strm.avail_out === 0)) return D5;
    }
    return e.insert = e.strstart < k2 - 1 ? e.strstart : k2 - 1, i === W10 ? (O11(e, !0), e.strm.avail_out === 0 ? te8 : he5) : e.last_lit && (O11(e, !1), e.strm.avail_out === 0) ? D5 : Re4;
}, re6 = (e, i)=>{
    let t, n, a;
    for(;;){
        if (e.lookahead < $9) {
            if (ie6(e), e.lookahead < $9 && i === le6) return D5;
            if (e.lookahead === 0) break;
        }
        if (t = 0, e.lookahead >= k2 && (e.ins_h = V5(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = k2 - 1, t !== 0 && e.prev_length < e.max_lazy_match && e.strstart - t <= e.w_size - $9 && (e.match_length = pi(e, t), e.match_length <= 5 && (e.strategy === xa || e.match_length === k2 && e.strstart - e.match_start > 4096) && (e.match_length = k2 - 1)), e.prev_length >= k2 && e.match_length <= e.prev_length) {
            a = e.strstart + e.lookahead - k2, n = j9(e, e.strstart - 1 - e.prev_match, e.prev_length - k2), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
            do ++e.strstart <= a && (e.ins_h = V5(e, e.ins_h, e.window[e.strstart + k2 - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
            while (--e.prev_length !== 0)
            if (e.match_available = 0, e.match_length = k2 - 1, e.strstart++, n && (O11(e, !1), e.strm.avail_out === 0)) return D5;
        } else if (e.match_available) {
            if (n = j9(e, 0, e.window[e.strstart - 1]), n && O11(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0) return D5;
        } else e.match_available = 1, e.strstart++, e.lookahead--;
    }
    return e.match_available && (n = j9(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < k2 - 1 ? e.strstart : k2 - 1, i === W10 ? (O11(e, !0), e.strm.avail_out === 0 ? te8 : he5) : e.last_lit && (O11(e, !1), e.strm.avail_out === 0) ? D5 : Re4;
}, Ca = (e, i)=>{
    let t, n, a, l, o = e.window;
    for(;;){
        if (e.lookahead <= Y8) {
            if (ie6(e), e.lookahead <= Y8 && i === le6) return D5;
            if (e.lookahead === 0) break;
        }
        if (e.match_length = 0, e.lookahead >= k2 && e.strstart > 0 && (a = e.strstart - 1, n = o[a], n === o[++a] && n === o[++a] && n === o[++a])) {
            l = e.strstart + Y8;
            do ;
            while (n === o[++a] && n === o[++a] && n === o[++a] && n === o[++a] && n === o[++a] && n === o[++a] && n === o[++a] && n === o[++a] && a < l)
            e.match_length = Y8 - (l - a), e.match_length > e.lookahead && (e.match_length = e.lookahead);
        }
        if (e.match_length >= k2 ? (t = j9(e, 1, e.match_length - k2), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (t = j9(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), t && (O11(e, !1), e.strm.avail_out === 0)) return D5;
    }
    return e.insert = 0, i === W10 ? (O11(e, !0), e.strm.avail_out === 0 ? te8 : he5) : e.last_lit && (O11(e, !1), e.strm.avail_out === 0) ? D5 : Re4;
}, Fa = (e, i)=>{
    let t;
    for(;;){
        if (e.lookahead === 0 && (ie6(e), e.lookahead === 0)) {
            if (i === le6) return D5;
            break;
        }
        if (e.match_length = 0, t = j9(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, t && (O11(e, !1), e.strm.avail_out === 0)) return D5;
    }
    return e.insert = 0, i === W10 ? (O11(e, !0), e.strm.avail_out === 0 ? te8 : he5) : e.last_lit && (O11(e, !1), e.strm.avail_out === 0) ? D5 : Re4;
};
function C5(e, i, t, n, a) {
    this.good_length = e, this.max_lazy = i, this.nice_length = t, this.max_chain = n, this.func = a;
}
var ce5 = [
    new C5(0, 0, 0, 0, $a),
    new C5(4, 4, 8, 4, Qe),
    new C5(4, 5, 16, 8, Qe),
    new C5(4, 6, 32, 32, Qe),
    new C5(4, 4, 16, 16, re6),
    new C5(8, 16, 32, 32, re6),
    new C5(8, 16, 128, 128, re6),
    new C5(8, 32, 128, 256, re6),
    new C5(32, 128, 258, 1024, re6),
    new C5(32, 258, 258, 4096, re6)
], Ma = (e)=>{
    e.window_size = 2 * e.w_size, X11(e.head), e.max_lazy_match = ce5[e.level].max_lazy, e.good_match = ce5[e.level].good_length, e.nice_match = ce5[e.level].nice_length, e.max_chain_length = ce5[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = k2 - 1, e.match_available = 0, e.ins_h = 0;
};
function Ha() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Pe7, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Za * 2), this.dyn_dtree = new Uint16Array((2 * ma + 1) * 2), this.bl_tree = new Uint16Array((2 * Da + 1) * 2), X11(this.dyn_ltree), X11(this.dyn_dtree), X11(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Ia + 1), this.heap = new Uint16Array(2 * _t + 1), X11(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * _t + 1), X11(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
var xi = (e)=>{
    if (!e || !e.state) return G8(e, L7);
    e.total_in = e.total_out = 0, e.data_type = ya;
    let i = e.state;
    return i.pending = 0, i.pending_out = 0, i.wrap < 0 && (i.wrap = -i.wrap), i.status = i.wrap ? Xe1 : q8, e.adler = i.wrap === 2 ? 0 : 1, i.last_flush = le6, da(i), M7;
}, ki = (e)=>{
    let i = xi(e);
    return i === M7 && Ma(e.state), i;
}, Ba = (e, i)=>!e || !e.state || e.state.wrap !== 2 ? L7 : (e.state.gzhead = i, M7), vi = (e, i, t, n, a, l)=>{
    if (!e) return L7;
    let o = 1;
    if (i === pa && (i = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), a < 1 || a > Sa || t !== Pe7 || n < 8 || n > 15 || i < 0 || i > 9 || l < 0 || l > va) return G8(e, L7);
    n === 8 && (n = 9);
    let f = new Ha;
    return e.state = f, f.strm = e, f.wrap = o, f.gzhead = null, f.w_bits = n, f.w_size = 1 << f.w_bits, f.w_mask = f.w_size - 1, f.hash_bits = a + 7, f.hash_size = 1 << f.hash_bits, f.hash_mask = f.hash_size - 1, f.hash_shift = ~~((f.hash_bits + k2 - 1) / k2), f.window = new Uint8Array(f.w_size * 2), f.head = new Uint16Array(f.hash_size), f.prev = new Uint16Array(f.w_size), f.lit_bufsize = 1 << a + 6, f.pending_buf_size = f.lit_bufsize * 4, f.pending_buf = new Uint8Array(f.pending_buf_size), f.d_buf = 1 * f.lit_bufsize, f.l_buf = (1 + 2) * f.lit_bufsize, f.level = i, f.strategy = l, f.method = t, ki(e);
}, Ka = (e, i)=>vi(e, i, Pe7, Aa, Ra, Ea), Pa = (e, i)=>{
    let t, n;
    if (!e || !e.state || i > St || i < 0) return e ? G8(e, L7) : L7;
    let a = e.state;
    if (!e.output || !e.input && e.avail_in !== 0 || a.status === se6 && i !== W10) return G8(e, e.avail_out === 0 ? Je1 : L7);
    a.strm = e;
    let l = a.last_flush;
    if (a.last_flush = i, a.status === Xe1) if (a.wrap === 2) e.adler = 0, y4(a, 31), y4(a, 139), y4(a, 8), a.gzhead ? (y4(a, (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)), y4(a, a.gzhead.time & 255), y4(a, a.gzhead.time >> 8 & 255), y4(a, a.gzhead.time >> 16 & 255), y4(a, a.gzhead.time >> 24 & 255), y4(a, a.level === 9 ? 2 : a.strategy >= Ie4 || a.level < 2 ? 4 : 0), y4(a, a.gzhead.os & 255), a.gzhead.extra && a.gzhead.extra.length && (y4(a, a.gzhead.extra.length & 255), y4(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (e.adler = I7(e.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = ht) : (y4(a, 0), y4(a, 0), y4(a, 0), y4(a, 0), y4(a, 0), y4(a, a.level === 9 ? 2 : a.strategy >= Ie4 || a.level < 2 ? 4 : 0), y4(a, Na), a.status = q8);
    else {
        let o = Pe7 + (a.w_bits - 8 << 4) << 8, f = -1;
        a.strategy >= Ie4 || a.level < 2 ? f = 0 : a.level < 6 ? f = 1 : a.level === 6 ? f = 2 : f = 3, o |= f << 6, a.strstart !== 0 && (o |= Oa), o += 31 - o % 31, a.status = q8, de8(a, o), a.strstart !== 0 && (de8(a, e.adler >>> 16), de8(a, e.adler & 65535)), e.adler = 1;
    }
    if (a.status === ht) if (a.gzhead.extra) {
        for(t = a.pending; a.gzindex < (a.gzhead.extra.length & 65535) && !(a.pending === a.pending_buf_size && (a.gzhead.hcrc && a.pending > t && (e.adler = I7(e.adler, a.pending_buf, a.pending - t, t)), P8(e), t = a.pending, a.pending === a.pending_buf_size));)y4(a, a.gzhead.extra[a.gzindex] & 255), a.gzindex++;
        a.gzhead.hcrc && a.pending > t && (e.adler = I7(e.adler, a.pending_buf, a.pending - t, t)), a.gzindex === a.gzhead.extra.length && (a.gzindex = 0, a.status = Ce9);
    } else a.status = Ce9;
    if (a.status === Ce9) if (a.gzhead.name) {
        t = a.pending;
        do {
            if (a.pending === a.pending_buf_size && (a.gzhead.hcrc && a.pending > t && (e.adler = I7(e.adler, a.pending_buf, a.pending - t, t)), P8(e), t = a.pending, a.pending === a.pending_buf_size)) {
                n = 1;
                break;
            }
            a.gzindex < a.gzhead.name.length ? n = a.gzhead.name.charCodeAt(a.gzindex++) & 255 : n = 0, y4(a, n);
        }while (n !== 0)
        a.gzhead.hcrc && a.pending > t && (e.adler = I7(e.adler, a.pending_buf, a.pending - t, t)), n === 0 && (a.gzindex = 0, a.status = Fe5);
    } else a.status = Fe5;
    if (a.status === Fe5) if (a.gzhead.comment) {
        t = a.pending;
        do {
            if (a.pending === a.pending_buf_size && (a.gzhead.hcrc && a.pending > t && (e.adler = I7(e.adler, a.pending_buf, a.pending - t, t)), P8(e), t = a.pending, a.pending === a.pending_buf_size)) {
                n = 1;
                break;
            }
            a.gzindex < a.gzhead.comment.length ? n = a.gzhead.comment.charCodeAt(a.gzindex++) & 255 : n = 0, y4(a, n);
        }while (n !== 0)
        a.gzhead.hcrc && a.pending > t && (e.adler = I7(e.adler, a.pending_buf, a.pending - t, t)), n === 0 && (a.status = Me7);
    } else a.status = Me7;
    if (a.status === Me7 && (a.gzhead.hcrc ? (a.pending + 2 > a.pending_buf_size && P8(e), a.pending + 2 <= a.pending_buf_size && (y4(a, e.adler & 255), y4(a, e.adler >> 8 & 255), e.adler = 0, a.status = q8)) : a.status = q8), a.pending !== 0) {
        if (P8(e), e.avail_out === 0) return a.last_flush = -1, M7;
    } else if (e.avail_in === 0 && Rt(i) <= Rt(l) && i !== W10) return G8(e, Je1);
    if (a.status === se6 && e.avail_in !== 0) return G8(e, Je1);
    if (e.avail_in !== 0 || a.lookahead !== 0 || i !== le6 && a.status !== se6) {
        let o1 = a.strategy === Ie4 ? Fa(a, i) : a.strategy === ka ? Ca(a, i) : ce5[a.level].func(a, i);
        if ((o1 === te8 || o1 === he5) && (a.status = se6), o1 === D5 || o1 === te8) return e.avail_out === 0 && (a.last_flush = -1), M7;
        if (o1 === Re4 && (i === ba ? ua(a) : i !== St && (sa(a, 0, 0, !1), i === wa && (X11(a.head), a.lookahead === 0 && (a.strstart = 0, a.block_start = 0, a.insert = 0))), P8(e), e.avail_out === 0)) return a.last_flush = -1, M7;
    }
    return i !== W10 ? M7 : a.wrap <= 0 ? At : (a.wrap === 2 ? (y4(a, e.adler & 255), y4(a, e.adler >> 8 & 255), y4(a, e.adler >> 16 & 255), y4(a, e.adler >> 24 & 255), y4(a, e.total_in & 255), y4(a, e.total_in >> 8 & 255), y4(a, e.total_in >> 16 & 255), y4(a, e.total_in >> 24 & 255)) : (de8(a, e.adler >>> 16), de8(a, e.adler & 65535)), P8(e), a.wrap > 0 && (a.wrap = -a.wrap), a.pending !== 0 ? M7 : At);
}, Xa = (e)=>{
    if (!e || !e.state) return L7;
    let i = e.state.status;
    return i !== Xe1 && i !== ht && i !== Ce9 && i !== Fe5 && i !== Me7 && i !== q8 && i !== se6 ? G8(e, L7) : (e.state = null, i === q8 ? G8(e, ga) : M7);
}, Ya = (e, i)=>{
    let t = i.length;
    if (!e || !e.state) return L7;
    let n = e.state, a = n.wrap;
    if (a === 2 || a === 1 && n.status !== Xe1 || n.lookahead) return L7;
    if (a === 1 && (e.adler = ve5(e.adler, i, t, 0)), n.wrap = 0, t >= n.w_size) {
        a === 0 && (X11(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
        let c = new Uint8Array(n.w_size);
        c.set(i.subarray(t - n.w_size, t), 0), i = c, t = n.w_size;
    }
    let l = e.avail_in, o = e.next_in, f = e.input;
    for(e.avail_in = t, e.next_in = 0, e.input = i, ie6(n); n.lookahead >= k2;){
        let c1 = n.strstart, r = n.lookahead - (k2 - 1);
        do n.ins_h = V5(n, n.ins_h, n.window[c1 + k2 - 1]), n.prev[c1 & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = c1, c1++;
        while (--r)
        n.strstart = c1, n.lookahead = k2 - 1, ie6(n);
    }
    return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = k2 - 1, n.match_available = 0, e.next_in = o, e.input = f, e.avail_in = l, n.wrap = a, M7;
}, Ga = Ka, ja = vi, Wa = ki, Va = xi, Ja = Ba, Qa = Pa, qa = Xa, en = Ya, tn = "pako deflate (from Nodeca project)", be5 = {
    deflateInit: Ga,
    deflateInit2: ja,
    deflateReset: Wa,
    deflateResetKeep: Va,
    deflateSetHeader: Ja,
    deflate: Qa,
    deflateEnd: qa,
    deflateSetDictionary: en,
    deflateInfo: tn
}, an = (e, i)=>Object.prototype.hasOwnProperty.call(e, i), nn = function(e) {
    let i = Array.prototype.slice.call(arguments, 1);
    for(; i.length;){
        let t = i.shift();
        if (!!t) {
            if (typeof t != "object") throw new TypeError(t + "must be non-object");
            for(let n in t)an(t, n) && (e[n] = t[n]);
        }
    }
    return e;
}, ln = (e)=>{
    let i = 0;
    for(let n = 0, a = e.length; n < a; n++)i += e[n].length;
    let t = new Uint8Array(i);
    for(let n1 = 0, a1 = 0, l = e.length; n1 < l; n1++){
        let o = e[n1];
        t.set(o, a1), a1 += o.length;
    }
    return t;
}, Ye4 = {
    assign: nn,
    flattenChunks: ln
}, Ei = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch  {
    Ei = !1;
}
var Ee5 = new Uint8Array(256);
for(let e1 = 0; e1 < 256; e1++)Ee5[e1] = e1 >= 252 ? 6 : e1 >= 248 ? 5 : e1 >= 240 ? 4 : e1 >= 224 ? 3 : e1 >= 192 ? 2 : 1;
Ee5[254] = Ee5[254] = 1;
var rn1 = (e)=>{
    if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(e);
    let i, t, n, a, l, o = e.length, f = 0;
    for(a = 0; a < o; a++)t = e.charCodeAt(a), (t & 64512) === 55296 && a + 1 < o && (n = e.charCodeAt(a + 1), (n & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (n - 56320), a++)), f += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
    for(i = new Uint8Array(f), l = 0, a = 0; l < f; a++)t = e.charCodeAt(a), (t & 64512) === 55296 && a + 1 < o && (n = e.charCodeAt(a + 1), (n & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (n - 56320), a++)), t < 128 ? i[l++] = t : t < 2048 ? (i[l++] = 192 | t >>> 6, i[l++] = 128 | t & 63) : t < 65536 ? (i[l++] = 224 | t >>> 12, i[l++] = 128 | t >>> 6 & 63, i[l++] = 128 | t & 63) : (i[l++] = 240 | t >>> 18, i[l++] = 128 | t >>> 12 & 63, i[l++] = 128 | t >>> 6 & 63, i[l++] = 128 | t & 63);
    return i;
}, fn = (e, i)=>{
    if (i < 65534 && e.subarray && Ei) return String.fromCharCode.apply(null, e.length === i ? e : e.subarray(0, i));
    let t = "";
    for(let n = 0; n < i; n++)t += String.fromCharCode(e[n]);
    return t;
}, on = (e, i)=>{
    let t = i || e.length;
    if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(e.subarray(0, i));
    let n, a, l = new Array(t * 2);
    for(a = 0, n = 0; n < t;){
        let o = e[n++];
        if (o < 128) {
            l[a++] = o;
            continue;
        }
        let f = Ee5[o];
        if (f > 4) {
            l[a++] = 65533, n += f - 1;
            continue;
        }
        for(o &= f === 2 ? 31 : f === 3 ? 15 : 7; f > 1 && n < t;)o = o << 6 | e[n++] & 63, f--;
        if (f > 1) {
            l[a++] = 65533;
            continue;
        }
        o < 65536 ? l[a++] = o : (o -= 65536, l[a++] = 55296 | o >> 10 & 1023, l[a++] = 56320 | o & 1023);
    }
    return fn(l, a);
}, _n = (e, i)=>{
    i = i || e.length, i > e.length && (i = e.length);
    let t = i - 1;
    for(; t >= 0 && (e[t] & 192) === 128;)t--;
    return t < 0 || t === 0 ? i : t + Ee5[e[t]] > i ? t : i;
}, ye7 = {
    string2buf: rn1,
    buf2string: on,
    utf8border: _n
};
function hn() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var yi = hn, Si = Object.prototype.toString, { Z_NO_FLUSH: dn , Z_SYNC_FLUSH: sn , Z_FULL_FLUSH: cn , Z_FINISH: un , Z_OK: Be2 , Z_STREAM_END: bn , Z_DEFAULT_COMPRESSION: wn , Z_DEFAULT_STRATEGY: gn , Z_DEFLATED: pn  } = ne8;
function ze3(e) {
    this.options = Ye4.assign({
        level: wn,
        method: pn,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: gn
    }, e || {});
    let i = this.options;
    i.raw && i.windowBits > 0 ? i.windowBits = -i.windowBits : i.gzip && i.windowBits > 0 && i.windowBits < 16 && (i.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new yi, this.strm.avail_out = 0;
    let t = be5.deflateInit2(this.strm, i.level, i.method, i.windowBits, i.memLevel, i.strategy);
    if (t !== Be2) throw new Error(ee10[t]);
    if (i.header && be5.deflateSetHeader(this.strm, i.header), i.dictionary) {
        let n;
        if (typeof i.dictionary == "string" ? n = ye7.string2buf(i.dictionary) : Si.call(i.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(i.dictionary) : n = i.dictionary, t = be5.deflateSetDictionary(this.strm, n), t !== Be2) throw new Error(ee10[t]);
        this._dict_set = !0;
    }
}
ze3.prototype.push = function(e, i) {
    let t = this.strm, n = this.options.chunkSize, a, l;
    if (this.ended) return !1;
    for(i === ~~i ? l = i : l = i === !0 ? un : dn, typeof e == "string" ? t.input = ye7.string2buf(e) : Si.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length;;){
        if (t.avail_out === 0 && (t.output = new Uint8Array(n), t.next_out = 0, t.avail_out = n), (l === sn || l === cn) && t.avail_out <= 6) {
            this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
            continue;
        }
        if (a = be5.deflate(t, l), a === bn) return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), a = be5.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === Be2;
        if (t.avail_out === 0) {
            this.onData(t.output);
            continue;
        }
        if (l > 0 && t.next_out > 0) {
            this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
            continue;
        }
        if (t.avail_in === 0) break;
    }
    return !0;
};
ze3.prototype.onData = function(e) {
    this.chunks.push(e);
};
ze3.prototype.onEnd = function(e) {
    e === Be2 && (this.result = Ye4.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function bt(e, i) {
    let t = new ze3(i);
    if (t.push(e, !0), t.err) throw t.msg || ee10[t.err];
    return t.result;
}
function xn(e, i) {
    return i = i || {}, i.raw = !0, bt(e, i);
}
function kn(e, i) {
    return i = i || {}, i.gzip = !0, bt(e, i);
}
var vn = ze3, En = bt, yn = xn, Sn = kn, An = ne8, Rn = {
    Deflate: vn,
    deflate: En,
    deflateRaw: yn,
    gzip: Sn,
    constants: An
}, Oe4 = 30, zn = 12, Tn = function(i, t) {
    let n, a, l, o, f, c, r, _, E, s, h, u, m, v, w, A, x, d, S, Z, b, z, R, g, p = i.state;
    n = i.next_in, R = i.input, a = n + (i.avail_in - 5), l = i.next_out, g = i.output, o = l - (t - i.avail_out), f = l + (i.avail_out - 257), c = p.dmax, r = p.wsize, _ = p.whave, E = p.wnext, s = p.window, h = p.hold, u = p.bits, m = p.lencode, v = p.distcode, w = (1 << p.lenbits) - 1, A = (1 << p.distbits) - 1;
    e: do {
        u < 15 && (h += R[n++] << u, u += 8, h += R[n++] << u, u += 8), x = m[h & w];
        t: for(;;){
            if (d = x >>> 24, h >>>= d, u -= d, d = x >>> 16 & 255, d === 0) g[l++] = x & 65535;
            else if (d & 16) {
                S = x & 65535, d &= 15, d && (u < d && (h += R[n++] << u, u += 8), S += h & (1 << d) - 1, h >>>= d, u -= d), u < 15 && (h += R[n++] << u, u += 8, h += R[n++] << u, u += 8), x = v[h & A];
                i: for(;;){
                    if (d = x >>> 24, h >>>= d, u -= d, d = x >>> 16 & 255, d & 16) {
                        if (Z = x & 65535, d &= 15, u < d && (h += R[n++] << u, u += 8, u < d && (h += R[n++] << u, u += 8)), Z += h & (1 << d) - 1, Z > c) {
                            i.msg = "invalid distance too far back", p.mode = Oe4;
                            break e;
                        }
                        if (h >>>= d, u -= d, d = l - o, Z > d) {
                            if (d = Z - d, d > _ && p.sane) {
                                i.msg = "invalid distance too far back", p.mode = Oe4;
                                break e;
                            }
                            if (b = 0, z = s, E === 0) {
                                if (b += r - d, d < S) {
                                    S -= d;
                                    do g[l++] = s[b++];
                                    while (--d)
                                    b = l - Z, z = g;
                                }
                            } else if (E < d) {
                                if (b += r + E - d, d -= E, d < S) {
                                    S -= d;
                                    do g[l++] = s[b++];
                                    while (--d)
                                    if (b = 0, E < S) {
                                        d = E, S -= d;
                                        do g[l++] = s[b++];
                                        while (--d)
                                        b = l - Z, z = g;
                                    }
                                }
                            } else if (b += E - d, d < S) {
                                S -= d;
                                do g[l++] = s[b++];
                                while (--d)
                                b = l - Z, z = g;
                            }
                            for(; S > 2;)g[l++] = z[b++], g[l++] = z[b++], g[l++] = z[b++], S -= 3;
                            S && (g[l++] = z[b++], S > 1 && (g[l++] = z[b++]));
                        } else {
                            b = l - Z;
                            do g[l++] = g[b++], g[l++] = g[b++], g[l++] = g[b++], S -= 3;
                            while (S > 2)
                            S && (g[l++] = g[b++], S > 1 && (g[l++] = g[b++]));
                        }
                    } else if ((d & 64) === 0) {
                        x = v[(x & 65535) + (h & (1 << d) - 1)];
                        continue i;
                    } else {
                        i.msg = "invalid distance code", p.mode = Oe4;
                        break e;
                    }
                    break;
                }
            } else if ((d & 64) === 0) {
                x = m[(x & 65535) + (h & (1 << d) - 1)];
                continue t;
            } else if (d & 32) {
                p.mode = zn;
                break e;
            } else {
                i.msg = "invalid literal/length code", p.mode = Oe4;
                break e;
            }
            break;
        }
    }while (n < a && l < f)
    S = u >> 3, n -= S, u -= S << 3, h &= (1 << u) - 1, i.next_in = n, i.next_out = l, i.avail_in = n < a ? 5 + (a - n) : 5 - (n - a), i.avail_out = l < f ? 257 + (f - l) : 257 - (l - f), p.hold = h, p.bits = u;
}, fe7 = 15, zt = 852, Tt = 592, mt = 0, qe4 = 1, Dt = 2, mn = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
]), Dn = new Uint8Array([
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
]), Zn = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
]), In = new Uint8Array([
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
]), On = (e, i, t, n, a, l, o, f)=>{
    let c = f.bits, r = 0, _ = 0, E = 0, s = 0, h = 0, u = 0, m = 0, v = 0, w = 0, A = 0, x, d, S, Z, b, z = null, R = 0, g, p = new Uint16Array(fe7 + 1), J = new Uint16Array(fe7 + 1), me = null, gt = 0, pt, De, Ze;
    for(r = 0; r <= fe7; r++)p[r] = 0;
    for(_ = 0; _ < n; _++)p[i[t + _]]++;
    for(h = c, s = fe7; s >= 1 && p[s] === 0; s--);
    if (h > s && (h = s), s === 0) return a[l++] = 1 << 24 | 64 << 16 | 0, a[l++] = 1 << 24 | 64 << 16 | 0, f.bits = 1, 0;
    for(E = 1; E < s && p[E] === 0; E++);
    for(h < E && (h = E), v = 1, r = 1; r <= fe7; r++)if (v <<= 1, v -= p[r], v < 0) return -1;
    if (v > 0 && (e === mt || s !== 1)) return -1;
    for(J[1] = 0, r = 1; r < fe7; r++)J[r + 1] = J[r] + p[r];
    for(_ = 0; _ < n; _++)i[t + _] !== 0 && (o[J[i[t + _]]++] = _);
    if (e === mt ? (z = me = o, g = 19) : e === qe4 ? (z = mn, R -= 257, me = Dn, gt -= 257, g = 256) : (z = Zn, me = In, g = -1), A = 0, _ = 0, r = E, b = l, u = h, m = 0, S = -1, w = 1 << h, Z = w - 1, e === qe4 && w > zt || e === Dt && w > Tt) return 1;
    for(;;){
        pt = r - m, o[_] < g ? (De = 0, Ze = o[_]) : o[_] > g ? (De = me[gt + o[_]], Ze = z[R + o[_]]) : (De = 32 + 64, Ze = 0), x = 1 << r - m, d = 1 << u, E = d;
        do d -= x, a[b + (A >> m) + d] = pt << 24 | De << 16 | Ze | 0;
        while (d !== 0)
        for(x = 1 << r - 1; A & x;)x >>= 1;
        if (x !== 0 ? (A &= x - 1, A += x) : A = 0, _++, --p[r] === 0) {
            if (r === s) break;
            r = i[t + o[_]];
        }
        if (r > h && (A & Z) !== S) {
            for(m === 0 && (m = h), b += E, u = r - m, v = 1 << u; u + m < s && (v -= p[u + m], !(v <= 0));)u++, v <<= 1;
            if (w += 1 << u, e === qe4 && w > zt || e === Dt && w > Tt) return 1;
            S = A & Z, a[S] = h << 24 | u << 16 | b - l | 0;
        }
    }
    return A !== 0 && (a[b + A] = r - m << 24 | 64 << 16 | 0), f.bits = h, 0;
}, we7 = On, Nn = 0, Ai = 1, Ri1 = 2, { Z_FINISH: Zt , Z_BLOCK: Ln , Z_TREES: Ne5 , Z_OK: ae8 , Z_STREAM_END: Un , Z_NEED_DICT: $n , Z_STREAM_ERROR: U7 , Z_DATA_ERROR: zi , Z_MEM_ERROR: Ti , Z_BUF_ERROR: Cn , Z_DEFLATED: It  } = ne8, mi = 1, Ot = 2, Nt = 3, Lt = 4, Ut = 5, $t = 6, Ct = 7, Ft = 8, Mt = 9, Ht = 10, Ke2 = 11, H7 = 12, et = 13, Bt = 14, tt = 15, Kt = 16, Pt = 17, Xt = 18, Yt = 19, Le4 = 20, Ue4 = 21, Gt = 22, jt = 23, Wt = 24, Vt = 25, Jt = 26, it = 27, Qt = 28, qt = 29, T3 = 30, Di1 = 31, Fn = 32, Mn = 852, Hn = 592, Bn = 15, Kn = Bn, ei = (e)=>(e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function Pn() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
var Zi = (e)=>{
    if (!e || !e.state) return U7;
    let i = e.state;
    return e.total_in = e.total_out = i.total = 0, e.msg = "", i.wrap && (e.adler = i.wrap & 1), i.mode = mi, i.last = 0, i.havedict = 0, i.dmax = 32768, i.head = null, i.hold = 0, i.bits = 0, i.lencode = i.lendyn = new Int32Array(Mn), i.distcode = i.distdyn = new Int32Array(Hn), i.sane = 1, i.back = -1, ae8;
}, Ii = (e)=>{
    if (!e || !e.state) return U7;
    let i = e.state;
    return i.wsize = 0, i.whave = 0, i.wnext = 0, Zi(e);
}, Oi = (e, i)=>{
    let t;
    if (!e || !e.state) return U7;
    let n = e.state;
    return i < 0 ? (t = 0, i = -i) : (t = (i >> 4) + 1, i < 48 && (i &= 15)), i && (i < 8 || i > 15) ? U7 : (n.window !== null && n.wbits !== i && (n.window = null), n.wrap = t, n.wbits = i, Ii(e));
}, Ni = (e, i)=>{
    if (!e) return U7;
    let t = new Pn;
    e.state = t, t.window = null;
    let n = Oi(e, i);
    return n !== ae8 && (e.state = null), n;
}, Xn = (e)=>Ni(e, Kn), ti = !0, at, nt, Yn = (e)=>{
    if (ti) {
        at = new Int32Array(512), nt = new Int32Array(32);
        let i = 0;
        for(; i < 144;)e.lens[i++] = 8;
        for(; i < 256;)e.lens[i++] = 9;
        for(; i < 280;)e.lens[i++] = 7;
        for(; i < 288;)e.lens[i++] = 8;
        for(we7(Ai, e.lens, 0, 288, at, 0, e.work, {
            bits: 9
        }), i = 0; i < 32;)e.lens[i++] = 5;
        we7(Ri1, e.lens, 0, 32, nt, 0, e.work, {
            bits: 5
        }), ti = !1;
    }
    e.lencode = at, e.lenbits = 9, e.distcode = nt, e.distbits = 5;
}, Li = (e, i, t, n)=>{
    let a, l = e.state;
    return l.window === null && (l.wsize = 1 << l.wbits, l.wnext = 0, l.whave = 0, l.window = new Uint8Array(l.wsize)), n >= l.wsize ? (l.window.set(i.subarray(t - l.wsize, t), 0), l.wnext = 0, l.whave = l.wsize) : (a = l.wsize - l.wnext, a > n && (a = n), l.window.set(i.subarray(t - n, t - n + a), l.wnext), n -= a, n ? (l.window.set(i.subarray(t - n, t), 0), l.wnext = n, l.whave = l.wsize) : (l.wnext += a, l.wnext === l.wsize && (l.wnext = 0), l.whave < l.wsize && (l.whave += a))), 0;
}, Gn = (e, i)=>{
    let t, n, a, l, o, f, c, r, _, E, s, h, u, m, v = 0, w, A, x, d, S, Z, b, z, R = new Uint8Array(4), g, p, J = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]);
    if (!e || !e.state || !e.output || !e.input && e.avail_in !== 0) return U7;
    t = e.state, t.mode === H7 && (t.mode = et), o = e.next_out, a = e.output, c = e.avail_out, l = e.next_in, n = e.input, f = e.avail_in, r = t.hold, _ = t.bits, E = f, s = c, z = ae8;
    e: for(;;)switch(t.mode){
        case mi:
            if (t.wrap === 0) {
                t.mode = et;
                break;
            }
            for(; _ < 16;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            if (t.wrap & 2 && r === 35615) {
                t.check = 0, R[0] = r & 255, R[1] = r >>> 8 & 255, t.check = I7(t.check, R, 2, 0), r = 0, _ = 0, t.mode = Ot;
                break;
            }
            if (t.flags = 0, t.head && (t.head.done = !1), !(t.wrap & 1) || (((r & 255) << 8) + (r >> 8)) % 31) {
                e.msg = "incorrect header check", t.mode = T3;
                break;
            }
            if ((r & 15) !== It) {
                e.msg = "unknown compression method", t.mode = T3;
                break;
            }
            if (r >>>= 4, _ -= 4, b = (r & 15) + 8, t.wbits === 0) t.wbits = b;
            else if (b > t.wbits) {
                e.msg = "invalid window size", t.mode = T3;
                break;
            }
            t.dmax = 1 << t.wbits, e.adler = t.check = 1, t.mode = r & 512 ? Ht : H7, r = 0, _ = 0;
            break;
        case Ot:
            for(; _ < 16;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            if (t.flags = r, (t.flags & 255) !== It) {
                e.msg = "unknown compression method", t.mode = T3;
                break;
            }
            if (t.flags & 57344) {
                e.msg = "unknown header flags set", t.mode = T3;
                break;
            }
            t.head && (t.head.text = r >> 8 & 1), t.flags & 512 && (R[0] = r & 255, R[1] = r >>> 8 & 255, t.check = I7(t.check, R, 2, 0)), r = 0, _ = 0, t.mode = Nt;
        case Nt:
            for(; _ < 32;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            t.head && (t.head.time = r), t.flags & 512 && (R[0] = r & 255, R[1] = r >>> 8 & 255, R[2] = r >>> 16 & 255, R[3] = r >>> 24 & 255, t.check = I7(t.check, R, 4, 0)), r = 0, _ = 0, t.mode = Lt;
        case Lt:
            for(; _ < 16;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            t.head && (t.head.xflags = r & 255, t.head.os = r >> 8), t.flags & 512 && (R[0] = r & 255, R[1] = r >>> 8 & 255, t.check = I7(t.check, R, 2, 0)), r = 0, _ = 0, t.mode = Ut;
        case Ut:
            if (t.flags & 1024) {
                for(; _ < 16;){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                t.length = r, t.head && (t.head.extra_len = r), t.flags & 512 && (R[0] = r & 255, R[1] = r >>> 8 & 255, t.check = I7(t.check, R, 2, 0)), r = 0, _ = 0;
            } else t.head && (t.head.extra = null);
            t.mode = $t;
        case $t:
            if (t.flags & 1024 && (h = t.length, h > f && (h = f), h && (t.head && (b = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(n.subarray(l, l + h), b)), t.flags & 512 && (t.check = I7(t.check, n, h, l)), f -= h, l += h, t.length -= h), t.length)) break e;
            t.length = 0, t.mode = Ct;
        case Ct:
            if (t.flags & 2048) {
                if (f === 0) break e;
                h = 0;
                do b = n[l + h++], t.head && b && t.length < 65536 && (t.head.name += String.fromCharCode(b));
                while (b && h < f)
                if (t.flags & 512 && (t.check = I7(t.check, n, h, l)), f -= h, l += h, b) break e;
            } else t.head && (t.head.name = null);
            t.length = 0, t.mode = Ft;
        case Ft:
            if (t.flags & 4096) {
                if (f === 0) break e;
                h = 0;
                do b = n[l + h++], t.head && b && t.length < 65536 && (t.head.comment += String.fromCharCode(b));
                while (b && h < f)
                if (t.flags & 512 && (t.check = I7(t.check, n, h, l)), f -= h, l += h, b) break e;
            } else t.head && (t.head.comment = null);
            t.mode = Mt;
        case Mt:
            if (t.flags & 512) {
                for(; _ < 16;){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                if (r !== (t.check & 65535)) {
                    e.msg = "header crc mismatch", t.mode = T3;
                    break;
                }
                r = 0, _ = 0;
            }
            t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), e.adler = t.check = 0, t.mode = H7;
            break;
        case Ht:
            for(; _ < 32;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            e.adler = t.check = ei(r), r = 0, _ = 0, t.mode = Ke2;
        case Ke2:
            if (t.havedict === 0) return e.next_out = o, e.avail_out = c, e.next_in = l, e.avail_in = f, t.hold = r, t.bits = _, $n;
            e.adler = t.check = 1, t.mode = H7;
        case H7:
            if (i === Ln || i === Ne5) break e;
        case et:
            if (t.last) {
                r >>>= _ & 7, _ -= _ & 7, t.mode = it;
                break;
            }
            for(; _ < 3;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            switch(t.last = r & 1, r >>>= 1, _ -= 1, r & 3){
                case 0:
                    t.mode = Bt;
                    break;
                case 1:
                    if (Yn(t), t.mode = Le4, i === Ne5) {
                        r >>>= 2, _ -= 2;
                        break e;
                    }
                    break;
                case 2:
                    t.mode = Pt;
                    break;
                case 3:
                    e.msg = "invalid block type", t.mode = T3;
            }
            r >>>= 2, _ -= 2;
            break;
        case Bt:
            for(r >>>= _ & 7, _ -= _ & 7; _ < 32;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            if ((r & 65535) !== (r >>> 16 ^ 65535)) {
                e.msg = "invalid stored block lengths", t.mode = T3;
                break;
            }
            if (t.length = r & 65535, r = 0, _ = 0, t.mode = tt, i === Ne5) break e;
        case tt:
            t.mode = Kt;
        case Kt:
            if (h = t.length, h) {
                if (h > f && (h = f), h > c && (h = c), h === 0) break e;
                a.set(n.subarray(l, l + h), o), f -= h, l += h, c -= h, o += h, t.length -= h;
                break;
            }
            t.mode = H7;
            break;
        case Pt:
            for(; _ < 14;){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            if (t.nlen = (r & 31) + 257, r >>>= 5, _ -= 5, t.ndist = (r & 31) + 1, r >>>= 5, _ -= 5, t.ncode = (r & 15) + 4, r >>>= 4, _ -= 4, t.nlen > 286 || t.ndist > 30) {
                e.msg = "too many length or distance symbols", t.mode = T3;
                break;
            }
            t.have = 0, t.mode = Xt;
        case Xt:
            for(; t.have < t.ncode;){
                for(; _ < 3;){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                t.lens[J[t.have++]] = r & 7, r >>>= 3, _ -= 3;
            }
            for(; t.have < 19;)t.lens[J[t.have++]] = 0;
            if (t.lencode = t.lendyn, t.lenbits = 7, g = {
                bits: t.lenbits
            }, z = we7(Nn, t.lens, 0, 19, t.lencode, 0, t.work, g), t.lenbits = g.bits, z) {
                e.msg = "invalid code lengths set", t.mode = T3;
                break;
            }
            t.have = 0, t.mode = Yt;
        case Yt:
            for(; t.have < t.nlen + t.ndist;){
                for(; v = t.lencode[r & (1 << t.lenbits) - 1], w = v >>> 24, A = v >>> 16 & 255, x = v & 65535, !(w <= _);){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                if (x < 16) r >>>= w, _ -= w, t.lens[t.have++] = x;
                else {
                    if (x === 16) {
                        for(p = w + 2; _ < p;){
                            if (f === 0) break e;
                            f--, r += n[l++] << _, _ += 8;
                        }
                        if (r >>>= w, _ -= w, t.have === 0) {
                            e.msg = "invalid bit length repeat", t.mode = T3;
                            break;
                        }
                        b = t.lens[t.have - 1], h = 3 + (r & 3), r >>>= 2, _ -= 2;
                    } else if (x === 17) {
                        for(p = w + 3; _ < p;){
                            if (f === 0) break e;
                            f--, r += n[l++] << _, _ += 8;
                        }
                        r >>>= w, _ -= w, b = 0, h = 3 + (r & 7), r >>>= 3, _ -= 3;
                    } else {
                        for(p = w + 7; _ < p;){
                            if (f === 0) break e;
                            f--, r += n[l++] << _, _ += 8;
                        }
                        r >>>= w, _ -= w, b = 0, h = 11 + (r & 127), r >>>= 7, _ -= 7;
                    }
                    if (t.have + h > t.nlen + t.ndist) {
                        e.msg = "invalid bit length repeat", t.mode = T3;
                        break;
                    }
                    for(; h--;)t.lens[t.have++] = b;
                }
            }
            if (t.mode === T3) break;
            if (t.lens[256] === 0) {
                e.msg = "invalid code -- missing end-of-block", t.mode = T3;
                break;
            }
            if (t.lenbits = 9, g = {
                bits: t.lenbits
            }, z = we7(Ai, t.lens, 0, t.nlen, t.lencode, 0, t.work, g), t.lenbits = g.bits, z) {
                e.msg = "invalid literal/lengths set", t.mode = T3;
                break;
            }
            if (t.distbits = 6, t.distcode = t.distdyn, g = {
                bits: t.distbits
            }, z = we7(Ri1, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, g), t.distbits = g.bits, z) {
                e.msg = "invalid distances set", t.mode = T3;
                break;
            }
            if (t.mode = Le4, i === Ne5) break e;
        case Le4:
            t.mode = Ue4;
        case Ue4:
            if (f >= 6 && c >= 258) {
                e.next_out = o, e.avail_out = c, e.next_in = l, e.avail_in = f, t.hold = r, t.bits = _, Tn(e, s), o = e.next_out, a = e.output, c = e.avail_out, l = e.next_in, n = e.input, f = e.avail_in, r = t.hold, _ = t.bits, t.mode === H7 && (t.back = -1);
                break;
            }
            for(t.back = 0; v = t.lencode[r & (1 << t.lenbits) - 1], w = v >>> 24, A = v >>> 16 & 255, x = v & 65535, !(w <= _);){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            if (A && (A & 240) === 0) {
                for(d = w, S = A, Z = x; v = t.lencode[Z + ((r & (1 << d + S) - 1) >> d)], w = v >>> 24, A = v >>> 16 & 255, x = v & 65535, !(d + w <= _);){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                r >>>= d, _ -= d, t.back += d;
            }
            if (r >>>= w, _ -= w, t.back += w, t.length = x, A === 0) {
                t.mode = Jt;
                break;
            }
            if (A & 32) {
                t.back = -1, t.mode = H7;
                break;
            }
            if (A & 64) {
                e.msg = "invalid literal/length code", t.mode = T3;
                break;
            }
            t.extra = A & 15, t.mode = Gt;
        case Gt:
            if (t.extra) {
                for(p = t.extra; _ < p;){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                t.length += r & (1 << t.extra) - 1, r >>>= t.extra, _ -= t.extra, t.back += t.extra;
            }
            t.was = t.length, t.mode = jt;
        case jt:
            for(; v = t.distcode[r & (1 << t.distbits) - 1], w = v >>> 24, A = v >>> 16 & 255, x = v & 65535, !(w <= _);){
                if (f === 0) break e;
                f--, r += n[l++] << _, _ += 8;
            }
            if ((A & 240) === 0) {
                for(d = w, S = A, Z = x; v = t.distcode[Z + ((r & (1 << d + S) - 1) >> d)], w = v >>> 24, A = v >>> 16 & 255, x = v & 65535, !(d + w <= _);){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                r >>>= d, _ -= d, t.back += d;
            }
            if (r >>>= w, _ -= w, t.back += w, A & 64) {
                e.msg = "invalid distance code", t.mode = T3;
                break;
            }
            t.offset = x, t.extra = A & 15, t.mode = Wt;
        case Wt:
            if (t.extra) {
                for(p = t.extra; _ < p;){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                t.offset += r & (1 << t.extra) - 1, r >>>= t.extra, _ -= t.extra, t.back += t.extra;
            }
            if (t.offset > t.dmax) {
                e.msg = "invalid distance too far back", t.mode = T3;
                break;
            }
            t.mode = Vt;
        case Vt:
            if (c === 0) break e;
            if (h = s - c, t.offset > h) {
                if (h = t.offset - h, h > t.whave && t.sane) {
                    e.msg = "invalid distance too far back", t.mode = T3;
                    break;
                }
                h > t.wnext ? (h -= t.wnext, u = t.wsize - h) : u = t.wnext - h, h > t.length && (h = t.length), m = t.window;
            } else m = a, u = o - t.offset, h = t.length;
            h > c && (h = c), c -= h, t.length -= h;
            do a[o++] = m[u++];
            while (--h)
            t.length === 0 && (t.mode = Ue4);
            break;
        case Jt:
            if (c === 0) break e;
            a[o++] = t.length, c--, t.mode = Ue4;
            break;
        case it:
            if (t.wrap) {
                for(; _ < 32;){
                    if (f === 0) break e;
                    f--, r |= n[l++] << _, _ += 8;
                }
                if (s -= c, e.total_out += s, t.total += s, s && (e.adler = t.check = t.flags ? I7(t.check, a, s, o - s) : ve5(t.check, a, s, o - s)), s = c, (t.flags ? r : ei(r)) !== t.check) {
                    e.msg = "incorrect data check", t.mode = T3;
                    break;
                }
                r = 0, _ = 0;
            }
            t.mode = Qt;
        case Qt:
            if (t.wrap && t.flags) {
                for(; _ < 32;){
                    if (f === 0) break e;
                    f--, r += n[l++] << _, _ += 8;
                }
                if (r !== (t.total & 4294967295)) {
                    e.msg = "incorrect length check", t.mode = T3;
                    break;
                }
                r = 0, _ = 0;
            }
            t.mode = qt;
        case qt:
            z = Un;
            break e;
        case T3:
            z = zi;
            break e;
        case Di1:
            return Ti;
        case Fn:
        default:
            return U7;
    }
    return e.next_out = o, e.avail_out = c, e.next_in = l, e.avail_in = f, t.hold = r, t.bits = _, (t.wsize || s !== e.avail_out && t.mode < T3 && (t.mode < it || i !== Zt)) && Li(e, e.output, e.next_out, s - e.avail_out), E -= e.avail_in, s -= e.avail_out, e.total_in += E, e.total_out += s, t.total += s, t.wrap && s && (e.adler = t.check = t.flags ? I7(t.check, a, s, e.next_out - s) : ve5(t.check, a, s, e.next_out - s)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === H7 ? 128 : 0) + (t.mode === Le4 || t.mode === tt ? 256 : 0), (E === 0 && s === 0 || i === Zt) && z === ae8 && (z = Cn), z;
}, jn = (e)=>{
    if (!e || !e.state) return U7;
    let i = e.state;
    return i.window && (i.window = null), e.state = null, ae8;
}, Wn = (e, i)=>{
    if (!e || !e.state) return U7;
    let t = e.state;
    return (t.wrap & 2) === 0 ? U7 : (t.head = i, i.done = !1, ae8);
}, Vn = (e, i)=>{
    let t = i.length, n, a, l;
    return !e || !e.state || (n = e.state, n.wrap !== 0 && n.mode !== Ke2) ? U7 : n.mode === Ke2 && (a = 1, a = ve5(a, i, t, 0), a !== n.check) ? zi : (l = Li(e, i, t, t), l ? (n.mode = Di1, Ti) : (n.havedict = 1, ae8));
}, Jn = Ii, Qn = Oi, qn = Zi, el = Xn, tl = Ni, il = Gn, al = jn, nl = Wn, ll = Vn, rl = "pako inflate (from Nodeca project)", K10 = {
    inflateReset: Jn,
    inflateReset2: Qn,
    inflateResetKeep: qn,
    inflateInit: el,
    inflateInit2: tl,
    inflate: il,
    inflateEnd: al,
    inflateGetHeader: nl,
    inflateSetDictionary: ll,
    inflateInfo: rl
};
function fl() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var ol = fl, Ui = Object.prototype.toString, { Z_NO_FLUSH: _l , Z_FINISH: hl , Z_OK: Se5 , Z_STREAM_END: lt , Z_NEED_DICT: rt , Z_STREAM_ERROR: dl , Z_DATA_ERROR: ii , Z_MEM_ERROR: sl  } = ne8;
function Te6(e) {
    this.options = Ye4.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, e || {});
    let i = this.options;
    i.raw && i.windowBits >= 0 && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), i.windowBits >= 0 && i.windowBits < 16 && !(e && e.windowBits) && (i.windowBits += 32), i.windowBits > 15 && i.windowBits < 48 && (i.windowBits & 15) === 0 && (i.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new yi, this.strm.avail_out = 0;
    let t = K10.inflateInit2(this.strm, i.windowBits);
    if (t !== Se5) throw new Error(ee10[t]);
    if (this.header = new ol, K10.inflateGetHeader(this.strm, this.header), i.dictionary && (typeof i.dictionary == "string" ? i.dictionary = ye7.string2buf(i.dictionary) : Ui.call(i.dictionary) === "[object ArrayBuffer]" && (i.dictionary = new Uint8Array(i.dictionary)), i.raw && (t = K10.inflateSetDictionary(this.strm, i.dictionary), t !== Se5))) throw new Error(ee10[t]);
}
Te6.prototype.push = function(e, i) {
    let t = this.strm, n = this.options.chunkSize, a = this.options.dictionary, l, o, f;
    if (this.ended) return !1;
    for(i === ~~i ? o = i : o = i === !0 ? hl : _l, Ui.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length;;){
        for(t.avail_out === 0 && (t.output = new Uint8Array(n), t.next_out = 0, t.avail_out = n), l = K10.inflate(t, o), l === rt && a && (l = K10.inflateSetDictionary(t, a), l === Se5 ? l = K10.inflate(t, o) : l === ii && (l = rt)); t.avail_in > 0 && l === lt && t.state.wrap > 0 && e[t.next_in] !== 0;)K10.inflateReset(t), l = K10.inflate(t, o);
        switch(l){
            case dl:
            case ii:
            case rt:
            case sl:
                return this.onEnd(l), this.ended = !0, !1;
        }
        if (f = t.avail_out, t.next_out && (t.avail_out === 0 || l === lt)) if (this.options.to === "string") {
            let c = ye7.utf8border(t.output, t.next_out), r = t.next_out - c, _ = ye7.buf2string(t.output, c);
            t.next_out = r, t.avail_out = n - r, r && t.output.set(t.output.subarray(c, c + r), 0), this.onData(_);
        } else this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
        if (!(l === Se5 && f === 0)) {
            if (l === lt) return l = K10.inflateEnd(this.strm), this.onEnd(l), this.ended = !0, !0;
            if (t.avail_in === 0) break;
        }
    }
    return !0;
};
Te6.prototype.onData = function(e) {
    this.chunks.push(e);
};
Te6.prototype.onEnd = function(e) {
    e === Se5 && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Ye4.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function wt(e, i) {
    let t = new Te6(i);
    if (t.push(e), t.err) throw t.msg || ee10[t.err];
    return t.result;
}
function cl(e, i) {
    return i = i || {}, i.raw = !0, wt(e, i);
}
var ul = Te6, bl = wt, wl = cl, gl = wt, pl = ne8, xl = {
    Inflate: ul,
    inflate: bl,
    inflateRaw: wl,
    ungzip: gl,
    constants: pl
}, { Deflate: kl , deflate: vl , deflateRaw: El , gzip: yl  } = Rn, { Inflate: Sl , inflate: Al , inflateRaw: Rl , ungzip: zl  } = xl, Tl = kl, ml = vl, Dl = El, Zl = yl, Il = Sl, Ol = Al, Nl = Rl, Ll = zl, Ul = ne8, $l = {
    Deflate: Tl,
    deflate: ml,
    deflateRaw: Dl,
    gzip: Zl,
    Inflate: Il,
    inflate: Ol,
    inflateRaw: Nl,
    ungzip: Ll,
    constants: Ul
};
function m2(t, r) {
    return t === r;
}
function h10(t, r, n) {
    if (r === null || n === null || r.length !== n.length) return !1;
    for(var e = r.length, u = 0; u < e; u++)if (!t(r[u], n[u])) return !1;
    return !0;
}
function v7(t) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : m2, n = null, e = null;
    return function() {
        return h10(r, n, arguments) || (e = t.apply(null, arguments)), n = arguments, e;
    };
}
function y5(t) {
    var r = Array.isArray(t[0]) ? t[0] : t;
    if (!r.every(function(e) {
        return typeof e == "function";
    })) {
        var n = r.map(function(e) {
            return typeof e;
        }).join(", ");
        throw new Error("Selector creators expect all input-selectors to be functions, " + ("instead received the following types: [" + n + "]"));
    }
    return r;
}
function S6(t) {
    for(var r = arguments.length, n = Array(r > 1 ? r - 1 : 0), e = 1; e < r; e++)n[e - 1] = arguments[e];
    return function() {
        for(var u = arguments.length, a = Array(u), o = 0; o < u; o++)a[o] = arguments[o];
        var l = 0, s = a.pop(), f = y5(a), p = t.apply(void 0, [
            function() {
                return l++, s.apply(null, arguments);
            }
        ].concat(n)), c = t(function() {
            for(var g = [], d = f.length, i = 0; i < d; i++)g.push(f[i].apply(null, arguments));
            return p.apply(null, g);
        });
        return c.resultFunc = s, c.dependencies = f, c.recomputations = function() {
            return l;
        }, c.resetRecomputations = function() {
            return l = 0;
        }, c;
    };
}
var w5 = S6(v7);
function u3(n) {
    return n == null;
}
function a6(n) {
    throw new Error("Argument " + n + " is empty.");
}
function d5(n) {
    return typeof n == "function" && "getType" in n;
}
function g9(n) {
    throw new Error("Argument " + n + ' is invalid, it should be an action-creator instance from "typesafe-actions"');
}
function m3(n) {
    return typeof n == "string" || typeof n == "symbol";
}
function f5(n) {
    return !m3(n);
}
function l3(n) {
    throw new Error("Argument " + n + " is invalid, it should be an action type of type: string | symbol");
}
function E5(n, t) {
    return u3(n) && a6(1), f5(n) && l3(1), Object.assign(function() {
        var r = t != null ? t.apply(void 0, arguments) : void 0;
        return Object.assign({
            type: n
        }, r);
    }, {
        getType: function() {
            return n;
        },
        toString: function() {
            return n;
        }
    });
}
function h11(n, t, r) {
    return u3(n) && a6(1), f5(n) && l3(1), function() {
        return E5(n, function() {
            var i = arguments.length <= 0 ? void 0 : arguments[0], e = arguments.length <= 1 ? void 0 : arguments[1];
            return t == null && r == null || (i = t != null ? t.apply(void 0, arguments) : void 0, e = r != null ? r.apply(void 0, arguments) : void 0), Object.assign({}, i !== void 0 && {
                payload: i
            }, {}, e !== void 0 && {
                meta: e
            });
        });
    };
}
function j10(n) {
    return u3(n) && a6(1), d5(n) || g9(1), n.getType();
}
function T4(n, t) {
    t === void 0 && (t = {});
    var r = Object.assign({}, t), i = function(e, o) {
        var c = Array.isArray(e) ? e : [
            e
        ], y = {};
        return c.map(function(s, b) {
            return d5(s) ? j10(s) : m3(s) ? s : function(A) {
                throw new Error("Argument " + A + ' is invalid, it should be an action-creator instance from "typesafe-actions" or action type of type: string | symbol');
            }(b + 1);
        }).forEach(function(s) {
            return y[s] = o;
        }), T4(n, Object.assign({}, r, {}, y));
    };
    return Object.assign(function(e, o) {
        if (e === void 0 && (e = n), r.hasOwnProperty(o.type)) {
            var c = r[o.type];
            if (typeof c != "function") throw Error('Reducer under "' + o.type + '" key is not a valid reducer');
            return c(e, o);
        }
        return e;
    }, {
        handlers: Object.assign({}, r),
        handleAction: i,
        handleType: i
    });
}
var ve6 = Object.create;
var ce6 = Object.defineProperty;
var ye8 = Object.getOwnPropertyDescriptor;
var ke5 = Object.getOwnPropertyNames;
var be6 = Object.getPrototypeOf, we8 = Object.prototype.hasOwnProperty;
var Ee6 = (A, l)=>()=>(l || A((l = {
            exports: {}
        }).exports, l), l.exports);
var Ce10 = (A, l, q, G)=>{
    if (l && typeof l == "object" || typeof l == "function") for (let N of ke5(l))!we8.call(A, N) && N !== q && ce6(A, N, {
        get: ()=>l[N],
        enumerable: !(G = ye8(l, N)) || G.enumerable
    });
    return A;
};
var Re5 = (A, l, q)=>(q = A != null ? ve6(be6(A)) : {}, Ce10(l || !A || !A.__esModule ? ce6(q, "default", {
        value: A,
        enumerable: !0
    }) : q, A));
var pe10 = Ee6((he, ue)=>{
    (function(A, l) {
        typeof define == "function" && define.amd ? define([], l) : typeof ue == "object" && typeof he < "u" ? ue.exports = l() : A.Papa = l();
    })(he, function A() {
        "use strict";
        var l = typeof self < "u" ? self : typeof document < "u" ? window : l !== void 0 ? l : {}, q = !l.document && !!l.postMessage, G = q && /blob:/i.test((l.location || {}).protocol), N = {}, ge = 0, u = {
            parse: function(t, e) {
                var i = (e = e || {}).dynamicTyping || !1;
                if (y(i) && (e.dynamicTypingFunction = i, i = {}), e.dynamicTyping = i, e.transform = !!y(e.transform) && e.transform, e.worker && u.WORKERS_SUPPORTED) {
                    var r = function() {
                        if (!u.WORKERS_SUPPORTED) return !1;
                        var f = (I = l.URL || l.webkitURL || null, w = A.toString(), u.BLOB_URL || (u.BLOB_URL = I.createObjectURL(new Blob([
                            "(",
                            w,
                            ")();"
                        ], {
                            type: "text/javascript"
                        })))), g = new l.Worker(f), I, w;
                        return g.onmessage = _e, g.id = ge++, N[g.id] = g;
                    }();
                    return r.userStep = e.step, r.userChunk = e.chunk, r.userComplete = e.complete, r.userError = e.error, e.step = y(e.step), e.chunk = y(e.chunk), e.complete = y(e.complete), e.error = y(e.error), delete e.worker, void r.postMessage({
                        input: t,
                        config: e,
                        workerId: r.id
                    });
                }
                var s = null;
                return u.NODE_STREAM_INPUT, typeof t == "string" ? s = e.download ? new ie(e) : new ee(e) : t.readable === !0 && y(t.read) && y(t.on) ? s = new ne(e) : (l.File && t instanceof File || t instanceof Object) && (s = new re(e)), s.stream(t);
            },
            unparse: function(t, e) {
                var i = !1, r = !0, s = ",", f = `\r
`, g = '"', I = g + g, w = !1, n = null, O = !1;
                (function() {
                    if (typeof e == "object") {
                        if (typeof e.delimiter != "string" || u.BAD_DELIMITERS.filter(function(_) {
                            return e.delimiter.indexOf(_) !== -1;
                        }).length || (s = e.delimiter), (typeof e.quotes == "boolean" || typeof e.quotes == "function" || Array.isArray(e.quotes)) && (i = e.quotes), typeof e.skipEmptyLines != "boolean" && typeof e.skipEmptyLines != "string" || (w = e.skipEmptyLines), typeof e.newline == "string" && (f = e.newline), typeof e.quoteChar == "string" && (g = e.quoteChar), typeof e.header == "boolean" && (r = e.header), Array.isArray(e.columns)) {
                            if (e.columns.length === 0) throw new Error("Option columns is empty");
                            n = e.columns;
                        }
                        e.escapeChar !== void 0 && (I = e.escapeChar + g), typeof e.escapeFormulae == "boolean" && (O = e.escapeFormulae);
                    }
                })();
                var a = new RegExp(te(g), "g");
                if (typeof t == "string" && (t = JSON.parse(t)), Array.isArray(t)) {
                    if (!t.length || Array.isArray(t[0])) return T(null, t, w);
                    if (typeof t[0] == "object") return T(n || W(t[0]), t, w);
                } else if (typeof t == "object") return typeof t.data == "string" && (t.data = JSON.parse(t.data)), Array.isArray(t.data) && (t.fields || (t.fields = t.meta && t.meta.fields), t.fields || (t.fields = Array.isArray(t.data[0]) ? t.fields : W(t.data[0])), Array.isArray(t.data[0]) || typeof t.data[0] == "object" || (t.data = [
                    t.data
                ])), T(t.fields || [], t.data || [], w);
                throw new Error("Unable to serialize unrecognized input");
                function W(_) {
                    if (typeof _ != "object") return [];
                    var v = [];
                    for(var S in _)v.push(S);
                    return v;
                }
                function T(_, v, S) {
                    var D = "";
                    typeof _ == "string" && (_ = JSON.parse(_)), typeof v == "string" && (v = JSON.parse(v));
                    var x = Array.isArray(_) && 0 < _.length, F = !Array.isArray(v[0]);
                    if (x && r) {
                        for(var o = 0; o < _.length; o++)0 < o && (D += s), D += d(_[o], o);
                        0 < v.length && (D += f);
                    }
                    for(var c = 0; c < v.length; c++){
                        var k = x ? _.length : v[c].length, b = !1, p = x ? Object.keys(v[c]).length === 0 : v[c].length === 0;
                        if (S && !x && (b = S === "greedy" ? v[c].join("").trim() === "" : v[c].length === 1 && v[c][0].length === 0), S === "greedy" && x) {
                            for(var m = [], E = 0; E < k; E++){
                                var h = F ? _[E] : E;
                                m.push(v[c][h]);
                            }
                            b = m.join("").trim() === "";
                        }
                        if (!b) {
                            for(var C = 0; C < k; C++){
                                0 < C && !p && (D += s);
                                var U = x && F ? _[C] : C;
                                D += d(v[c][U], C);
                            }
                            c < v.length - 1 && (!S || 0 < k && !p) && (D += f);
                        }
                    }
                    return D;
                }
                function d(_, v) {
                    if (_ == null) return "";
                    if (_.constructor === Date) return JSON.stringify(_).slice(1, 25);
                    O === !0 && typeof _ == "string" && _.match(/^[=+\-@].*$/) !== null && (_ = "'" + _);
                    var S = _.toString().replace(a, I), D = typeof i == "boolean" && i || typeof i == "function" && i(_, v) || Array.isArray(i) && i[v] || function(x, F) {
                        for(var o = 0; o < F.length; o++)if (-1 < x.indexOf(F[o])) return !0;
                        return !1;
                    }(S, u.BAD_DELIMITERS) || -1 < S.indexOf(s) || S.charAt(0) === " " || S.charAt(S.length - 1) === " ";
                    return D ? g + S + g : S;
                }
            }
        };
        if (u.RECORD_SEP = String.fromCharCode(30), u.UNIT_SEP = String.fromCharCode(31), u.BYTE_ORDER_MARK = "\uFEFF", u.BAD_DELIMITERS = [
            "\r",
            `
`,
            '"',
            u.BYTE_ORDER_MARK
        ], u.WORKERS_SUPPORTED = !q && !!l.Worker, u.NODE_STREAM_INPUT = 1, u.LocalChunkSize = 10485760, u.RemoteChunkSize = 5242880, u.DefaultDelimiter = ",", u.Parser = se, u.ParserHandle = fe, u.NetworkStreamer = ie, u.FileStreamer = re, u.StringStreamer = ee, u.ReadableStreamStreamer = ne, l.jQuery) {
            var V = l.jQuery;
            V.fn.parse = function(t) {
                var e = t.config || {}, i = [];
                return this.each(function(f) {
                    if (!(V(this).prop("tagName").toUpperCase() === "INPUT" && V(this).attr("type").toLowerCase() === "file" && l.FileReader) || !this.files || this.files.length === 0) return !0;
                    for(var g = 0; g < this.files.length; g++)i.push({
                        file: this.files[g],
                        inputElem: this,
                        instanceConfig: V.extend({}, e)
                    });
                }), r(), this;
                function r() {
                    if (i.length !== 0) {
                        var f, g, I, w, n = i[0];
                        if (y(t.before)) {
                            var O = t.before(n.file, n.inputElem);
                            if (typeof O == "object") {
                                if (O.action === "abort") return f = "AbortError", g = n.file, I = n.inputElem, w = O.reason, void (y(t.error) && t.error({
                                    name: f
                                }, g, I, w));
                                if (O.action === "skip") return void s();
                                typeof O.config == "object" && (n.instanceConfig = V.extend(n.instanceConfig, O.config));
                            } else if (O === "skip") return void s();
                        }
                        var a = n.instanceConfig.complete;
                        n.instanceConfig.complete = function(W) {
                            y(a) && a(W, n.file, n.inputElem), s();
                        }, u.parse(n.file, n.instanceConfig);
                    } else y(t.complete) && t.complete();
                }
                function s() {
                    i.splice(0, 1), r();
                }
            };
        }
        function K(t) {
            this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = {
                data: [],
                errors: [],
                meta: {}
            }, (function(e) {
                var i = ae(e);
                i.chunkSize = parseInt(i.chunkSize), e.step || e.chunk || (i.chunkSize = null), this._handle = new fe(i), (this._handle.streamer = this)._config = i;
            }).call(this, t), this.parseChunk = function(e, i) {
                if (this.isFirstChunk && y(this._config.beforeFirstChunk)) {
                    var r = this._config.beforeFirstChunk(e);
                    r !== void 0 && (e = r);
                }
                this.isFirstChunk = !1, this._halted = !1;
                var s = this._partialLine + e;
                this._partialLine = "";
                var f = this._handle.parse(s, this._baseIndex, !this._finished);
                if (!this._handle.paused() && !this._handle.aborted()) {
                    var g = f.meta.cursor;
                    this._finished || (this._partialLine = s.substring(g - this._baseIndex), this._baseIndex = g), f && f.data && (this._rowCount += f.data.length);
                    var I = this._finished || this._config.preview && this._rowCount >= this._config.preview;
                    if (G) l.postMessage({
                        results: f,
                        workerId: u.WORKER_ID,
                        finished: I
                    });
                    else if (y(this._config.chunk) && !i) {
                        if (this._config.chunk(f, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
                        f = void 0, this._completeResults = void 0;
                    }
                    return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(f.data), this._completeResults.errors = this._completeResults.errors.concat(f.errors), this._completeResults.meta = f.meta), this._completed || !I || !y(this._config.complete) || f && f.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), I || f && f.meta.paused || this._nextChunk(), f;
                }
                this._halted = !0;
            }, this._sendError = function(e) {
                y(this._config.error) ? this._config.error(e) : G && this._config.error && l.postMessage({
                    workerId: u.WORKER_ID,
                    error: e,
                    finished: !1
                });
            };
        }
        function ie(t) {
            var e;
            (t = t || {}).chunkSize || (t.chunkSize = u.RemoteChunkSize), K.call(this, t), this._nextChunk = q ? function() {
                this._readChunk(), this._chunkLoaded();
            } : function() {
                this._readChunk();
            }, this.stream = function(i) {
                this._input = i, this._nextChunk();
            }, this._readChunk = function() {
                if (this._finished) this._chunkLoaded();
                else {
                    if (e = new XMLHttpRequest, this._config.withCredentials && (e.withCredentials = this._config.withCredentials), q || (e.onload = $(this._chunkLoaded, this), e.onerror = $(this._chunkError, this)), e.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !q), this._config.downloadRequestHeaders) {
                        var i = this._config.downloadRequestHeaders;
                        for(var r in i)e.setRequestHeader(r, i[r]);
                    }
                    if (this._config.chunkSize) {
                        var s = this._start + this._config.chunkSize - 1;
                        e.setRequestHeader("Range", "bytes=" + this._start + "-" + s);
                    }
                    try {
                        e.send(this._config.downloadRequestBody);
                    } catch (f) {
                        this._chunkError(f.message);
                    }
                    q && e.status === 0 && this._chunkError();
                }
            }, this._chunkLoaded = function() {
                e.readyState === 4 && (e.status < 200 || 400 <= e.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : e.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(i) {
                    var r = i.getResponseHeader("Content-Range");
                    return r === null ? -1 : parseInt(r.substring(r.lastIndexOf("/") + 1));
                }(e), this.parseChunk(e.responseText)));
            }, this._chunkError = function(i) {
                var r = e.statusText || i;
                this._sendError(new Error(r));
            };
        }
        function re(t) {
            var e, i;
            (t = t || {}).chunkSize || (t.chunkSize = u.LocalChunkSize), K.call(this, t);
            var r = typeof FileReader < "u";
            this.stream = function(s) {
                this._input = s, i = s.slice || s.webkitSlice || s.mozSlice, r ? ((e = new FileReader).onload = $(this._chunkLoaded, this), e.onerror = $(this._chunkError, this)) : e = new FileReaderSync, this._nextChunk();
            }, this._nextChunk = function() {
                this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
            }, this._readChunk = function() {
                var s = this._input;
                if (this._config.chunkSize) {
                    var f = Math.min(this._start + this._config.chunkSize, this._input.size);
                    s = i.call(s, this._start, f);
                }
                var g = e.readAsText(s, this._config.encoding);
                r || this._chunkLoaded({
                    target: {
                        result: g
                    }
                });
            }, this._chunkLoaded = function(s) {
                this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(s.target.result);
            }, this._chunkError = function() {
                this._sendError(e.error);
            };
        }
        function ee(t) {
            var e;
            K.call(this, t = t || {}), this.stream = function(i) {
                return e = i, this._nextChunk();
            }, this._nextChunk = function() {
                if (!this._finished) {
                    var i, r = this._config.chunkSize;
                    return r ? (i = e.substring(0, r), e = e.substring(r)) : (i = e, e = ""), this._finished = !e, this.parseChunk(i);
                }
            };
        }
        function ne(t) {
            K.call(this, t = t || {});
            var e = [], i = !0, r = !1;
            this.pause = function() {
                K.prototype.pause.apply(this, arguments), this._input.pause();
            }, this.resume = function() {
                K.prototype.resume.apply(this, arguments), this._input.resume();
            }, this.stream = function(s) {
                this._input = s, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
            }, this._checkIsFinished = function() {
                r && e.length === 1 && (this._finished = !0);
            }, this._nextChunk = function() {
                this._checkIsFinished(), e.length ? this.parseChunk(e.shift()) : i = !0;
            }, this._streamData = $(function(s) {
                try {
                    e.push(typeof s == "string" ? s : s.toString(this._config.encoding)), i && (i = !1, this._checkIsFinished(), this.parseChunk(e.shift()));
                } catch (f) {
                    this._streamError(f);
                }
            }, this), this._streamError = $(function(s) {
                this._streamCleanUp(), this._sendError(s);
            }, this), this._streamEnd = $(function() {
                this._streamCleanUp(), r = !0, this._streamData("");
            }, this), this._streamCleanUp = $(function() {
                this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
            }, this);
        }
        function fe(t) {
            var e, i, r, s = Math.pow(2, 53), f = -s, g = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)(e[-+]?\d+)?\s*$/, I = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/, w = this, n = 0, O = 0, a = !1, W = !1, T = [], d = {
                data: [],
                errors: [],
                meta: {}
            };
            if (y(t.step)) {
                var _ = t.step;
                t.step = function(o) {
                    if (d = o, D()) S();
                    else {
                        if (S(), d.data.length === 0) return;
                        n += o.data.length, t.preview && n > t.preview ? i.abort() : (d.data = d.data[0], _(d, w));
                    }
                };
            }
            function v(o) {
                return t.skipEmptyLines === "greedy" ? o.join("").trim() === "" : o.length === 1 && o[0].length === 0;
            }
            function S() {
                if (d && r && (F("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + u.DefaultDelimiter + "'"), r = !1), t.skipEmptyLines) for(var o = 0; o < d.data.length; o++)v(d.data[o]) && d.data.splice(o--, 1);
                return D() && function() {
                    if (!d) return;
                    function c(b, p) {
                        y(t.transformHeader) && (b = t.transformHeader(b, p)), T.push(b);
                    }
                    if (Array.isArray(d.data[0])) {
                        for(var k = 0; D() && k < d.data.length; k++)d.data[k].forEach(c);
                        d.data.splice(0, 1);
                    } else d.data.forEach(c);
                }(), function() {
                    if (!d || !t.header && !t.dynamicTyping && !t.transform) return d;
                    function c(b, p) {
                        var m, E = t.header ? {} : [];
                        for(m = 0; m < b.length; m++){
                            var h = m, C = b[m];
                            t.header && (h = m >= T.length ? "__parsed_extra" : T[m]), t.transform && (C = t.transform(C, h)), C = x(h, C), h === "__parsed_extra" ? (E[h] = E[h] || [], E[h].push(C)) : E[h] = C;
                        }
                        return t.header && (m > T.length ? F("FieldMismatch", "TooManyFields", "Too many fields: expected " + T.length + " fields but parsed " + m, O + p) : m < T.length && F("FieldMismatch", "TooFewFields", "Too few fields: expected " + T.length + " fields but parsed " + m, O + p)), E;
                    }
                    var k = 1;
                    return !d.data.length || Array.isArray(d.data[0]) ? (d.data = d.data.map(c), k = d.data.length) : d.data = c(d.data, 0), t.header && d.meta && (d.meta.fields = T), O += k, d;
                }();
            }
            function D() {
                return t.header && T.length === 0;
            }
            function x(o, c) {
                return k = o, t.dynamicTypingFunction && t.dynamicTyping[k] === void 0 && (t.dynamicTyping[k] = t.dynamicTypingFunction(k)), (t.dynamicTyping[k] || t.dynamicTyping) === !0 ? c === "true" || c === "TRUE" || c !== "false" && c !== "FALSE" && (function(b) {
                    if (g.test(b)) {
                        var p = parseFloat(b);
                        if (f < p && p < s) return !0;
                    }
                    return !1;
                }(c) ? parseFloat(c) : I.test(c) ? new Date(c) : c === "" ? null : c) : c;
                var k;
            }
            function F(o, c, k, b) {
                var p = {
                    type: o,
                    code: c,
                    message: k
                };
                b !== void 0 && (p.row = b), d.errors.push(p);
            }
            this.parse = function(o, c, k) {
                var b = t.quoteChar || '"';
                if (t.newline || (t.newline = function(E, h) {
                    E = E.substring(0, 1048576);
                    var C = new RegExp(te(h) + "([^]*?)" + te(h), "gm"), U = (E = E.replace(C, "")).split("\r"), P = E.split(`
`), B = 1 < P.length && P[0].length < U[0].length;
                    if (U.length === 1 || B) return `
`;
                    for(var H = 0, z = 0; z < U.length; z++)U[z][0] === `
` && H++;
                    return H >= U.length / 2 ? `\r
` : "\r";
                }(o, b)), r = !1, t.delimiter) y(t.delimiter) && (t.delimiter = t.delimiter(o), d.meta.delimiter = t.delimiter);
                else {
                    var p = function(E, h, C, U, P) {
                        var B, H, z, Y;
                        P = P || [
                            ",",
                            "	",
                            "|",
                            ";",
                            u.RECORD_SEP,
                            u.UNIT_SEP
                        ];
                        for(var L = 0; L < P.length; L++){
                            var Z = P[L], X = 0, R = 0, Q = 0;
                            z = void 0;
                            for(var M = new se({
                                comments: U,
                                delimiter: Z,
                                newline: h,
                                preview: 10
                            }).parse(E), J = 0; J < M.data.length; J++)if (C && v(M.data[J])) Q++;
                            else {
                                var j = M.data[J].length;
                                R += j, z !== void 0 ? 0 < j && (X += Math.abs(j - z), z = j) : z = j;
                            }
                            0 < M.data.length && (R /= M.data.length - Q), (H === void 0 || X <= H) && (Y === void 0 || Y < R) && 1.99 < R && (H = X, B = Z, Y = R);
                        }
                        return {
                            successful: !!(t.delimiter = B),
                            bestDelimiter: B
                        };
                    }(o, t.newline, t.skipEmptyLines, t.comments, t.delimitersToGuess);
                    p.successful ? t.delimiter = p.bestDelimiter : (r = !0, t.delimiter = u.DefaultDelimiter), d.meta.delimiter = t.delimiter;
                }
                var m = ae(t);
                return t.preview && t.header && m.preview++, e = o, i = new se(m), d = i.parse(e, c, k), S(), a ? {
                    meta: {
                        paused: !0
                    }
                } : d || {
                    meta: {
                        paused: !1
                    }
                };
            }, this.paused = function() {
                return a;
            }, this.pause = function() {
                a = !0, i.abort(), e = y(t.chunk) ? "" : e.substring(i.getCharIndex());
            }, this.resume = function() {
                w.streamer._halted ? (a = !1, w.streamer.parseChunk(e, !0)) : setTimeout(w.resume, 3);
            }, this.aborted = function() {
                return W;
            }, this.abort = function() {
                W = !0, i.abort(), d.meta.aborted = !0, y(t.complete) && t.complete(d), e = "";
            };
        }
        function te(t) {
            return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function se(t) {
            var e, i = (t = t || {}).delimiter, r = t.newline, s = t.comments, f = t.step, g = t.preview, I = t.fastMode, w = e = t.quoteChar === void 0 ? '"' : t.quoteChar;
            if (t.escapeChar !== void 0 && (w = t.escapeChar), (typeof i != "string" || -1 < u.BAD_DELIMITERS.indexOf(i)) && (i = ","), s === i) throw new Error("Comment character same as delimiter");
            s === !0 ? s = "#" : (typeof s != "string" || -1 < u.BAD_DELIMITERS.indexOf(s)) && (s = !1), r !== `
` && r !== "\r" && r !== `\r
` && (r = `
`);
            var n = 0, O = !1;
            this.parse = function(a, W, T) {
                if (typeof a != "string") throw new Error("Input must be a string");
                var d = a.length, _ = i.length, v = r.length, S = s.length, D = y(f), x = [], F = [], o = [], c = n = 0;
                if (!a) return L();
                if (I || I !== !1 && a.indexOf(e) === -1) {
                    for(var k = a.split(r), b = 0; b < k.length; b++){
                        if (o = k[b], n += o.length, b !== k.length - 1) n += r.length;
                        else if (T) return L();
                        if (!s || o.substring(0, S) !== s) {
                            if (D) {
                                if (x = [], B(o.split(i)), Z(), O) return L();
                            } else B(o.split(i));
                            if (g && g <= b) return x = x.slice(0, g), L(!0);
                        }
                    }
                    return L();
                }
                for(var p = a.indexOf(i, n), m = a.indexOf(r, n), E = new RegExp(te(w) + te(e), "g"), h = a.indexOf(e, n);;)if (a[n] !== e) if (s && o.length === 0 && a.substring(n, n + S) === s) {
                    if (m === -1) return L();
                    n = m + v, m = a.indexOf(r, n), p = a.indexOf(i, n);
                } else {
                    if (p !== -1 && (p < m || m === -1)) {
                        if (!(p < h)) {
                            o.push(a.substring(n, p)), n = p + _, p = a.indexOf(i, n);
                            continue;
                        }
                        var C = X(p, h, m);
                        if (C && C.nextDelim !== void 0) {
                            p = C.nextDelim, h = C.quoteSearch, o.push(a.substring(n, p)), n = p + _, p = a.indexOf(i, n);
                            continue;
                        }
                    }
                    if (m === -1) break;
                    if (o.push(a.substring(n, m)), Y(m + v), D && (Z(), O)) return L();
                    if (g && x.length >= g) return L(!0);
                }
                else for(h = n, n++;;){
                    if ((h = a.indexOf(e, h + 1)) === -1) return T || F.push({
                        type: "Quotes",
                        code: "MissingQuotes",
                        message: "Quoted field unterminated",
                        row: x.length,
                        index: n
                    }), z();
                    if (h === d - 1) return z(a.substring(n, h).replace(E, e));
                    if (e !== w || a[h + 1] !== w) {
                        if (e === w || h === 0 || a[h - 1] !== w) {
                            p !== -1 && p < h + 1 && (p = a.indexOf(i, h + 1)), m !== -1 && m < h + 1 && (m = a.indexOf(r, h + 1));
                            var U = H(m === -1 ? p : Math.min(p, m));
                            if (a[h + 1 + U] === i) {
                                o.push(a.substring(n, h).replace(E, e)), a[n = h + 1 + U + _] !== e && (h = a.indexOf(e, n)), p = a.indexOf(i, n), m = a.indexOf(r, n);
                                break;
                            }
                            var P = H(m);
                            if (a.substring(h + 1 + P, h + 1 + P + v) === r) {
                                if (o.push(a.substring(n, h).replace(E, e)), Y(h + 1 + P + v), p = a.indexOf(i, n), h = a.indexOf(e, n), D && (Z(), O)) return L();
                                if (g && x.length >= g) return L(!0);
                                break;
                            }
                            F.push({
                                type: "Quotes",
                                code: "InvalidQuotes",
                                message: "Trailing quote on quoted field is malformed",
                                row: x.length,
                                index: n
                            }), h++;
                        }
                    } else h++;
                }
                return z();
                function B(R) {
                    x.push(R), c = n;
                }
                function H(R) {
                    var Q = 0;
                    if (R !== -1) {
                        var M = a.substring(h + 1, R);
                        M && M.trim() === "" && (Q = M.length);
                    }
                    return Q;
                }
                function z(R) {
                    return T || (R === void 0 && (R = a.substring(n)), o.push(R), n = d, B(o), D && Z()), L();
                }
                function Y(R) {
                    n = R, B(o), o = [], m = a.indexOf(r, n);
                }
                function L(R) {
                    return {
                        data: x,
                        errors: F,
                        meta: {
                            delimiter: i,
                            linebreak: r,
                            aborted: O,
                            truncated: !!R,
                            cursor: c + (W || 0)
                        }
                    };
                }
                function Z() {
                    f(L()), x = [], F = [];
                }
                function X(R, Q, M) {
                    var J = {
                        nextDelim: void 0,
                        quoteSearch: void 0
                    }, j = a.indexOf(e, Q + 1);
                    if (Q < R && R < j && (j < M || M === -1)) {
                        var oe = a.indexOf(i, j);
                        if (oe === -1) return J;
                        j < oe && (j = a.indexOf(e, j + 1)), J = X(oe, j, M);
                    } else J = {
                        nextDelim: R,
                        quoteSearch: Q
                    };
                    return J;
                }
            }, this.abort = function() {
                O = !0;
            }, this.getCharIndex = function() {
                return n;
            };
        }
        function _e(t) {
            var e = t.data, i = N[e.workerId], r = !1;
            if (e.error) i.userError(e.error, e.file);
            else if (e.results && e.results.data) {
                var s = {
                    abort: function() {
                        r = !0, de(e.workerId, {
                            data: [],
                            errors: [],
                            meta: {
                                aborted: !0
                            }
                        });
                    },
                    pause: le,
                    resume: le
                };
                if (y(i.userStep)) {
                    for(var f = 0; f < e.results.data.length && (i.userStep({
                        data: e.results.data[f],
                        errors: e.results.errors,
                        meta: e.results.meta
                    }, s), !r); f++);
                    delete e.results;
                } else y(i.userChunk) && (i.userChunk(e.results, s, e.file), delete e.results);
            }
            e.finished && !r && de(e.workerId, e.results);
        }
        function de(t, e) {
            var i = N[t];
            y(i.userComplete) && i.userComplete(e), i.terminate(), delete N[t];
        }
        function le() {
            throw new Error("Not implemented.");
        }
        function ae(t) {
            if (typeof t != "object" || t === null) return t;
            var e = Array.isArray(t) ? [] : {};
            for(var i in t)e[i] = ae(t[i]);
            return e;
        }
        function $(t, e) {
            return function() {
                t.apply(e, arguments);
            };
        }
        function y(t) {
            return typeof t == "function";
        }
        return G && (l.onmessage = function(t) {
            var e = t.data;
            if (u.WORKER_ID === void 0 && e && (u.WORKER_ID = e.workerId), typeof e.input == "string") l.postMessage({
                workerId: u.WORKER_ID,
                results: u.parse(e.input, e.config),
                finished: !0
            });
            else if (l.File && e.input instanceof File || e.input instanceof Object) {
                var i = u.parse(e.input, e.config);
                i && l.postMessage({
                    workerId: u.WORKER_ID,
                    results: i,
                    finished: !0
                });
            }
        }), (ie.prototype = Object.create(K.prototype)).constructor = ie, (re.prototype = Object.create(K.prototype)).constructor = re, (ee.prototype = Object.create(ee.prototype)).constructor = ee, (ne.prototype = Object.create(K.prototype)).constructor = ne, u;
    });
});
var Se6 = Re5(pe10()), { default: me7 , ...xe7 } = Se6;
function cond(value, message) {
    if (!value) {
        throw new Error(message);
    }
}
function nonNull(value, message) {
    cond(value != null, message);
}
function bigint(value, message) {
    cond(typeof value === "bigint", message);
}
function number(value, message) {
    cond(typeof value === "number" && !isNaN(value), message);
}
function string(value, message) {
    cond(typeof value === "string", message);
}
function array(value, message) {
    cond(Array.isArray(value), message);
}
function bigintArray(value, message) {
    array(value, message);
    for(let i = 0; i < value.length; ++i){
        bigint(value[i], message);
    }
}
function numArray(value, message) {
    array(value, message);
    for(let i = 0; i < value.length; ++i){
        number(value[i], message);
    }
}
function strArray(value, message) {
    cond(Array.isArray(value), message);
    for(let i = 0; i < value.length; ++i){
        string(value[i], message);
    }
}
function strArray2D(value, message) {
    array(value, message);
    for(let i = 0; i < value.length; ++i){
        strArray(value[i], message);
    }
}
function strArray3D(value, message) {
    array(value, message);
    for(let i = 0; i < value.length; ++i){
        strArray2D(value[i], message);
    }
}
function parseWithName(value, names) {
    const numValue = Number(value);
    if (!isNaN(numValue)) {
        return numValue;
    } else if (names.has(value)) {
        return names.get(value);
    } else {
        return null;
    }
}
function parse1(fileName, rows, names) {
    const template = {
        base: new Map(),
        maxBase: new Map(),
        mark: new Map(),
        exp: new Map(),
        abl: new Map(),
        talent: new Map(),
        relation: new Map(),
        cflag: new Map(),
        equip: new Map(),
        juel: new Map(),
        cstr: new Map()
    };
    for (const row of rows){
        switch(row[0]){
            case "":
                {
                    const no = parseInt(row[1]);
                    number(no, `NO in ${fileName} should be an integer`);
                    template.no = no;
                    break;
                }
            case "":
                {
                    template.name = row[1];
                    break;
                }
            case "":
                {
                    template.callname = row[1];
                    break;
                }
            case "":
                {
                    template.nickname = row[1];
                    break;
                }
            case "":
                {
                    template.mastername = row[1];
                    break;
                }
            case "":
                {
                    const index = parseWithName(row[1], names.base);
                    cond(index != null, `Base index in ${fileName} should be an integer`);
                    let value;
                    if (row[2] != null && row[2] !== "") {
                        value = parseInt(row[2]);
                    } else {
                        value = 1;
                    }
                    number(value, `Base value in ${fileName} should be an integer`);
                    template.base.set(index, value);
                    template.maxBase.set(index, value);
                    break;
                }
            case "":
                {
                    const index1 = parseWithName(row[1], names.mark);
                    cond(index1 != null, `Mark index in ${fileName} should be an integer`);
                    let value1;
                    if (row[2] != null && row[2] !== "") {
                        value1 = parseInt(row[2]);
                    } else {
                        value1 = 1;
                    }
                    template.mark.set(index1, value1);
                    break;
                }
            case "":
                {
                    const index2 = parseWithName(row[1], names.exp);
                    cond(index2 != null, `Exp index in ${fileName} should be an integer`);
                    let value2;
                    if (row[2] != null && row[2] !== "") {
                        value2 = parseInt(row[2]);
                    } else {
                        value2 = 1;
                    }
                    number(value2, `Exp value in ${fileName} should be an integer`);
                    template.exp.set(index2, value2);
                    break;
                }
            case "":
                {
                    const index3 = parseWithName(row[1], names.abl);
                    cond(index3 != null, `Abl index in ${fileName} should be an integer`);
                    let value3;
                    if (row[2] != null && row[2] !== "") {
                        value3 = parseInt(row[2]);
                    } else {
                        value3 = 1;
                    }
                    number(value3, `Abl value in ${fileName} should be an integer`);
                    template.abl.set(index3, value3);
                    break;
                }
            case "":
                {
                    const index4 = parseWithName(row[1], names.talent);
                    cond(index4 != null, `Talent index in ${fileName} should be an integer`);
                    let value4;
                    if (row[2] != null && row[2] !== "") {
                        value4 = parseInt(row[2]);
                    } else {
                        value4 = 1;
                    }
                    number(value4, `Talent value in ${fileName} should be an integer`);
                    template.talent.set(index4, value4);
                    break;
                }
            case "":
                {
                    const index5 = parseInt(row[1]);
                    number(index5, `Relation index in ${fileName} should be an integer`);
                    let value5;
                    if (row[2] != null && row[2] !== "") {
                        value5 = parseInt(row[2]);
                    } else {
                        value5 = 1;
                    }
                    number(value5, `Relation value in ${fileName} should be an integer`);
                    template.relation.set(index5, value5);
                    break;
                }
            case "":
                {
                    const index6 = parseWithName(row[1], names.cflag);
                    cond(index6 != null, `Flag index in ${fileName} should be an integer`);
                    let value6;
                    if (row[2] != null && row[2] !== "") {
                        value6 = parseInt(row[2]);
                    } else {
                        value6 = 1;
                    }
                    number(value6, `Flag value in ${fileName} should be an integer`);
                    template.cflag.set(index6, value6);
                    break;
                }
            case "":
                {
                    const index7 = parseWithName(row[1], names.equip);
                    cond(index7 != null, `Equip index in ${fileName} should be an integer`);
                    let value7;
                    if (row[2] != null && row[2] !== "") {
                        value7 = parseInt(row[2]);
                    } else {
                        value7 = 1;
                    }
                    number(value7, `Equip value in ${fileName} should be an integer`);
                    template.equip.set(index7, value7);
                    break;
                }
            case "":
                {
                    const index8 = parseWithName(row[1], names.juel);
                    cond(index8 != null, `Juel index in ${fileName} should be an integer`);
                    let value8;
                    if (row[2] != null && row[2] !== "") {
                        value8 = parseInt(row[2]);
                    } else {
                        value8 = 1;
                    }
                    number(value8, `Juel value in ${fileName} should be an integer`);
                    template.juel.set(index8, value8);
                    break;
                }
            case "CSTR":
                {
                    const index9 = parseWithName(row[1], names.cstr);
                    cond(index9 != null, `Cstr index in ${fileName} should be an integer`);
                    const value9 = row[2];
                    template.cstr.set(index9, value9);
                    break;
                }
        }
    }
    cond(template.no != null, `ID should be defined in ${fileName}`);
    if (template.name == null) template.name = "";
    if (template.callname == null) template.callname = "";
    if (template.nickname == null) template.nickname = "";
    if (template.mastername == null) template.mastername = "";
    return template;
}
function parse2(fileName, rows) {
    const result = {};
    for (const row of rows){
        switch(row[0]){
            case "":
                result.author = row[1];
                break;
            case "":
                result.info = row[1];
                break;
            case "":
                result.year = row[1];
                break;
            case "":
                result.title = row[1];
                break;
            case "":
                {
                    const code = parseInt(row[1]);
                    number(code, `Code in ${fileName} should be an integer`);
                    result.code = code;
                    break;
                }
            case "":
                {
                    const version = parseInt(row[1]);
                    number(version, `Version in ${fileName} should be an integer`);
                    result.version = version;
                    break;
                }
            default:
                break;
        }
    }
    return result;
}
function parse3(fileName, rows) {
    const result = new Map();
    for (const row of rows){
        const index = parseInt(row[0]);
        number(index, `Index value in ${fileName} should be an integer`);
        result.set(index, {
            name: row[1] ?? "",
            price: Number(row[2] ?? "0")
        });
    }
    return result;
}
function parse4(fileName, rows) {
    const result = new Map();
    for (const row of rows){
        const name = row[0];
        const size = row.slice(1).map((cell)=>Number(cell));
        numArray(size, `Size of variable in ${fileName} should be an integer`);
        if (size.every((s)=>s >= 0)) {
            result.set(name, size);
        }
    }
    return result;
}
function parseStringMap(fileName, rows) {
    const result = new Map();
    for (const row of rows){
        const index = parseInt(row[0]);
        number(index, `Index value in ${fileName} should be an integer`);
        result.set(index, row[1] ?? "");
    }
    return result;
}
function parseCSV(content) {
    function getTable(name) {
        if (!content.has(name)) {
            return [];
        }
        const raw = content.get(name);
        const normalized = raw.replace(/\r/g, "").split("\n");
        const stripped = normalized.map((line)=>/^[^;]*/.exec(line)[0]);
        const filtered = stripped.map((line)=>line.trim()).filter((line)=>line.length > 0);
        const parsed = parse(filtered.join("\n"), {
            delimiter: ",",
            skipEmptyLines: true
        });
        return parsed.data;
    }
    const gamebase = parse2("GAMEBASE.CSV", getTable("GAMEBASE.CSV"));
    const abl = parseStringMap("ABL.CSV", getTable("ABL.CSV"));
    const exp = parseStringMap("EXP.CSV", getTable("EXP.CSV"));
    const talent = parseStringMap("TALENT.CSV", getTable("TALENT.CSV"));
    const palam = parseStringMap("PALAM.CSV", getTable("PALAM.CSV"));
    const train = parseStringMap("TRAIN.CSV", getTable("TRAIN.CSV"));
    const mark = parseStringMap("MARK.CSV", getTable("MARK.CSV"));
    const item = parse3("ITEM.CSV", getTable("ITEM.CSV"));
    const base = parseStringMap("BASE.CSV", getTable("BASE.CSV"));
    const source = parseStringMap("SOURCE.CSV", getTable("SOURCE.CSV"));
    const ex = parseStringMap("EX.CSV", getTable("EX.CSV"));
    const str = parseStringMap("STR.CSV", getTable("STR.CSV"));
    const equip = parseStringMap("EQUIP.CSV", getTable("EQUIP.CSV"));
    const tequip = parseStringMap("TEQUIP.CSV", getTable("TEQUIP.CSV"));
    const flag = parseStringMap("FLAG.CSV", getTable("FLAG.CSV"));
    const tflag = parseStringMap("TFLAG.CSV", getTable("TFLAG.CSV"));
    const cflag = parseStringMap("CFLAG.CSV", getTable("CFLAG.CSV"));
    const tcvar = parseStringMap("TCVAR.CSV", getTable("TCVAR.CSV"));
    const cstr = parseStringMap("CSTR.CSV", getTable("CSTR.CSV"));
    const stain = parseStringMap("STAIN.CSV", getTable("STAIN.CSV"));
    const cdflag1 = parseStringMap("CDFLAG1.CSV", getTable("CDFLAG1.CSV"));
    const cdflag2 = parseStringMap("CDFLAG2.CSV", getTable("CDFLAG2.CSV"));
    const strName = parseStringMap("STRNAME.CSV", getTable("STRNAME.CSV"));
    const tstr = parseStringMap("TSTR.CSV", getTable("TSTR.CSV"));
    const saveStr = parseStringMap("SAVESTR.CSV", getTable("SAVESTR.CSV"));
    const global = parseStringMap("GLOBAL.CSV", getTable("GLOBAL.CSV"));
    const globalS = parseStringMap("GLOBALS.CSV", getTable("GLOBALS.CSV"));
    const varSize = parse4("VARIABLESIZE.CSV", getTable("VARIABLESIZE.CSV"));
    const character = new Map();
    for (const name of content.keys()){
        if (name.startsWith("CHARA") && name.endsWith(".CSV")) {
            const template = parse1(name, getTable(name), {
                base: new Map([
                    ...base.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                mark: new Map([
                    ...mark.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                exp: new Map([
                    ...exp.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                abl: new Map([
                    ...abl.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                talent: new Map([
                    ...talent.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                cflag: new Map([
                    ...cflag.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                equip: new Map([
                    ...equip.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                juel: new Map([
                    ...palam.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ])),
                cstr: new Map([
                    ...cstr.entries()
                ].map(([index, value])=>[
                        value,
                        index
                    ]))
            });
            character.set(template.no, template);
        }
    }
    return {
        gamebase,
        character,
        abl,
        exp,
        talent,
        palam,
        train,
        mark,
        item,
        base,
        source,
        ex,
        str,
        equip,
        tequip,
        flag,
        tflag,
        cflag,
        tcvar,
        cstr,
        stain,
        cdflag1,
        cdflag2,
        strName,
        tstr,
        saveStr,
        global,
        globalS,
        varSize
    };
}
var Vt1 = Object.create;
var Ot1 = Object.defineProperty;
var Ht1 = Object.getOwnPropertyDescriptor;
var Kt1 = Object.getOwnPropertyNames;
var Qt1 = Object.getPrototypeOf, Xt1 = Object.prototype.hasOwnProperty;
var Yt1 = (h, s)=>()=>(s || h((s = {
            exports: {}
        }).exports, s), s.exports);
var Zt1 = (h, s, d, u)=>{
    if (s && typeof s == "object" || typeof s == "function") for (let f of Kt1(s))!Xt1.call(h, f) && f !== d && Ot1(h, f, {
        get: ()=>s[f],
        enumerable: !(u = Ht1(s, f)) || u.enumerable
    });
    return h;
};
var $t1 = (h, s, d)=>(d = h != null ? Vt1(Qt1(h)) : {}, Zt1(s || !h || !h.__esModule ? Ot1(d, "default", {
        value: h,
        enumerable: !0
    }) : d, h));
var St1 = Yt1((V, lt)=>{
    (function(h, s) {
        typeof V == "object" && typeof lt == "object" ? lt.exports = s() : typeof define == "function" && define.amd ? define([], s) : typeof V == "object" ? V.Parsimmon = s() : h.Parsimmon = s();
    })(typeof self < "u" ? self : V, function() {
        return function(h) {
            var s = {};
            function d(u) {
                if (s[u]) return s[u].exports;
                var f = s[u] = {
                    i: u,
                    l: !1,
                    exports: {}
                };
                return h[u].call(f.exports, f, f.exports, d), f.l = !0, f.exports;
            }
            return d.m = h, d.c = s, d.d = function(u, f, H) {
                d.o(u, f) || Object.defineProperty(u, f, {
                    configurable: !1,
                    enumerable: !0,
                    get: H
                });
            }, d.r = function(u) {
                Object.defineProperty(u, "__esModule", {
                    value: !0
                });
            }, d.n = function(u) {
                var f = u && u.__esModule ? function() {
                    return u.default;
                } : function() {
                    return u;
                };
                return d.d(f, "a", f), f;
            }, d.o = function(u, f) {
                return Object.prototype.hasOwnProperty.call(u, f);
            }, d.p = "", d(d.s = 0);
        }([
            function(h, s, d) {
                "use strict";
                function u(t) {
                    if (!(this instanceof u)) return new u(t);
                    this._ = t;
                }
                var f = u.prototype;
                function H(t, n) {
                    for(var r = 0; r < t; r++)n(r);
                }
                function S(t, n, r) {
                    return function(e, o) {
                        H(o.length, function(i) {
                            e(o[i], i, o);
                        });
                    }(function(e, o, i) {
                        n = t(n, e, o, i);
                    }, r), n;
                }
                function j(t, n) {
                    return S(function(r, e, o, i) {
                        return r.concat([
                            t(e, o, i)
                        ]);
                    }, [], n);
                }
                function qt(t, n) {
                    var r = {
                        v: 0,
                        buf: n
                    };
                    return H(t, function() {
                        var e;
                        r = {
                            v: r.v << 1 | (e = r.buf, e[0] >> 7),
                            buf: function(o) {
                                var i = S(function(a, c, l, m) {
                                    return a.concat(l === m.length - 1 ? Buffer1.from([
                                        c,
                                        0
                                    ]).readUInt16BE(0) : m.readUInt16BE(l));
                                }, [], o);
                                return Buffer1.from(j(function(a) {
                                    return (a << 1 & 65535) >> 8;
                                }, i));
                            }(r.buf)
                        };
                    }), r;
                }
                function pt() {
                    return typeof Buffer1 < "u";
                }
                function K() {
                    if (!pt()) throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
                }
                function ht(t) {
                    K();
                    var n = S(function(i, a) {
                        return i + a;
                    }, 0, t);
                    if (n % 8 != 0) throw new Error("The bits [" + t.join(", ") + "] add up to " + n + " which is not an even number of bytes; the total should be divisible by 8");
                    var r, e = n / 8, o = (r = function(i) {
                        return i > 48;
                    }, S(function(i, a) {
                        return i || (r(a) ? a : i);
                    }, null, t));
                    if (o) throw new Error(o + " bit range requested exceeds 48 bit (6 byte) Number max.");
                    return new u(function(i, a) {
                        var c = e + a;
                        return c > i.length ? y(a, e.toString() + " bytes") : p(c, S(function(l, m) {
                            var v = qt(m, l.buf);
                            return {
                                coll: l.coll.concat(v.v),
                                buf: v.buf
                            };
                        }, {
                            coll: [],
                            buf: i.slice(a, c)
                        }, t).coll);
                    });
                }
                function b(t, n) {
                    return new u(function(r, e) {
                        return K(), e + n > r.length ? y(e, n + " bytes for " + t) : p(e + n, r.slice(e, e + n));
                    });
                }
                function Q(t, n) {
                    if (typeof (r = n) != "number" || Math.floor(r) !== r || n < 0 || n > 6) throw new Error(t + " requires integer length in range [0, 6].");
                    var r;
                }
                function X(t) {
                    return Q("uintBE", t), b("uintBE(" + t + ")", t).map(function(n) {
                        return n.readUIntBE(0, t);
                    });
                }
                function Y(t) {
                    return Q("uintLE", t), b("uintLE(" + t + ")", t).map(function(n) {
                        return n.readUIntLE(0, t);
                    });
                }
                function Z(t) {
                    return Q("intBE", t), b("intBE(" + t + ")", t).map(function(n) {
                        return n.readIntBE(0, t);
                    });
                }
                function $(t) {
                    return Q("intLE", t), b("intLE(" + t + ")", t).map(function(n) {
                        return n.readIntLE(0, t);
                    });
                }
                function N(t) {
                    return t instanceof u;
                }
                function A(t) {
                    return ({}).toString.call(t) === "[object Array]";
                }
                function G(t) {
                    return pt() && Buffer1.isBuffer(t);
                }
                function p(t, n) {
                    return {
                        status: !0,
                        index: t,
                        value: n,
                        furthest: -1,
                        expected: []
                    };
                }
                function y(t, n) {
                    return A(n) || (n = [
                        n
                    ]), {
                        status: !1,
                        index: -1,
                        value: null,
                        furthest: t,
                        expected: n
                    };
                }
                function E(t, n) {
                    if (!n || t.furthest > n.furthest) return t;
                    var r = t.furthest === n.furthest ? function(e, o) {
                        if (function() {
                            if (u._supportsSet !== void 0) return u._supportsSet;
                            var _ = typeof Set < "u";
                            return u._supportsSet = _, _;
                        }() && Array.from) {
                            for(var i = new Set(e), a = 0; a < o.length; a++)i.add(o[a]);
                            var c = Array.from(i);
                            return c.sort(), c;
                        }
                        for(var l = {}, m = 0; m < e.length; m++)l[e[m]] = !0;
                        for(var v = 0; v < o.length; v++)l[o[v]] = !0;
                        var B = [];
                        for(var w in l)({}).hasOwnProperty.call(l, w) && B.push(w);
                        return B.sort(), B;
                    }(t.expected, n.expected) : n.expected;
                    return {
                        status: t.status,
                        index: t.index,
                        value: t.value,
                        furthest: n.furthest,
                        expected: r
                    };
                }
                var F = {};
                function dt(t, n) {
                    if (G(t)) return {
                        offset: n,
                        line: -1,
                        column: -1
                    };
                    if (F.input === t && F.i === n) return F.value;
                    var r = t.slice(0, n).split(`
`), e = {
                        offset: n,
                        line: r.length,
                        column: r[r.length - 1].length + 1
                    };
                    return F.input = t, F.i = n, F.value = e, e;
                }
                function I(t) {
                    if (!N(t)) throw new Error("not a parser: " + t);
                }
                function tt(t, n) {
                    return typeof t == "string" ? t.charAt(n) : t[n];
                }
                function M(t) {
                    if (typeof t != "number") throw new Error("not a number: " + t);
                }
                function L(t) {
                    if (typeof t != "function") throw new Error("not a function: " + t);
                }
                function C(t) {
                    if (typeof t != "string") throw new Error("not a string: " + t);
                }
                var Pt = 2, At = 3, O = 8, Ft = 5 * O, It = 4 * O, gt = "  ";
                function nt(t, n) {
                    return new Array(n + 1).join(t);
                }
                function rt(t, n, r) {
                    var e = n - t.length;
                    return e <= 0 ? t : nt(r, e) + t;
                }
                function vt(t, n, r, e) {
                    return {
                        from: t - n > 0 ? t - n : 0,
                        to: t + r > e ? e : t + r
                    };
                }
                function Mt(t, n) {
                    var r, e, o, i, a, c = n.index, l = c.offset, m = 1;
                    if (l === t.length) return "Got the end of the input";
                    if (G(t)) {
                        var v = l - l % O, B = l - v, w = vt(v, Ft, It + O, t.length), _ = j(function(g) {
                            return j(function(W) {
                                return rt(W.toString(16), 2, "0");
                            }, g);
                        }, function(g, W) {
                            var R = g.length, P = [], U = 0;
                            if (R <= W) return [
                                g.slice()
                            ];
                            for(var D = 0; D < R; D++)P[U] || P.push([]), P[U].push(g[D]), (D + 1) % W == 0 && U++;
                            return P;
                        }(t.slice(w.from, w.to).toJSON().data, O));
                        i = function(g) {
                            return g.from === 0 && g.to === 1 ? {
                                from: g.from,
                                to: g.to
                            } : {
                                from: g.from / O,
                                to: Math.floor(g.to / O)
                            };
                        }(w), e = v / O, r = 3 * B, B >= 4 && (r += 1), m = 2, o = j(function(g) {
                            return g.length <= 4 ? g.join(" ") : g.slice(0, 4).join(" ") + "  " + g.slice(4).join(" ");
                        }, _), (a = (8 * (i.to > 0 ? i.to - 1 : i.to)).toString(16).length) < 2 && (a = 2);
                    } else {
                        var z = t.split(/\r\n|[\n\r\u2028\u2029]/);
                        r = c.column - 1, e = c.line - 1, i = vt(e, Pt, At, z.length), o = z.slice(i.from, i.to), a = i.to.toString().length;
                    }
                    var Tt = e - i.from;
                    return G(t) && (a = (8 * (i.to > 0 ? i.to - 1 : i.to)).toString(16).length) < 2 && (a = 2), S(function(g, W, R) {
                        var P, U = R === Tt, D = U ? "> " : gt;
                        return P = G(t) ? rt((8 * (i.from + R)).toString(16), a, "0") : rt((i.from + R + 1).toString(), a, " "), [].concat(g, [
                            D + P + " | " + W
                        ], U ? [
                            gt + nt(" ", a) + " | " + rt("", r, " ") + nt("^", m)
                        ] : []);
                    }, [], o).join(`
`);
                }
                function mt(t, n) {
                    return [
                        `
`,
                        "-- PARSING FAILED " + nt("-", 50),
                        `

`,
                        Mt(t, n),
                        `

`,
                        (r = n.expected, r.length === 1 ? `Expected:

` + r[0] : `Expected one of the following: 

` + r.join(", ")),
                        `
`
                    ].join("");
                    var r;
                }
                function yt(t) {
                    return t.flags !== void 0 ? t.flags : [
                        t.global ? "g" : "",
                        t.ignoreCase ? "i" : "",
                        t.multiline ? "m" : "",
                        t.unicode ? "u" : "",
                        t.sticky ? "y" : ""
                    ].join("");
                }
                function et() {
                    for(var t = [].slice.call(arguments), n = t.length, r = 0; r < n; r += 1)I(t[r]);
                    return u(function(e, o) {
                        for(var i, a = new Array(n), c = 0; c < n; c += 1){
                            if (!(i = E(t[c]._(e, o), i)).status) return i;
                            a[c] = i.value, o = i.index;
                        }
                        return E(p(o, a), i);
                    });
                }
                function k() {
                    var t = [].slice.call(arguments);
                    if (t.length === 0) throw new Error("seqMap needs at least one argument");
                    var n = t.pop();
                    return L(n), et.apply(null, t).map(function(r) {
                        return n.apply(null, r);
                    });
                }
                function ut() {
                    var t = [].slice.call(arguments), n = t.length;
                    if (n === 0) return ot("zero alternates");
                    for(var r = 0; r < n; r += 1)I(t[r]);
                    return u(function(e, o) {
                        for(var i, a = 0; a < t.length; a += 1)if ((i = E(t[a]._(e, o), i)).status) return i;
                        return i;
                    });
                }
                function wt(t, n) {
                    return ft(t, n).or(q([]));
                }
                function ft(t, n) {
                    return I(t), I(n), k(t, n.then(t).many(), function(r, e) {
                        return [
                            r
                        ].concat(e);
                    });
                }
                function J(t) {
                    C(t);
                    var n = "'" + t + "'";
                    return u(function(r, e) {
                        var o = e + t.length, i = r.slice(e, o);
                        return i === t ? p(o, i) : y(e, n);
                    });
                }
                function x(t, n) {
                    (function(o) {
                        if (!(o instanceof RegExp)) throw new Error("not a regexp: " + o);
                        for(var i = yt(o), a = 0; a < i.length; a++){
                            var c = i.charAt(a);
                            if (c !== "i" && c !== "m" && c !== "u" && c !== "s") throw new Error('unsupported regexp flag "' + c + '": ' + o);
                        }
                    })(t), arguments.length >= 2 ? M(n) : n = 0;
                    var r = function(o) {
                        return RegExp("^(?:" + o.source + ")", yt(o));
                    }(t), e = "" + t;
                    return u(function(o, i) {
                        var a = r.exec(o.slice(i));
                        if (a) {
                            if (0 <= n && n <= a.length) {
                                var c = a[0], l = a[n];
                                return p(i + c.length, l);
                            }
                            return y(i, "valid match group (0 to " + a.length + ") in " + e);
                        }
                        return y(i, e);
                    });
                }
                function q(t) {
                    return u(function(n, r) {
                        return p(r, t);
                    });
                }
                function ot(t) {
                    return u(function(n, r) {
                        return y(r, t);
                    });
                }
                function it(t) {
                    if (N(t)) return u(function(n, r) {
                        var e = t._(n, r);
                        return e.index = r, e.value = "", e;
                    });
                    if (typeof t == "string") return it(J(t));
                    if (t instanceof RegExp) return it(x(t));
                    throw new Error("not a string, regexp, or parser: " + t);
                }
                function Et(t) {
                    return I(t), u(function(n, r) {
                        var e = t._(n, r), o = n.slice(r, e.index);
                        return e.status ? y(r, 'not "' + o + '"') : p(r, null);
                    });
                }
                function at(t) {
                    return L(t), u(function(n, r) {
                        var e = tt(n, r);
                        return r < n.length && t(e) ? p(r + 1, e) : y(r, "a character/byte matching " + t);
                    });
                }
                function bt(t, n) {
                    arguments.length < 2 && (n = t, t = void 0);
                    var r = u(function(e, o) {
                        return r._ = n()._, r._(e, o);
                    });
                    return t ? r.desc(t) : r;
                }
                function ct() {
                    return ot("fantasy-land/empty");
                }
                f.parse = function(t) {
                    if (typeof t != "string" && !G(t)) throw new Error(".parse must be called with a string or Buffer as its argument");
                    var n = this.skip(st)._(t, 0);
                    return n.status ? {
                        status: !0,
                        value: n.value
                    } : {
                        status: !1,
                        index: dt(t, n.furthest),
                        expected: n.expected
                    };
                }, f.tryParse = function(t) {
                    var n = this.parse(t);
                    if (n.status) return n.value;
                    var r = mt(t, n), e = new Error(r);
                    throw e.type = "ParsimmonError", e.result = n, e;
                }, f.assert = function(t, n) {
                    return this.chain(function(r) {
                        return t(r) ? q(r) : ot(n);
                    });
                }, f.or = function(t) {
                    return ut(this, t);
                }, f.trim = function(t) {
                    return this.wrap(t, t);
                }, f.wrap = function(t, n) {
                    return k(t, this, n, function(r, e) {
                        return e;
                    });
                }, f.thru = function(t) {
                    return t(this);
                }, f.then = function(t) {
                    return I(t), et(this, t).map(function(n) {
                        return n[1];
                    });
                }, f.many = function() {
                    var t = this;
                    return u(function(n, r) {
                        for(var e = [], o = void 0;;){
                            if (!(o = E(t._(n, r), o)).status) return E(p(r, e), o);
                            if (r === o.index) throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                            r = o.index, e.push(o.value);
                        }
                    });
                }, f.tieWith = function(t) {
                    return C(t), this.map(function(n) {
                        if (function(o) {
                            if (!A(o)) throw new Error("not an array: " + o);
                        }(n), n.length) {
                            C(n[0]);
                            for(var r = n[0], e = 1; e < n.length; e++)C(n[e]), r += t + n[e];
                            return r;
                        }
                        return "";
                    });
                }, f.tie = function() {
                    return this.tieWith("");
                }, f.times = function(t, n) {
                    var r = this;
                    return arguments.length < 2 && (n = t), M(t), M(n), u(function(e, o) {
                        for(var i = [], a = void 0, c = void 0, l = 0; l < t; l += 1){
                            if (c = E(a = r._(e, o), c), !a.status) return c;
                            o = a.index, i.push(a.value);
                        }
                        for(; l < n && (c = E(a = r._(e, o), c), a.status); l += 1)o = a.index, i.push(a.value);
                        return E(p(o, i), c);
                    });
                }, f.result = function(t) {
                    return this.map(function() {
                        return t;
                    });
                }, f.atMost = function(t) {
                    return this.times(0, t);
                }, f.atLeast = function(t) {
                    return k(this.times(t), this.many(), function(n, r) {
                        return n.concat(r);
                    });
                }, f.map = function(t) {
                    L(t);
                    var n = this;
                    return u(function(r, e) {
                        var o = n._(r, e);
                        return o.status ? E(p(o.index, t(o.value)), o) : o;
                    });
                }, f.contramap = function(t) {
                    L(t);
                    var n = this;
                    return u(function(r, e) {
                        var o = n.parse(t(r.slice(e)));
                        return o.status ? p(e + r.length, o.value) : o;
                    });
                }, f.promap = function(t, n) {
                    return L(t), L(n), this.contramap(t).map(n);
                }, f.skip = function(t) {
                    return et(this, t).map(function(n) {
                        return n[0];
                    });
                }, f.mark = function() {
                    return k(T, this, T, function(t, n, r) {
                        return {
                            start: t,
                            value: n,
                            end: r
                        };
                    });
                }, f.node = function(t) {
                    return k(T, this, T, function(n, r, e) {
                        return {
                            name: t,
                            value: r,
                            start: n,
                            end: e
                        };
                    });
                }, f.sepBy = function(t) {
                    return wt(this, t);
                }, f.sepBy1 = function(t) {
                    return ft(this, t);
                }, f.lookahead = function(t) {
                    return this.skip(it(t));
                }, f.notFollowedBy = function(t) {
                    return this.skip(Et(t));
                }, f.desc = function(t) {
                    A(t) || (t = [
                        t
                    ]);
                    var n = this;
                    return u(function(r, e) {
                        var o = n._(r, e);
                        return o.status || (o.expected = t), o;
                    });
                }, f.fallback = function(t) {
                    return this.or(q(t));
                }, f.ap = function(t) {
                    return k(t, this, function(n, r) {
                        return n(r);
                    });
                }, f.chain = function(t) {
                    var n = this;
                    return u(function(r, e) {
                        var o = n._(r, e);
                        return o.status ? E(t(o.value)._(r, o.index), o) : o;
                    });
                }, f.concat = f.or, f.empty = ct, f.of = q, f["fantasy-land/ap"] = f.ap, f["fantasy-land/chain"] = f.chain, f["fantasy-land/concat"] = f.concat, f["fantasy-land/empty"] = f.empty, f["fantasy-land/of"] = f.of, f["fantasy-land/map"] = f.map;
                var T = u(function(t, n) {
                    return p(n, dt(t, n));
                }), zt = u(function(t, n) {
                    return n >= t.length ? y(n, "any character/byte") : p(n + 1, tt(t, n));
                }), Wt = u(function(t, n) {
                    return p(t.length, t.slice(n));
                }), st = u(function(t, n) {
                    return n < t.length ? y(n, "EOF") : p(n, null);
                }), Rt = x(/[0-9]/).desc("a digit"), Ut = x(/[0-9]*/).desc("optional digits"), Dt = x(/[a-z]/i).desc("a letter"), Nt = x(/[a-z]*/i).desc("optional letters"), Gt = x(/\s*/).desc("optional whitespace"), Ct = x(/\s+/).desc("whitespace"), xt = J("\r"), Bt = J(`
`), _t = J(`\r
`), jt = ut(_t, Bt, xt).desc("newline"), Jt = ut(jt, st);
                u.all = Wt, u.alt = ut, u.any = zt, u.cr = xt, u.createLanguage = function(t) {
                    var n = {};
                    for(var r in t)({}).hasOwnProperty.call(t, r) && function(e) {
                        n[e] = bt(function() {
                            return t[e](n);
                        });
                    }(r);
                    return n;
                }, u.crlf = _t, u.custom = function(t) {
                    return u(t(p, y));
                }, u.digit = Rt, u.digits = Ut, u.empty = ct, u.end = Jt, u.eof = st, u.fail = ot, u.formatError = mt, u.index = T, u.isParser = N, u.lazy = bt, u.letter = Dt, u.letters = Nt, u.lf = Bt, u.lookahead = it, u.makeFailure = y, u.makeSuccess = p, u.newline = jt, u.noneOf = function(t) {
                    return at(function(n) {
                        return t.indexOf(n) < 0;
                    }).desc("none of '" + t + "'");
                }, u.notFollowedBy = Et, u.of = q, u.oneOf = function(t) {
                    for(var n = t.split(""), r = 0; r < n.length; r++)n[r] = "'" + n[r] + "'";
                    return at(function(e) {
                        return t.indexOf(e) >= 0;
                    }).desc(n);
                }, u.optWhitespace = Gt, u.Parser = u, u.range = function(t, n) {
                    return at(function(r) {
                        return t <= r && r <= n;
                    }).desc(t + "-" + n);
                }, u.regex = x, u.regexp = x, u.sepBy = wt, u.sepBy1 = ft, u.seq = et, u.seqMap = k, u.seqObj = function() {
                    for(var t, n = {}, r = 0, e = (t = arguments, Array.prototype.slice.call(t)), o = e.length, i = 0; i < o; i += 1){
                        var a = e[i];
                        if (!N(a)) {
                            if (A(a) && a.length === 2 && typeof a[0] == "string" && N(a[1])) {
                                var c = a[0];
                                if (Object.prototype.hasOwnProperty.call(n, c)) throw new Error("seqObj: duplicate key " + c);
                                n[c] = !0, r++;
                                continue;
                            }
                            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
                        }
                    }
                    if (r === 0) throw new Error("seqObj expects at least one named parser, found zero");
                    return u(function(l, m) {
                        for(var v, B = {}, w = 0; w < o; w += 1){
                            var _, z;
                            if (A(e[w]) ? (_ = e[w][0], z = e[w][1]) : (_ = null, z = e[w]), !(v = E(z._(l, m), v)).status) return v;
                            _ && (B[_] = v.value), m = v.index;
                        }
                        return E(p(m, B), v);
                    });
                }, u.string = J, u.succeed = q, u.takeWhile = function(t) {
                    return L(t), u(function(n, r) {
                        for(var e = r; e < n.length && t(tt(n, e));)e++;
                        return p(e, n.slice(r, e));
                    });
                }, u.test = at, u.whitespace = Ct, u["fantasy-land/empty"] = ct, u["fantasy-land/of"] = q, u.Binary = {
                    bitSeq: ht,
                    bitSeqObj: function(t) {
                        K();
                        var n = {}, r = 0, e = j(function(i) {
                            if (A(i)) {
                                var a = i;
                                if (a.length !== 2) throw new Error("[" + a.join(", ") + "] should be length 2, got length " + a.length);
                                if (C(a[0]), M(a[1]), Object.prototype.hasOwnProperty.call(n, a[0])) throw new Error("duplicate key in bitSeqObj: " + a[0]);
                                return n[a[0]] = !0, r++, a;
                            }
                            return M(i), [
                                null,
                                i
                            ];
                        }, t);
                        if (r < 1) throw new Error("bitSeqObj expects at least one named pair, got [" + t.join(", ") + "]");
                        var o = j(function(i) {
                            return i[0];
                        }, e);
                        return ht(j(function(i) {
                            return i[1];
                        }, e)).map(function(i) {
                            return S(function(a, c) {
                                return c[0] !== null && (a[c[0]] = c[1]), a;
                            }, {}, j(function(a, c) {
                                return [
                                    a,
                                    i[c]
                                ];
                            }, o));
                        });
                    },
                    byte: function(t) {
                        if (K(), M(t), t > 255) throw new Error("Value specified to byte constructor (" + t + "=0x" + t.toString(16) + ") is larger in value than a single byte.");
                        var n = (t > 15 ? "0x" : "0x0") + t.toString(16);
                        return u(function(r, e) {
                            var o = tt(r, e);
                            return o === t ? p(e + 1, o) : y(e, n);
                        });
                    },
                    buffer: function(t) {
                        return b("buffer", t).map(function(n) {
                            return Buffer1.from(n);
                        });
                    },
                    encodedString: function(t, n) {
                        return b("string", n).map(function(r) {
                            return r.toString(t);
                        });
                    },
                    uintBE: X,
                    uint8BE: X(1),
                    uint16BE: X(2),
                    uint32BE: X(4),
                    uintLE: Y,
                    uint8LE: Y(1),
                    uint16LE: Y(2),
                    uint32LE: Y(4),
                    intBE: Z,
                    int8BE: Z(1),
                    int16BE: Z(2),
                    int32BE: Z(4),
                    intLE: $,
                    int8LE: $(1),
                    int16LE: $(2),
                    int32LE: $(4),
                    floatBE: b("floatBE", 4).map(function(t) {
                        return t.readFloatBE(0);
                    }),
                    floatLE: b("floatLE", 4).map(function(t) {
                        return t.readFloatLE(0);
                    }),
                    doubleBE: b("doubleBE", 8).map(function(t) {
                        return t.readDoubleBE(0);
                    }),
                    doubleLE: b("doubleLE", 8).map(function(t) {
                        return t.readDoubleLE(0);
                    })
                }, h.exports = u;
            }
        ]);
    });
});
var kt1 = $t1(St1()), { all: rn2 , alt: en1 , any: un1 , cr: on1 , createLanguage: an1 , crlf: fn1 , custom: cn1 , digit: sn1 , digits: ln1 , empty: pn1 , end: hn1 , eof: dn1 , fail: gn1 , formatError: vn1 , index: mn1 , isParser: yn1 , lazy: wn1 , letter: En1 , letters: bn1 , lf: xn1 , lookahead: Bn1 , makeFailure: _n1 , makeSuccess: jn1 , newline: On1 , noneOf: Sn1 , notFollowedBy: Ln1 , of: kn1 , oneOf: qn1 , optWhitespace: Pn1 , Parser: An1 , range: Fn1 , regex: In1 , regexp: Mn1 , sepBy: zn1 , sepBy1: Wn1 , seq: Rn1 , seqMap: Un1 , seqObj: Dn1 , string: Nn1 , succeed: Gn1 , takeWhile: Cn1 , test: Jn1 , whitespace: Tn1 , Binary: Vn1  } = kt1, { default: Lt1 , ...tn1 } = kt1, Hn1 = Lt1 !== void 0 ? Lt1 : tn1;
class Binary {
    left;
    right;
    op;
    constructor(op, left, right){
        this.op = op;
        this.left = left;
        this.right = right;
    }
    async reduce(vm) {
        const left = await this.left.reduce(vm);
        switch(this.op){
            case "&&":
                if (typeof left === "bigint" && left === 0n) return 0n;
                break;
            case "!&":
                if (typeof left === "bigint" && left === 0n) return 1n;
                break;
            case "||":
                if (typeof left === "bigint" && left === 1n) return 1n;
                break;
            case "!|":
                if (typeof left === "bigint" && left === 1n) return 0n;
                break;
            default:
        }
        const right = await this.right.reduce(vm);
        if (typeof left === "bigint" && typeof right === "bigint") {
            switch(this.op){
                case "*":
                    return left * right;
                case "/":
                    return left / right;
                case "%":
                    return left % right;
                case "+":
                    return left + right;
                case "-":
                    return left - right;
                case "<<":
                    return left << right;
                case ">>":
                    return left >> right;
                case "<":
                    return left < right ? 1n : 0n;
                case "<=":
                    return left <= right ? 1n : 0n;
                case ">":
                    return left > right ? 1n : 0n;
                case ">=":
                    return left >= right ? 1n : 0n;
                case "==":
                    return left === right ? 1n : 0n;
                case "!=":
                    return left !== right ? 1n : 0n;
                case "&":
                    return left & right;
                case "|":
                    return left | right;
                case "^":
                    return left ^ right;
                case "&&":
                    return left !== 0n && right !== 0n ? 1n : 0n;
                case "!&":
                    return !(left !== 0n && right !== 0n) ? 1n : 0n;
                case "||":
                    return left !== 0n || right !== 0n ? 1n : 0n;
                case "!|":
                    return !(left !== 0n || right !== 0n) ? 1n : 0n;
                case "^^":
                    return left !== 0n !== (right !== 0n) ? 1n : 0n;
            }
        } else if (typeof left === "string" && typeof right === "string") {
            switch(this.op){
                case "+":
                    return left + right;
                case "<":
                    return left < right ? 1n : 0n;
                case "<=":
                    return left <= right ? 1n : 0n;
                case ">":
                    return left > right ? 1n : 0n;
                case ">=":
                    return left >= right ? 1n : 0n;
                case "==":
                    return left === right ? 1n : 0n;
                case "!=":
                    return left !== right ? 1n : 0n;
                default:
            }
        } else if (typeof left === "string" && typeof right === "bigint") {
            switch(this.op){
                case "*":
                    return left.repeat(Number(right));
                default:
            }
        }
        throw new Error(`Type of operands for ${this.op} is invalid`);
    }
}
class Const {
    value;
    constructor(value){
        this.value = value;
    }
    async reduce(_vm) {
        return this.value;
    }
}
class Form {
    expr;
    constructor(expr){
        const merged = [];
        for (const e of expr){
            const last = merged[merged.length - 1];
            if (last != null && typeof last.value === "string" && typeof e.value === "string") {
                last.value += e.value;
            } else {
                merged.push(e);
            }
        }
        this.expr = merged;
    }
    async reduce(vm) {
        let result = "";
        for (const expr of this.expr){
            let value;
            if (typeof expr.value === "string") {
                value = expr.value;
            } else {
                const reduced = await expr.value.reduce(vm);
                switch(typeof reduced){
                    case "string":
                        value = reduced;
                        break;
                    case "bigint":
                        value = reduced.toString();
                        break;
                }
            }
            if (expr.display != null) {
                const display = await expr.display.reduce(vm);
                bigint(display, "Display size of form string should be an integer");
                if (expr.align == null || expr.align === "LEFT") {
                    value = value.padStart(Number(display), " ");
                } else {
                    value = value.padEnd(Number(display), " ");
                }
            }
            result += value;
        }
        return result;
    }
}
async function abs(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of ABS must a be number");
    return value >= 0 ? value : -value;
}
async function barStr(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of BAR must be a number");
    const max = await arg[1].reduce(vm);
    bigint(max, "2nd argument of BAR must be a number");
    const length = await arg[2].reduce(vm);
    bigint(length, "3rd argument of BAR must be a number");
    const filled = length * value / max;
    return "[" + "*".repeat(Number(filled)) + ".".repeat(Number(length - filled)) + "]";
}
async function csvAbl(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVABL must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVABL must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.abl.get(Number(index)) ?? 0;
}
async function csvBase(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVBASE must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVBASE must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.base.get(Number(index)) ?? 0;
}
async function csvCallname(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVCALLNAME must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.callname;
}
async function csvCflag(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVCFLAG must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVCFLAG must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.cflag.get(Number(index)) ?? 0;
}
async function csvCstr(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVCSTR must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVCSTR must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.cstr.get(Number(index)) ?? "";
}
async function csvEquip(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVEQUIP must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVEQUIP must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.equip.get(Number(index)) ?? 0;
}
async function csvExp(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVEXP must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVEXP must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.exp.get(Number(index)) ?? 0;
}
async function csvJuel(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVJUEL must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVJUEL must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.juel.get(Number(index)) ?? 0;
}
async function csvMark(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVMARK must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVMARK must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.mark.get(Number(index)) ?? 0;
}
async function csvMastername(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVMASTERNAME must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.mastername;
}
async function csvName(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVNAME must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.name;
}
async function csvNickname(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVNICKNAME must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.nickname;
}
async function csvRelation(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVRELATION must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVRELATION must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.relation.get(Number(index)) ?? 0;
}
async function csvTalent(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of CSVTALENT must be an integer");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of CSVTALENT must be an integer");
    const character = vm.code.csv.character.get(Number(num));
    cond(character != null, `Character #${num} does not exist`);
    return character.talent.get(Number(index)) ?? 0;
}
async function existCsv(vm, arg) {
    const num = await arg[0].reduce(vm);
    bigint(num, "1st argument of EXISTCSV should be a number");
    return vm.templateMap.has(Number(num)) ? 1 : 0;
}
class Variable {
    name;
    index;
    scope;
    constructor(name, index, scope){
        this.name = name.toUpperCase();
        this.index = index;
        this.scope = scope;
    }
    getCell(vm) {
        return vm.getValue(this.name, this.scope);
    }
    async reduce(vm) {
        if (vm.macroMap.has(this.name)) {
            if (this.index.length !== 0) {
                throw new Error("Macro cannot be indexed");
            }
            const expr = vm.macroMap.get(this.name)?.expr;
            if (expr == null) {
                throw new Error("Empty macro cannot be referenced");
            }
            return expr.reduce(vm);
        } else {
            return this.getCell(vm).get(vm, await this.reduceIndex(vm));
        }
    }
    async reduceIndex(vm) {
        if (this.index.length !== 0) {
            const result = [];
            for (const i of this.index){
                const value = await i.reduce(vm);
                bigint(value, "Index of variable should be an integer");
                result.push(Number(value));
            }
            return result;
        } else {
            return [];
        }
    }
}
async function findChara(vm, arg) {
    const target = arg[0];
    cond(target instanceof Variable, "1st argument of FINDCHARA should be a variable");
    const value = await arg[1].reduce(vm);
    const start = arg.length >= 3 ? await arg[2].reduce(vm) : 0n;
    bigint(start, "3rd argument of FINDCHARA should be a nmber");
    const end = arg.length >= 4 ? await arg[3].reduce(vm) : BigInt(vm.characterList.length);
    bigint(end, "4th argument of FINDCHARA should be a number");
    const index = await target.reduceIndex(vm);
    for(let i = start; i < end; ++i){
        if (target.getCell(vm).get(vm, [
            Number(i),
            ...index
        ]) === value) {
            return i;
        }
    }
    return -1n;
}
async function findLastChara(vm, arg) {
    const target = arg[0];
    cond(target instanceof Variable, "1st argument of FINDLASTCHARA should be a variable");
    const value = await arg[1].reduce(vm);
    const start = arg.length >= 3 ? await arg[2].reduce(vm) : 0n;
    bigint(start, "3rd argument of FINDLASTCHARA should be a number");
    const end = arg.length >= 4 ? await arg[3].reduce(vm) : BigInt(vm.characterList.length);
    bigint(end, "4th argument of FINDLASTCHARA should be a number");
    const index = await target.reduceIndex(vm);
    for(let i = end - 1n; i >= start; --i){
        if (target.getCell(vm).get(vm, [
            Number(i),
            ...index
        ]) === value) {
            return i;
        }
    }
    return -1n;
}
function getBgColor(vm, _arg) {
    return parseInt(vm.printer.background, 16);
}
async function getBit(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of GETBIT should be a number");
    const index = await arg[1].reduce(vm);
    bigint(index, "2nd argument of GETBIT should be a number");
    cond(index < 64, "2nd argument of GETBIT should be less than 64");
    return (value & 1n << index) !== 0n ? 1 : 0;
}
async function getChara(vm, arg) {
    const id = await arg[0].reduce(vm);
    bigint(id, "1st argument of GETCHARA should be an integer");
    for(let i = 0; i < vm.characterList.length; ++i){
        if (vm.getValue("NO").get(vm, [
            i
        ]) === id) {
            return i;
        }
    }
    return -1;
}
function getColor(vm, _arg) {
    return parseInt(vm.printer.color, 16);
}
function getDefBgColor(vm, _arg) {
    return parseInt(vm.printer.defaultBackground, 16);
}
function getDefColor(vm, _arg) {
    return parseInt(vm.printer.defaultColor, 16);
}
function getFocusColor(vm, _arg) {
    return parseInt(vm.printer.focus, 16);
}
async function groupMatch(vm, arg) {
    cond(arg.length > 0, "1st argument of GROUPMATCH must exist");
    const key = await arg[0].reduce(vm);
    const values = [];
    for (const a of arg.slice(1)){
        values.push(await a.reduce(vm));
    }
    return values.reduce((acc, val)=>acc + (val === key ? 1 : 0), 0);
}
async function inRange(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of INRANGE should be a number");
    const min = await arg[1].reduce(vm);
    bigint(min, "2nd argument of INRANGE should be a number");
    const max = await arg[2].reduce(vm);
    bigint(max, "3rd argument of INRANGE should be a number");
    return min <= value && value <= max ? 1 : 0;
}
async function limit(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of LIMIT must a be number");
    const min = await arg[1].reduce(vm);
    bigint(min, "2nd argument of LIMIT must a be number");
    const max = await arg[2].reduce(vm);
    bigint(max, "3rd argument of LIMIT must a be number");
    if (value < min) {
        return min;
    } else if (value > max) {
        return max;
    } else {
        return value;
    }
}
function lineIsEmpty(vm, _arg) {
    return vm.printer.chunks.length === 0 ? 1 : 0;
}
const LARGE_INT = 2n ** 60n;
async function match(vm, arg) {
    const target = arg[0];
    cond(target instanceof Variable, "1st argument of MATCH should be a variable");
    const value = await arg[1].reduce(vm);
    const start = arg.length >= 3 ? await arg[2].reduce(vm) : 0n;
    bigint(start, "3rd argument of MATCH should be a number");
    const end = arg.length >= 4 ? await arg[3].reduce(vm) : LARGE_INT;
    bigint(end, "4th argument of MATCH should be a number");
    const varSize = target.getCell(vm).length(0);
    const realEnd = end > varSize ? BigInt(varSize) : end;
    let result = 0;
    for(let i = start; i < realEnd; ++i){
        if (target.getCell(vm).get(vm, [
            Number(i)
        ]) === value) {
            result += 1;
        }
    }
    return result;
}
async function max(vm, arg) {
    cond(arg.length > 0, "MAX must have at least 1 argument");
    let result = 0n;
    for(let i = 0; i < arg.length; ++i){
        const value = await arg[i].reduce(vm);
        bigint(value, `${i + 1}th argument of MAX should be a number`);
        result = result > value ? result : value;
    }
    return result;
}
const LARGE_INT1 = 2n ** 60n;
async function maxArray(vm, arg) {
    const target = arg[0];
    cond(target instanceof Variable, "1st argument of MAXARRAY should be a variable");
    cond(target.getCell(vm).type === "number", "1st argument of MAXARRAY should be a number variable");
    const start = arg.length >= 2 ? await arg[1].reduce(vm) : 0n;
    bigint(start, "2nd argument of MAXARRAY should be a number");
    const end = arg.length >= 3 ? await arg[2].reduce(vm) : LARGE_INT1;
    bigint(end, "3rd argument of MAXARRAY should be a number");
    const varSize = target.getCell(vm).length(0);
    const realEnd = end > varSize ? BigInt(varSize) : end;
    let result = 0n;
    for(let i = start; i < realEnd; ++i){
        const value = target.getCell(vm).get(vm, [
            Number(i)
        ]);
        result = result > value ? result : value;
    }
    return result;
}
const LARGE_INT2 = 2n ** 60n;
async function min(vm, arg) {
    cond(arg.length > 0, "MIN must have at least 1 argument");
    let result = LARGE_INT2;
    for(let i = 0; i < arg.length; ++i){
        const value = await arg[i].reduce(vm);
        bigint(value, `${i + 1}th argument of MIN must be a number`);
        result = result > value ? value : result;
    }
    return result;
}
const LARGE_INT3 = 2n ** 60n;
async function minArray(vm, arg) {
    const target = arg[0];
    cond(target instanceof Variable, "1st argument of MINARRAY should be a variable");
    cond(target.getCell(vm).type === "number", "1st argument of MINARRAY should be a number variable");
    const start = arg.length >= 2 ? await arg[1].reduce(vm) : 0n;
    bigint(start, "2nd argument of MINARRAY should be a number");
    const end = arg.length >= 3 ? await arg[2].reduce(vm) : LARGE_INT3;
    bigint(end, "3rd argument of MINARRAY should be a number");
    const varSize = target.getCell(vm).length(0);
    const realEnd = end > varSize ? BigInt(varSize) : end;
    let result = LARGE_INT3;
    for(let i = start; i < realEnd; ++i){
        const value = target.getCell(vm).get(vm, [
            Number(i)
        ]);
        result = result > value ? value : result;
    }
    return result;
}
async function power(vm, arg) {
    const base = await arg[0].reduce(vm);
    bigint(base, "1st argument of POWER must be a number");
    const exponent = await arg[1].reduce(vm);
    bigint(exponent, "2nd argument of POWER must be a number");
    return base ** exponent;
}
async function rand(vm, arg) {
    if (arg.length === 0) {
        cond(false, "RAND should have at least 1 argument");
    } else if (arg.length === 1) {
        const max = await arg[0].reduce(vm);
        bigint(max, "1st argument of RAND should be an integer");
        return BigInt(vm.random.next()) % max;
    } else {
        const min = await arg[0].reduce(vm);
        bigint(min, "1st argument of RAND should be an integer");
        const max1 = await arg[1].reduce(vm);
        bigint(max1, "2nd argument of RAND should be an integer");
        return BigInt(vm.random.next()) % (max1 - min) + min;
    }
}
async function sign(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of SIGN must a be number");
    if (value > 0) {
        return 1;
    } else if (value < 0) {
        return -1;
    } else {
        return 0;
    }
}
class EraJSError extends Error {
    line;
    trace;
    constructor(message, line, trace){
        super(message);
        this.line = line;
        this.trace = trace;
    }
}
function parser(message) {
    return new Error(`Parser error found: ${message}`);
}
function notFound(type, name) {
    return new Error(`${type} ${name} does not exist`);
}
function invalidIndex(type, name, index) {
    return new Error(`${type} variable ${name} cannot be indexed by [${index.join(",")}]`);
}
function notImpl(target) {
    return new Error(`${target} is not implemented yet`);
}
function misc(message) {
    return new Error(`Runtime error found: ${message}`);
}
function internal(message) {
    return new Error(`Unexpected internal error found: ${message}`);
}
async function sqrt(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st argument of sqrt must be a number");
    if (value < 0n) {
        throw misc("Argument of sqrt must be larger than 0");
    }
    let prev = 0n;
    let result = value;
    for(let i = 0; i < 100; ++i){
        if (prev === result) {
            break;
        }
        prev = result;
        result = (result + value / result) / 2n;
    }
    if (result * result - 1n === value) {
        return result - 1n;
    } else {
        return result;
    }
}
async function strLenS(vm, arg) {
    const value = await arg[0].reduce(vm);
    string(value, "1st Argument of STRLENS should be a string");
    return value.length;
}
async function strLenSU(vm, arg) {
    const value = await arg[0].reduce(vm);
    string(value, "1st Argument of STRLENS should be a string");
    return value.length;
}
const LARGE_INT4 = 2n ** 60n;
async function sumArray(vm, arg) {
    const target = arg[0];
    cond(target instanceof Variable, "1st argument of SUMARRAY should be a variable");
    cond(target.getCell(vm).type === "number", "1st argument of SUMARRAY should be a number variable");
    const start = arg.length >= 2 ? await arg[1].reduce(vm) : 0n;
    bigint(start, "2nd argument of SUMARRAY should be a number");
    const end = arg.length >= 3 ? await arg[2].reduce(vm) : LARGE_INT4;
    bigint(end, "3rd argument of SUMARRAY should be a number");
    const varSize = target.getCell(vm).length(0);
    const realEnd = end > varSize ? BigInt(varSize) : end;
    let result = 0n;
    for(let i = start; i < realEnd; ++i){
        result += target.getCell(vm).get(vm, [
            Number(i)
        ]);
    }
    return result;
}
async function toInt(vm, arg) {
    const value = await arg[0].reduce(vm);
    string(value, "1st Argument of TOINT should be a string");
    const result = Number(value);
    return isNaN(result) ? 0 : result;
}
async function toStr(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st Argument of TOSTR should be a number");
    return value.toString();
}
async function varSize(vm, arg) {
    const name = await arg[0].reduce(vm);
    string(name, "1st Argument of VARSIZE should be a string");
    const depth = arg.length >= 2 ? await arg[1].reduce(vm) : 0n;
    bigint(depth, "2nd argument of VARSIZE must be a number");
    return vm.getValue(name).length(Number(depth));
}
async function unicode(vm, arg) {
    const value = await arg[0].reduce(vm);
    bigint(value, "1st Argument of UNICODE should be a number");
    return String.fromCharCode(Number(value));
}
async function runGenerator(gen) {
    while(true){
        const value = await gen.next();
        if (value.done === true) {
            return value.value;
        }
    }
}
class InlineCall {
    name;
    arg;
    constructor(name, arg){
        this.name = name.toUpperCase();
        this.arg = arg;
    }
    async reduce(vm) {
        switch(this.name.toUpperCase()){
            case "ABS":
                return abs(vm, this.arg);
            case "BARSTR":
                return barStr(vm, this.arg);
            case "CSVABL":
                return BigInt(await csvAbl(vm, this.arg));
            case "CSVBASE":
                return BigInt(await csvBase(vm, this.arg));
            case "CSVCALLNAME":
                return csvCallname(vm, this.arg);
            case "CSVCFLAG":
                return BigInt(await csvCflag(vm, this.arg));
            case "CSVCSTR":
                return csvCstr(vm, this.arg);
            case "CSVEQUIP":
                return BigInt(await csvEquip(vm, this.arg));
            case "CSVEXP":
                return BigInt(await csvExp(vm, this.arg));
            case "CSVJUEL":
                return BigInt(await csvJuel(vm, this.arg));
            case "CSVMARK":
                return BigInt(await csvMark(vm, this.arg));
            case "CSVMASTERNAME":
                return csvMastername(vm, this.arg);
            case "CSVNAME":
                return csvName(vm, this.arg);
            case "CSVNICKNAME":
                return csvNickname(vm, this.arg);
            case "CSVRELATION":
                return BigInt(await csvRelation(vm, this.arg));
            case "CSVTALENT":
                return BigInt(await csvTalent(vm, this.arg));
            case "EXISTCSV":
                return BigInt(await existCsv(vm, this.arg));
            case "FINDCHARA":
                return findChara(vm, this.arg);
            case "FINDLASTCHARA":
                return findLastChara(vm, this.arg);
            case "GETBGCOLOR":
                return BigInt(getBgColor(vm, this.arg));
            case "GETBIT":
                return BigInt(await getBit(vm, this.arg));
            case "GETCHARA":
                return BigInt(await getChara(vm, this.arg));
            case "GETCOLOR":
                return BigInt(getColor(vm, this.arg));
            case "GETDEFBGCOLOR":
                return BigInt(getDefBgColor(vm, this.arg));
            case "GETDEFCOLOR":
                return BigInt(getDefColor(vm, this.arg));
            case "GETFOCUSCOLOR":
                return BigInt(getFocusColor(vm, this.arg));
            case "GROUPMATCH":
                return BigInt(await groupMatch(vm, this.arg));
            case "INRANGE":
                return BigInt(await inRange(vm, this.arg));
            case "LIMIT":
                return limit(vm, this.arg);
            case "LINEISEMPTY":
                return BigInt(lineIsEmpty(vm, this.arg));
            case "MATCH":
                return BigInt(await match(vm, this.arg));
            case "MAX":
                return max(vm, this.arg);
            case "MAXARRAY":
                return maxArray(vm, this.arg);
            case "MIN":
                return min(vm, this.arg);
            case "MINARRAY":
                return minArray(vm, this.arg);
            case "POWER":
                return power(vm, this.arg);
            case "RAND":
                return rand(vm, this.arg);
            case "SIGN":
                return BigInt(await sign(vm, this.arg));
            case "SQRT":
                return sqrt(vm, this.arg);
            case "STRLENS":
                return BigInt(await strLenS(vm, this.arg));
            case "STRLENSU":
                return BigInt(await strLenSU(vm, this.arg));
            case "SUMARRAY":
                return sumArray(vm, this.arg);
            case "TOINT":
                return BigInt(await toInt(vm, this.arg));
            case "TOSTR":
                return toStr(vm, this.arg);
            case "VARSIZE":
                return BigInt(await varSize(vm, this.arg));
            case "UNICODE":
                return unicode(vm, this.arg);
            default:
                {
                    cond(vm.fnMap.has(this.name), `Method ${this.name} does not exist`);
                    const values = [];
                    for (const arg of this.arg){
                        values.push(await arg.reduce(vm));
                    }
                    const result = await runGenerator(vm.fnMap.get(this.name).run(vm, values));
                    cond(result?.type === "return", "Inline call should return a value");
                    return result.value[0];
                }
        }
    }
}
class Ternary {
    condition;
    left;
    right;
    constructor(condition, left, right){
        this.condition = condition;
        this.left = left;
        this.right = right;
    }
    async reduce(vm) {
        const condition = await this.condition.reduce(vm);
        bigint(condition, "Condition of ternary operator should be an integer");
        return condition !== 0n ? this.left.reduce(vm) : this.right.reduce(vm);
    }
}
class Unary {
    expr;
    op;
    constructor(op, expr){
        this.op = op;
        this.expr = expr;
    }
    async reduce(vm) {
        const value = await this.expr.reduce(vm);
        bigint(value, `Operand of ${this.op} should be an integer`);
        switch(this.op){
            case "+":
                return value;
            case "-":
                return -value;
            case "!":
                return value === 0n ? 1n : 0n;
            case "~":
                return ~value;
        }
    }
}
class UnaryOp {
    target;
    op;
    postfix;
    constructor(target, op, postfix){
        this.target = target;
        this.op = op;
        this.postfix = postfix;
    }
    async reduce(vm) {
        const cell = this.target.getCell(vm);
        const index = await this.target.reduceIndex(vm);
        const value = cell.get(vm, index);
        bigint(value, `Operand of ${this.op} should be an integer`);
        switch(this.op){
            case "++":
                cell.set(vm, value + 1n, index);
                break;
            case "--":
                cell.set(vm, value - 1n, index);
                break;
        }
        if (this.postfix) {
            return value;
        } else {
            switch(this.op){
                case "++":
                    return value + 1n;
                case "--":
                    return value - 1n;
            }
        }
    }
}
const SPECIAL_CHAR = [
    "+",
    "-",
    "*",
    "/",
    "%",
    "=",
    "!",
    "<",
    ">",
    "|",
    "&",
    "^",
    "~",
    "?",
    "#",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    ".",
    ",",
    ":",
    "$",
    "\\",
    "'",
    '"',
    "@",
    ";",
    " ",
    "\t",
    "",
    "\r",
    "\n"
];
const WS = Hn1.oneOf([
    " ",
    "\t",
    ""
].join(""));
const WS0 = WS.many().map(()=>null);
const WS1 = WS.atLeast(1).map(()=>null);
const Identifier = Hn1.noneOf(SPECIAL_CHAR.join("")).atLeast(1).tie();
const UInt = Hn1.alt(Hn1.seqMap(Hn1.regex(/[0-9]+p/i), Hn1.regex(/[0-9]+/), (base, exponent)=>parseInt(base) ** parseInt(exponent)), Hn1.regex(/0b/i).then(Hn1.regex(/[0-1]+/)).map((val)=>parseInt(val, 2)), Hn1.regex(/0x/i).then(Hn1.regex(/[0-9a-fA-F]+/)).map((val)=>parseInt(val, 16)), Hn1.regex(/[0-9]+/).map((val)=>parseInt(val, 10)));
const Int = Hn1.alt(Hn1.string("+").then(UInt), Hn1.string("-").then(UInt).map((val)=>-val), UInt);
const UFloat = Hn1.regex(/[0-9]+\.[0-9]+/).map((val)=>parseFloat(val));
const Float = Hn1.alt(Hn1.string("+").then(UFloat), Hn1.string("-").then(UFloat).map((val)=>-val), UFloat, Int);
const Str = __char('"').many().tie().trim(Hn1.string('"'));
function __char(...exclude) {
    return Hn1.notFollowedBy(Hn1.alt(...exclude.map((c)=>Hn1.string(c)))).then(Hn1.alt(Hn1.string("\\").then(Hn1.alt(Hn1.string("s").map(()=>" "), Hn1.string("S").map(()=>""), Hn1.string("t").map(()=>"\t"), Hn1.string("n").map(()=>"\n"), Hn1.any)), Hn1.any));
}
function charSeq(...exclude) {
    return __char(...exclude).atLeast(1).tie();
}
function alt(...values) {
    return Hn1.alt(...values.map(Hn1.string));
}
function optional(parser) {
    return parser.fallback(undefined);
}
function sepBy0(sep, parser) {
    return Hn1.sepBy(parser, Hn1.string(sep).trim(WS0));
}
function sepBy1(sep, first, rest) {
    return Hn1.seq(first, Hn1.string(sep).trim(WS0).then(rest).many()).map(([f, r])=>[
            f,
            ...r
        ]);
}
function wrap(left, right, parser) {
    return parser.wrap(Hn1.string(left).skip(WS0), WS0.then(Hn1.string(right)));
}
function arg0R0() {
    return Hn1.succeed(null);
}
function arg1R0(a0) {
    return Hn1.alt(WS1.then(a0), WS0.map(()=>undefined));
}
function arg1R1(a0) {
    return WS1.then(a0);
}
function arg2R0(a0, a1) {
    return Hn1.alt(WS1.then(Hn1.seq(a0, Hn1.string(",").trim(WS0).then(a1).fallback(undefined))), WS0.map(()=>[
            undefined,
            undefined
        ]));
}
function arg2R2(a0, a1) {
    return WS1.then(Hn1.seq(a0, Hn1.string(",").trim(WS0).then(a1)));
}
function arg3R3(a0, a1, a2) {
    return WS1.then(Hn1.seqMap(a0, Hn1.string(",").trim(WS0).then(a1), Hn1.string(",").trim(WS0).then(a2), (...arg)=>arg));
}
function arg4R1(a0, a1, a2, a3) {
    return WS1.then(Hn1.seqMap(a0, Hn1.string(",").trim(WS0).then(a1).fallback(undefined), Hn1.string(",").trim(WS0).then(a2).fallback(undefined), Hn1.string(",").trim(WS0).then(a3).fallback(undefined), (...arg)=>arg));
}
function arg4R2(a0, a1, a2, a3) {
    return WS1.then(Hn1.seqMap(a0, Hn1.string(",").trim(WS0).then(a1), Hn1.string(",").trim(WS0).then(a2).fallback(undefined), Hn1.string(",").trim(WS0).then(a3).fallback(undefined), (...arg)=>arg));
}
function arg4R3(a0, a1, a2, a3) {
    return WS1.then(Hn1.seqMap(a0, Hn1.string(",").trim(WS0).then(a1), Hn1.string(",").trim(WS0).then(a2), Hn1.string(",").trim(WS0).then(a3).fallback(undefined), (...arg)=>arg));
}
function arg5R1(a0, a1, a2, a3, a4) {
    return WS1.then(Hn1.seqMap(a0, Hn1.string(",").trim(WS0).then(a1).fallback(undefined), Hn1.string(",").trim(WS0).then(a2).fallback(undefined), Hn1.string(",").trim(WS0).then(a3).fallback(undefined), Hn1.string(",").trim(WS0).then(a4).fallback(undefined), (...arg)=>arg));
}
function arg5R3(a0, a1, a2, a3, a4) {
    return WS1.then(Hn1.seqMap(a0, Hn1.string(",").trim(WS0).then(a1), Hn1.string(",").trim(WS0).then(a2), Hn1.string(",").trim(WS0).then(a3).fallback(undefined), Hn1.string(",").trim(WS0).then(a4).fallback(undefined), (...arg)=>arg));
}
function argNR0(an) {
    return Hn1.alt(WS1.then(sepBy0(",", an)), WS0.map(()=>[])).skip(Hn1.string(",").fallback(""));
}
function argNR1(a0, an) {
    return WS1.then(sepBy1(",", a0, an)).skip(Hn1.string(",").fallback(""));
}
function tryParse(parser1, raw) {
    const result = parser1.parse(raw.get());
    if (result.status) {
        return result.value;
    } else {
        throw parser(`Expected one of (${result.expected.join(", ")})`);
    }
}
const language = Hn1.createLanguage({
    Variable: ()=>Hn1.seqMap(Identifier, optional(Hn1.string("@").then(Identifier)), (name, scope)=>new Variable(name, [], scope)),
    Index: (r)=>Hn1.alt(UInt.map((value)=>new Const(BigInt(value))), r.InlineCall, wrap("(", ")", r.Expr), r.Variable),
    FullVariable: (r)=>Hn1.seqMap(r.Variable, optional(Hn1.string(":").trim(WS0).then(r.Index)), optional(Hn1.string(":").trim(WS0).then(r.Index)), optional(Hn1.string(":").trim(WS0).then(r.Index)), (variable, index0, index1, index2)=>{
            if (index0 == null) {
                variable.index = [];
            } else if (index1 == null) {
                variable.index = [
                    index0
                ];
            } else if (index2 == null) {
                variable.index = [
                    index0,
                    index1
                ];
            } else {
                variable.index = [
                    index0,
                    index1,
                    index2
                ];
            }
            return variable;
        }),
    UnaryOp: (r)=>Hn1.alt(Hn1.seqMap(r.FullVariable, alt("++", "--"), (variable, op)=>new UnaryOp(variable, op, true)), Hn1.seqMap(alt("++", "--"), r.FullVariable, (op, variable)=>new UnaryOp(variable, op, false))),
    Leaf: (r)=>Hn1.alt(UInt.map((val)=>new Const(BigInt(val))), Str.map((value)=>new Const(value)), r.InlineCall, wrap('@"', '"', form['"']), wrap("(", ")", r.Expr), r.UnaryOp, r.FullVariable),
    Unary: (r)=>Hn1.alt(Hn1.seqMap(alt("+", "-", "!", "~").skip(WS0), r.Leaf, (op, expr)=>new Unary(op, expr)), r.Leaf),
    Binary: (r)=>{
        let result = r.Unary;
        const operators = [
            [
                "*",
                "/",
                "%"
            ],
            [
                "+",
                "-"
            ],
            [
                "<<",
                ">>"
            ],
            [
                "<=",
                "<",
                ">=",
                ">"
            ],
            [
                "==",
                "!="
            ],
            [
                "&",
                "|",
                "^"
            ],
            [
                "&&",
                "!&",
                "||",
                "!|",
                "^^"
            ]
        ];
        for (const op of operators){
            result = Hn1.seqMap(result, Hn1.seq(alt(...op).trim(WS0), result).many(), (first, rest)=>rest.reduce((acc, val)=>new Binary(val[0], acc, val[1]), first));
        }
        return result;
    },
    PercentlessBinary: (r)=>{
        let result = r.Unary;
        const operators = [
            [
                "*",
                "/"
            ],
            [
                "+",
                "-"
            ],
            [
                "<<",
                ">>"
            ],
            [
                "<=",
                "<",
                ">=",
                ">"
            ],
            [
                "==",
                "!="
            ],
            [
                "&",
                "|",
                "^"
            ],
            [
                "&&",
                "!&",
                "||",
                "!|",
                "^^"
            ]
        ];
        for (const op of operators){
            result = Hn1.seqMap(result, Hn1.seq(alt(...op).trim(WS0), result).many(), (first, rest)=>rest.reduce((acc, val)=>new Binary(val[0], acc, val[1]), first));
        }
        return result;
    },
    Ternary: (r)=>Hn1.alt(wrap("\\@", "\\@", Hn1.seqMap(r.Binary, Hn1.string("?").trim(WS0).then(optional(Hn1.lazy(()=>form["#"]))), optional(Hn1.string("#").trim(WS0).then(optional(Hn1.lazy(()=>formEnd)))), (expr, left, right)=>new Ternary(expr, left ?? new Const(""), right ?? new Const("")))), Hn1.seqMap(r.Binary, Hn1.string("?").trim(WS0).then(r.Binary), Hn1.string("#").trim(WS0).then(r.Binary), (expr, left, right)=>new Ternary(expr, left, right)), r.Binary),
    PercentlessTernary: (r)=>Hn1.alt(wrap("\\@", "\\@", Hn1.seqMap(r.PercentlessBinary, Hn1.string("?").trim(WS0).then(optional(Hn1.lazy(()=>form["#"]))), optional(Hn1.string("#").trim(WS0).then(optional(Hn1.lazy(()=>formEnd)))), (expr, left, right)=>new Ternary(expr, left ?? new Const(""), right ?? new Const("")))), Hn1.seqMap(r.PercentlessBinary, Hn1.string("?").trim(WS0).then(r.PercentlessBinary), Hn1.string("#").trim(WS0).then(r.PercentlessBinary), (expr, left, right)=>new Ternary(expr, left, right)), r.PercentlessBinary),
    Expr: (r)=>r.Ternary,
    PercentlessExpr: (r)=>r.PercentlessTernary,
    InlineCall: (r)=>Hn1.seqMap(Identifier, WS0.then(wrap("(", ")", sepBy0(",", r.Expr))), (name, arg)=>new InlineCall(name, arg))
});
function formParser(exclude, withTernary) {
    const chunkParser = [];
    chunkParser.push(wrap("{", "}", Hn1.seqMap(language.Expr.trim(WS0), Hn1.string(",").trim(WS0).then(optional(language.Expr)).fallback(undefined), Hn1.string(",").trim(WS0).then(optional(alt("LEFT", "RIGHT"))).fallback(undefined), (value, display, align)=>({
            value,
            display,
            align
        }))));
    chunkParser.push(wrap("%", "%", Hn1.seqMap(language.PercentlessExpr.trim(WS0), Hn1.string(",").trim(WS0).then(optional(language.PercentlessExpr)).fallback(undefined), Hn1.string(",").trim(WS0).then(optional(alt("LEFT", "RIGHT"))).fallback(undefined), (value, display, align)=>({
            value,
            display,
            align
        }))));
    if (withTernary) {
        chunkParser.push(wrap("\\@", "\\@", Hn1.seqMap(language.Binary, Hn1.string("?").trim(WS0).then(optional(Hn1.lazy(()=>form["#"]))), optional(Hn1.string("#").trim(WS0).then(optional(Hn1.lazy(()=>formEnd)))), (expr, left, right)=>({
                value: new Ternary(expr, left ?? new Const(""), right ?? new Const(""))
            }))));
    }
    chunkParser.push(charSeq("{", "%", "\\@", ...exclude).map((value)=>({
            value
        })));
    return Hn1.alt(...chunkParser).atLeast(1).map((expr)=>new Form(expr));
}
const variable = language.FullVariable;
const expr = language.Expr;
const formEnd = formParser("", false);
const form = {
    "": formParser("", true),
    "#": formParser("#", true),
    ",": formParser(",", true),
    '"': formParser('"', true),
    "(": formParser("(", true),
    "(,": formParser("(,", true)
};
class Lazy {
    raw;
    parser;
    isCompiled;
    cache;
    constructor(raw, parser){
        this.parser = parser;
        this.raw = raw;
        this.isCompiled = false;
    }
    get() {
        if (this.isCompiled) {
            return this.cache;
        }
        const result = tryParse(this.parser, this.raw);
        this.isCompiled = true;
        this.cache = result;
        return result;
    }
}
class Statement {
    raw;
    constructor(raw){
        this.raw = raw;
    }
    async *run(_vm, _label) {
        return null;
    }
}
class Call extends Statement {
    static PARSER = Hn1.alt(arg1R1(Hn1.seq(Identifier.skip(WS0), wrap("(", ")", sepBy0(",", optional(expr))))), argNR1(Identifier, optional(expr)).map(([f, ...r])=>[
            f,
            r
        ]));
    static async *exec(vm, target, argExpr) {
        const realTarget = target.toUpperCase();
        cond(vm.fnMap.has(realTarget), `Function ${realTarget} does not exist`);
        const arg = [];
        for (const a of argExpr){
            arg.push(await a?.reduce(vm));
        }
        const result = yield* vm.fnMap.get(realTarget).run(vm, arg);
        switch(result?.type){
            case "begin":
                return result;
            case "goto":
                return result;
            case "break":
                return result;
            case "continue":
                return result;
            case "throw":
                return result;
            case "return":
                {
                    for(let i = 0; i < result.value.length; ++i){
                        vm.getValue("RESULT").set(vm, result.value[i], [
                            i
                        ]);
                    }
                    return null;
                }
            case "quit":
                return result;
            case undefined:
                {
                    vm.getValue("RESULT").set(vm, 0n, [
                        0
                    ]);
                    return null;
                }
        }
    }
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
    }
    async *run(vm) {
        const [target, argExpr] = this.arg.get();
        return yield* Call.exec(vm, target, argExpr);
    }
}
class CallForm extends Statement {
    static PARSER(exclude) {
        return Hn1.alt(arg1R1(Hn1.seq(form[exclude], wrap("(", ")", sepBy0(",", optional(expr))))), argNR1(form[exclude], optional(expr)).map(([f, ...r])=>[
                f,
                r
            ]));
    }
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER("(,"));
    }
    async *run(vm) {
        const [targetExpr, argExpr] = this.arg.get();
        const target = await targetExpr.reduce(vm);
        string(target, "1st argument of CALLFORM must be a string");
        return yield* Call.exec(vm, target, argExpr);
    }
}
class Jump extends Statement {
    static async *exec(vm, target, argExpr) {
        const realTarget = target.toUpperCase();
        cond(vm.fnMap.has(realTarget), `Function ${realTarget} does not exist`);
        const arg = [];
        for (const a of argExpr){
            arg.push(await a?.reduce(vm));
        }
        return yield* vm.fnMap.get(realTarget).run(vm, arg);
    }
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
    }
    async *run(vm) {
        const [target, argExpr] = this.arg.get();
        return yield* Jump.exec(vm, target, argExpr);
    }
}
const PARSER = arg1R1(Identifier);
class Goto extends Statement {
    static *exec(vm, target) {
        const realTarget = target.toUpperCase();
        const context = vm.context();
        cond(context.fn.thunk.labelMap.has(realTarget), `Label ${realTarget} does not exist`);
        return {
            type: "goto",
            label: target
        };
    }
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER);
    }
    async *run(vm) {
        const target = this.arg.get();
        return yield* Goto.exec(vm, target);
    }
}
class Order {
    order;
    constructor(order){
        this.order = order;
    }
}
class Fn2 {
    static START_OF_FN = "@@START";
    name;
    arg;
    property;
    thunk;
    constructor(name, arg, property, thunk){
        this.name = name;
        this.arg = arg;
        this.thunk = thunk;
        this.property = property;
        this.thunk.labelMap.set(Fn2.START_OF_FN, 0);
    }
    isFirst() {
        return this.property.some((p)=>p instanceof Order && p.order === "PRI");
    }
    isLast() {
        return this.property.some((p)=>p instanceof Order && p.order === "LATER");
    }
    async *run(vm, arg) {
        await vm.pushContext(this);
        for(let i = 0; i < this.arg.length; ++i){
            const [argDest, argDef] = this.arg[i];
            const dest = argDest.getCell(vm);
            const index = await argDest.reduceIndex(vm);
            if (dest.type === "number") {
                let value;
                if (arg[i] != null) {
                    value = arg[i];
                } else if (argDef != null) {
                    if (argDef instanceof Variable) {
                        value = await argDef.reduce(vm);
                    } else {
                        value = argDef;
                    }
                } else {
                    value = 0n;
                }
                bigint(value, "Value for number argument must be a number");
                dest.set(vm, value, index);
            } else {
                let value1;
                if (arg[i] != null) {
                    value1 = arg[i];
                } else if (argDef != null) {
                    if (argDef instanceof Variable) {
                        value1 = await argDef.reduce(vm);
                    } else {
                        value1 = argDef;
                    }
                } else {
                    value1 = "";
                }
                string(value1, "Value for string argument must be a string");
                dest.set(vm, value1, index);
            }
        }
        const result = yield* this.thunk.run(vm);
        vm.popContext();
        return result;
    }
}
const PARSER1 = sepBy0(",", form[","]);
class AssignForm extends Statement {
    dest;
    arg;
    constructor(dest, raw){
        super(raw);
        this.dest = dest;
        this.arg = new Lazy(raw, PARSER1);
    }
    async *run(vm) {
        const dest = this.dest.getCell(vm);
        const index = await this.dest.reduceIndex(vm);
        const arg = this.arg.get();
        const partialIndex = index.slice(0, -1);
        const lastIndex = index[index.length - 1] ?? 0;
        if (arg.length !== 0) {
            for(let i = 0; i < arg.length; ++i){
                const value = await arg[i].reduce(vm);
                dest.set(vm, value, [
                    ...partialIndex,
                    lastIndex + i
                ]);
            }
        } else {
            dest.set(vm, "", index);
        }
        return null;
    }
}
const PARSER2 = sepBy0(",", expr);
class AssignInt extends Statement {
    dest;
    arg;
    constructor(dest, raw){
        super(raw);
        this.dest = dest;
        this.arg = new Lazy(raw, PARSER2);
    }
    async *run(vm) {
        const dest = this.dest.getCell(vm);
        const index = await this.dest.reduceIndex(vm);
        const arg = this.arg.get();
        const partialIndex = index.slice(0, -1);
        const lastIndex = index[index.length - 1] ?? 0;
        for(let i = 0; i < arg.length; ++i){
            const value = await arg[i].reduce(vm);
            dest.set(vm, value, [
                ...partialIndex,
                lastIndex + i
            ]);
        }
        return null;
    }
}
const PARSER3 = expr;
class AssignOpInt extends Statement {
    dest;
    operator;
    arg;
    constructor(dest, operator, raw){
        super(raw);
        this.dest = dest;
        this.operator = operator;
        this.arg = new Lazy(raw, PARSER3);
    }
    async *run(vm) {
        const dest = this.dest.getCell(vm);
        const index = await this.dest.reduceIndex(vm);
        const original = dest.get(vm, index);
        const value = await this.arg.get().reduce(vm);
        bigint(value, `Right operand of ${this.operator} should be a number`);
        switch(this.operator){
            case "*=":
                dest.set(vm, original * value, index);
                break;
            case "/=":
                dest.set(vm, original / value, index);
                break;
            case "%=":
                dest.set(vm, original % value, index);
                break;
            case "+=":
                dest.set(vm, original + value, index);
                break;
            case "-=":
                dest.set(vm, original - value, index);
                break;
            case "&=":
                dest.set(vm, original & value, index);
                break;
            case "|=":
                dest.set(vm, original | value, index);
                break;
            case "^=":
                dest.set(vm, original ^ value, index);
                break;
        }
        return null;
    }
}
const PARSER4 = expr;
class AssignOpStr extends Statement {
    dest;
    operator;
    arg;
    constructor(dest, operator, raw){
        super(raw);
        this.dest = dest;
        this.operator = operator;
        this.arg = new Lazy(raw, PARSER4);
    }
    async *run(vm) {
        const dest = this.dest.getCell(vm);
        const index = await this.dest.reduceIndex(vm);
        const original = dest.get(vm, index);
        const arg = await this.arg.get().reduce(vm);
        string(arg, `Right operand of ${this.operator} should be a string`);
        switch(this.operator){
            case "+=":
                dest.set(vm, original + arg, index);
                break;
        }
        return null;
    }
}
const PARSER5 = Hn1.eof;
class AssignPrefix extends Statement {
    dest;
    operator;
    arg;
    constructor(dest, operator, raw){
        super(raw);
        this.dest = dest;
        this.operator = operator;
        this.arg = new Lazy(raw, PARSER5);
    }
    async *run(vm) {
        this.raw.get();
        const dest = this.dest.getCell(vm);
        cond(dest.type === "number", "++/-- should be used with a numeric variable");
        const index = await this.dest.reduceIndex(vm);
        const original = dest.get(vm, index);
        switch(this.operator){
            case "++":
                dest.set(vm, original + 1n, index);
                break;
            case "--":
                dest.set(vm, original - 1n, index);
                break;
        }
        return null;
    }
}
const PARSER6 = Hn1.eof;
class AssignPostfix extends Statement {
    dest;
    operator;
    arg;
    constructor(dest, operator, raw){
        super(raw);
        this.dest = dest;
        this.operator = operator;
        this.arg = new Lazy(raw, PARSER6);
    }
    async *run(vm) {
        this.raw.get();
        const dest = this.dest.getCell(vm);
        cond(dest.type === "number", "++/-- should be used with a numeric variable");
        const index = await this.dest.reduceIndex(vm);
        const original = dest.get(vm, index);
        switch(this.operator){
            case "++":
                dest.set(vm, original + 1n, index);
                break;
            case "--":
                dest.set(vm, original - 1n, index);
                break;
        }
        return null;
    }
}
const PARSER7 = sepBy0(",", expr);
class AssignStr extends Statement {
    dest;
    arg;
    constructor(dest, raw){
        super(raw);
        this.dest = dest;
        this.arg = new Lazy(raw, PARSER7);
    }
    async *run(vm) {
        const dest = this.dest.getCell(vm);
        const index = await this.dest.reduceIndex(vm);
        const arg = this.arg.get();
        const partialIndex = index.slice(0, -1);
        const lastIndex = index[index.length - 1] ?? 0;
        for(let i = 0; i < arg.length; ++i){
            const value = await arg[i].reduce(vm);
            dest.set(vm, value, [
                ...partialIndex,
                lastIndex + i
            ]);
        }
        return null;
    }
}
const PARSER_PREFIX = Hn1.seq(alt("++", "--").trim(WS0), variable, Hn1.all);
const PARSER_POSTFIX = Hn1.seq(variable, alt("++", "--").trim(WS0), Hn1.all);
const PARSER_VAR = Hn1.seq(variable, Hn1.alt(alt("="), alt("'="), alt("*=", "/=", "%=", "+=", "-=", "&=", "|=", "^=")).trim(WS0), Hn1.all);
class Assign extends Statement {
    inner;
    constructor(raw){
        super(raw);
    }
    compile(vm) {
        try {
            const [op, dest, rest] = tryParse(PARSER_PREFIX, this.raw);
            const restSlice = this.raw.slice(this.raw.length() - rest.length);
            const destType = dest.getCell(vm).type;
            if (op === "++" && destType === "number") {
                this.inner = new AssignPrefix(dest, "++", restSlice);
            } else if (op === "--" && destType === "number") {
                this.inner = new AssignPrefix(dest, "--", restSlice);
            }
            return;
        } catch  {}
        try {
            const [dest1, op1, rest1] = tryParse(PARSER_POSTFIX, this.raw);
            const restSlice1 = this.raw.slice(this.raw.length() - rest1.length);
            const destType1 = dest1.getCell(vm).type;
            if (op1 === "++" && destType1 === "number") {
                this.inner = new AssignPostfix(dest1, "++", restSlice1);
            } else if (op1 === "--" && destType1 === "number") {
                this.inner = new AssignPostfix(dest1, "--", restSlice1);
            }
            return;
        } catch  {}
        try {
            const [dest2, op2, rest2] = tryParse(PARSER_VAR, this.raw);
            const restSlice2 = this.raw.slice(this.raw.length() - rest2.length);
            const destType2 = dest2.getCell(vm).type;
            if (op2 === "=" && destType2 === "number") {
                this.inner = new AssignInt(dest2, restSlice2);
            } else if (op2 === "=" && destType2 === "string") {
                this.inner = new AssignForm(dest2, restSlice2);
            } else if (op2 === "'=") {
                this.inner = new AssignStr(dest2, restSlice2);
            } else if (op2 === "+=" && destType2 === "string") {
                this.inner = new AssignOpStr(dest2, "+=", restSlice2);
            } else if ([
                "*=",
                "/=",
                "%=",
                "+=",
                "-=",
                "&=",
                "|=",
                "^="
            ].includes(op2) && destType2 === "number") {
                this.inner = new AssignOpInt(dest2, op2, restSlice2);
            }
            return;
        } catch  {}
        throw parser("Invalid assignment expression");
    }
    async *run(vm) {
        if (this.inner == null) {
            this.compile(vm);
        }
        return yield* vm.run(this.inner);
    }
}
class Int0DValue {
    type = "number";
    name;
    value;
    static normalizeIndex(name, index) {
        if (index.length === 0) {
            return [];
        } else if (index.length === 1 && index[0] === 0) {
            return [];
        } else {
            throw invalidIndex("0D", name, index);
        }
    }
    constructor(name){
        this.name = name;
        this.value = 0n;
    }
    reset(value) {
        this.value = BigInt(value);
        return this;
    }
    get(_vm, index) {
        Int0DValue.normalizeIndex(this.name, index);
        return this.value;
    }
    set(_vm, value, index) {
        Int0DValue.normalizeIndex(this.name, index);
        bigint(value, "Cannot assign a string to a numeric variable");
        this.value = value;
    }
    rangeSet(_vm, value, _index, _range) {
        bigint(value, "Cannot assign a string to a numeric variable");
        this.value = value;
    }
    length(depth) {
        switch(depth){
            case 0:
                return 1;
            default:
                throw new Error(`0D variable doesn't have a value at depth ${depth}`);
        }
    }
}
class Int1DValue {
    type = "number";
    name;
    value;
    static normalizeIndex(name, index) {
        if (index.length === 0) {
            return [
                0
            ];
        } else if (index.length === 1) {
            return index;
        } else if (index.length === 2 && index[1] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("1D", name, index);
        }
    }
    constructor(name, size){
        const realSize = size ?? [
            1000
        ];
        cond(realSize.length === 1, `${name} is not a ${realSize.length}D variable`);
        this.name = name;
        this.value = new Array(realSize[0]).fill(0n);
    }
    reset(value) {
        for(let i = 0; i < this.value.length; ++i){
            this.value[i] = 0n;
        }
        if (value instanceof Map) {
            for (const [i1, val] of value){
                this.value[i1] = BigInt(val);
            }
        } else {
            for(let i2 = 0; i2 < value.length; ++i2){
                this.value[i2] = BigInt(value[i2]);
            }
        }
        return this;
    }
    get(_vm, index) {
        const realIndex = Int1DValue.normalizeIndex(this.name, index);
        return this.value[realIndex[0]];
    }
    set(_vm, value, index) {
        const realIndex = Int1DValue.normalizeIndex(this.name, index);
        bigint(value, "Cannot assign a string to a numeric variable");
        this.value[realIndex[0]] = value;
    }
    rangeSet(_vm, value, _index, range) {
        bigint(value, "Cannot assign a string to a numeric variable");
        for(let i = range[0]; i < range[1]; ++i){
            this.value[i] = value;
        }
    }
    length(depth) {
        switch(depth){
            case 0:
                return this.value.length;
            case 1:
                return 1;
            default:
                throw new Error(`1D variable doesn't have a value at depth ${depth}`);
        }
    }
}
class IntChar0DValue {
    type = "number";
    name;
    value;
    static normalizeIndex(vm, name, index) {
        if (index.length === 0) {
            return [
                Number(vm.getValue("TARGET").get(vm, []))
            ];
        } else if (index.length === 1) {
            return index;
        } else if (index.length === 2 && index[1] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("0D character", name, index);
        }
    }
    constructor(name){
        this.name = name;
    }
    reset() {
        throw internal(`0D character variable ${this.name} cannot be reset`);
    }
    get(vm, index) {
        const realIndex = IntChar0DValue.normalizeIndex(vm, this.name, index);
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        return cell.get(vm, realIndex.slice(1));
    }
    set(vm, value, index) {
        const realIndex = IntChar0DValue.normalizeIndex(vm, this.name, index);
        bigint(value, "Cannot assign a string to a numeric variable");
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        cell.set(vm, value, realIndex.slice(1));
    }
    rangeSet(vm, value, index, _range) {
        this.set(vm, value, index);
    }
    length(depth) {
        switch(depth){
            case 0:
                return 1;
            case 1:
                return 1;
            default:
                throw new Error(`1D character variable doesn't have a value at depth ${depth}`);
        }
    }
}
class IntChar1DValue {
    type = "number";
    name;
    value;
    size;
    static normalizeIndex(vm, name, index) {
        if (index.length === 0) {
            return [
                Number(vm.getValue("TARGET").get(vm, [])),
                0
            ];
        } else if (index.length === 1) {
            return [
                Number(vm.getValue("TARGET").get(vm, [])),
                index[0]
            ];
        } else if (index.length === 2) {
            return index;
        } else if (index.length === 3 && index[2] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("1D character", name, index);
        }
    }
    constructor(name, size){
        const realSize = size ?? [
            100
        ];
        cond(realSize.length === 1, `${name} is not a ${realSize.length}D variable`);
        this.name = name;
        this.size = realSize[0];
    }
    reset() {
        throw internal(`1D character variable ${this.name} cannot be reset`);
    }
    get(vm, index) {
        const realIndex = IntChar1DValue.normalizeIndex(vm, this.name, index);
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        return cell.get(vm, realIndex.slice(1));
    }
    set(vm, value, index) {
        const realIndex = IntChar1DValue.normalizeIndex(vm, this.name, index);
        bigint(value, "Cannot assign a string to a numeric variable");
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        cell.set(vm, value, realIndex.slice(1));
    }
    rangeSet(vm, value, index, range) {
        const realIndex = IntChar1DValue.normalizeIndex(vm, this.name, [
            ...index,
            0
        ]);
        bigint(value, "Cannot assign a string to a numeric variable");
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        cell.rangeSet(vm, value, realIndex.slice(1), range);
    }
    length(depth) {
        switch(depth){
            case 0:
                return this.size;
            case 1:
                return this.size;
            case 2:
                return 1;
            default:
                throw new Error(`1D character variable doesn't have a value at depth ${depth}`);
        }
    }
}
class Str0DValue {
    type = "string";
    name;
    value;
    static normalizeIndex(name, index) {
        if (index.length === 0) {
            return [];
        } else if (index.length === 1 && index[0] === 0) {
            return [];
        } else {
            throw invalidIndex("0D", name, index);
        }
    }
    constructor(name){
        this.name = name;
        this.value = "";
    }
    reset(value) {
        this.value = value;
        return this;
    }
    get(_vm, index) {
        Str0DValue.normalizeIndex(this.name, index);
        return this.value;
    }
    set(_vm, value, index) {
        Str0DValue.normalizeIndex(this.name, index);
        string(value, "Cannot assign a number to a string variable");
        this.value = value;
    }
    rangeSet(_vm, value, _index, _range) {
        string(value, "Cannot assign a number to a string variable");
        this.value = value;
    }
    length(depth) {
        switch(depth){
            case 0:
                return 1;
            default:
                throw new Error(`0D variable doesn't have a value at depth ${depth}`);
        }
    }
}
class Str1DValue {
    type = "string";
    name;
    value;
    static normalizeIndex(name, index) {
        if (index.length === 0) {
            return [
                0
            ];
        } else if (index.length === 1) {
            return index;
        } else if (index.length === 2 && index[1] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("1D", name, index);
        }
    }
    constructor(name, size){
        const realSize = size ?? [
            100
        ];
        cond(realSize.length === 1, `${name} is not a ${realSize.length}D variable`);
        this.name = name;
        this.value = new Array(realSize[0]).fill("");
    }
    reset(value) {
        for(let i = 0; i < this.value.length; ++i){
            this.value[i] = "";
        }
        if (value instanceof Map) {
            for (const [i1, val] of value){
                this.value[i1] = val;
            }
        } else {
            for(let i2 = 0; i2 < value.length; ++i2){
                this.value[i2] = value[i2];
            }
        }
        return this;
    }
    get(_vm, index) {
        const realIndex = Str1DValue.normalizeIndex(this.name, index);
        return this.value[realIndex[0]];
    }
    set(_vm, value, index) {
        const realIndex = Str1DValue.normalizeIndex(this.name, index);
        string(value, "Cannot assign a number to a string variable");
        this.value[realIndex[0]] = value;
    }
    rangeSet(_vm, value, _index, range) {
        string(value, "Cannot assign a number to a string variable");
        for(let i = range[0]; i < range[1]; ++i){
            this.value[i] = value;
        }
    }
    length(depth) {
        switch(depth){
            case 0:
                return this.value.length;
            case 1:
                return 1;
            default:
                throw new Error(`1D variable doesn't have a value at depth ${depth}`);
        }
    }
}
class StrChar0DValue {
    type = "string";
    name;
    value;
    static normalizeIndex(vm, name, index) {
        if (index.length === 0) {
            return [
                Number(vm.getValue("TARGET").get(vm, []))
            ];
        } else if (index.length === 1) {
            return index;
        } else if (index.length === 2 && index[0] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("0D character", name, index);
        }
    }
    constructor(name){
        this.name = name;
    }
    reset() {
        throw internal(`0D character variable ${this.name} cannot be reset`);
    }
    get(vm, index) {
        const realIndex = StrChar0DValue.normalizeIndex(vm, this.name, index);
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        return cell.get(vm, realIndex.slice(1));
    }
    set(vm, value, index) {
        const realIndex = StrChar0DValue.normalizeIndex(vm, this.name, index);
        string(value, "Cannot assign a number to a string variable");
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        cell.set(vm, value, realIndex.slice(1));
    }
    rangeSet(vm, value, index, _range) {
        this.set(vm, value, index);
    }
    length(depth) {
        switch(depth){
            case 0:
                return 1;
            case 1:
                return 1;
            default:
                throw new Error(`1D character variable doesn't have a value at depth ${depth}`);
        }
    }
}
class StrChar1DValue {
    type = "string";
    name;
    value;
    size;
    static normalizeIndex(vm, name, index) {
        if (index.length === 0) {
            return [
                Number(vm.getValue("TARGET").get(vm, [])),
                0
            ];
        } else if (index.length === 1) {
            return [
                Number(vm.getValue("TARGET").get(vm, [])),
                index[0]
            ];
        } else if (index.length === 2) {
            return index;
        } else if (index.length === 3 && index[2] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("1D character", name, index);
        }
    }
    constructor(name, size){
        const realSize = size ?? [
            100
        ];
        cond(realSize.length === 1, `${name} is not a ${realSize.length}D variable`);
        this.name = name;
        this.size = realSize[0];
    }
    reset() {
        throw internal(`1D character variable ${this.name} cannot be reset`);
    }
    get(vm, index) {
        const realIndex = StrChar1DValue.normalizeIndex(vm, this.name, index);
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        return cell.get(vm, realIndex.slice(1));
    }
    set(vm, value, index) {
        const realIndex = StrChar1DValue.normalizeIndex(vm, this.name, index);
        string(value, "Cannot assign a number to a string variable");
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        cell.set(vm, value, realIndex.slice(1));
    }
    rangeSet(vm, value, index, range) {
        const realIndex = StrChar1DValue.normalizeIndex(vm, this.name, [
            ...index,
            0
        ]);
        string(value, "Cannot assign a number to a string variable");
        if (vm.characterList.length <= realIndex[0]) {
            throw notFound("Character", `#${realIndex[0]}`);
        }
        const cell = vm.characterList[realIndex[0]].getValue(this.name);
        cell.rangeSet(vm, value, realIndex.slice(1), range);
    }
    length(depth) {
        switch(depth){
            case 0:
                return this.size;
            case 1:
                return this.size;
            case 2:
                return 1;
            default:
                throw new Error(`1D character variable doesn't have a value at depth ${depth}`);
        }
    }
}
class Character {
    values;
    constructor(vm, template){
        this.values = new Map();
        for (const [name, value] of vm.globalMap){
            if (value instanceof IntChar0DValue) {
                this.values.set(name, new Int0DValue(name));
            } else if (value instanceof IntChar1DValue) {
                this.values.set(name, new Int1DValue(name, [
                    value.size
                ]));
            } else if (value instanceof StrChar0DValue) {
                this.values.set(name, new Str0DValue(name));
            } else if (value instanceof StrChar1DValue) {
                this.values.set(name, new Str1DValue(name, [
                    value.size
                ]));
            }
        }
        this.getValue("NO").reset(template.no);
        this.getValue("NAME").reset(template.name);
        this.getValue("CALLNAME").reset(template.callname);
        this.getValue("NICKNAME").reset(template.nickname);
        this.getValue("MASTERNAME").reset(template.mastername);
        this.getValue("BASE").reset(template.maxBase);
        this.getValue("MAXBASE").reset(template.maxBase);
        this.getValue("MARK").reset(template.mark);
        this.getValue("EXP").reset(template.exp);
        this.getValue("ABL").reset(template.abl);
        this.getValue("TALENT").reset(template.talent);
        this.getValue("RELATION").reset(template.relation);
        this.getValue("CFLAG").reset(template.cflag);
        this.getValue("EQUIP").reset(template.equip);
        this.getValue("JUEL").reset(template.juel);
        this.getValue("CSTR").reset(template.cstr);
    }
    getValue(name) {
        if (this.values.has(name)) {
            return this.values.get(name);
        } else {
            throw notFound("Character", name);
        }
    }
}
const PARSER8 = argNR0(expr);
class AddChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER8);
    }
    async *run(vm) {
        for (const expr of this.arg.get()){
            const id = await expr.reduce(vm);
            bigint(id, "Character id should be an integer");
            const template = vm.templateMap.get(Number(id));
            cond(template != null, `Character template with id ${id} does not exist`);
            vm.characterList.push(new Character(vm, template));
        }
        return null;
    }
}
const PARSER9 = arg1R1(expr);
class AddCopyChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER9);
    }
    async *run() {
        throw notImpl("ADDCOPYCHARA");
        return null;
    }
}
const PARSER10 = arg0R0();
class AddDefChara extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER10, raw);
    }
    async *run(vm) {
        const template = vm.templateMap.get(0);
        cond(template != null, "Character template with id 0 does not exist");
        vm.characterList.push(new Character(vm, template));
        return null;
    }
}
const PARSER11 = arg0R0();
class AddVoidChara extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER11, raw);
    }
    async *run() {
        throw notImpl("ADDVOIDCHARA");
        return null;
    }
}
const PARSER12 = arg1R1(alt("LEFT", "CENTER", "RIGHT"));
class Alignment extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER12);
    }
    async *run(vm) {
        vm.printer.align = this.arg.get();
        return null;
    }
}
const PARSER13 = arg3R3(variable, expr, expr);
class ArrayRemove extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER13);
    }
    async *run(vm) {
        const [targetExpr, startExpr, countExpr] = this.arg.get();
        const target = targetExpr.getCell(vm);
        const index = await targetExpr.reduceIndex(vm);
        const length = target.length(index.length);
        const start = await startExpr.reduce(vm);
        bigint(start, "2nd argument of ARRAYREMOVE must be a number");
        const count = await countExpr.reduce(vm);
        bigint(count, "3rd argument of ARRAYREMOVE must be a number");
        for(let i = start; i < BigInt(length) - count; ++i){
            const value = target.get(vm, [
                ...index,
                Number(i + count)
            ]);
            target.set(vm, value, [
                ...index,
                Number(i)
            ]);
        }
        for(let i1 = 0n; i1 < count; ++i1){
            if (target.type === "number") {
                target.set(vm, 0n, [
                    ...index,
                    length - 1 - Number(i1)
                ]);
            } else {
                target.set(vm, "", [
                    ...index,
                    length - 1 - Number(i1)
                ]);
            }
        }
        return null;
    }
}
const PARSER14 = arg5R3(variable, expr, expr, expr, expr);
class ArrayShift extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER14);
    }
    async *run(vm) {
        const [targetExpr, countExpr, fillExpr] = this.arg.get();
        const target = targetExpr.getCell(vm);
        const index = await targetExpr.reduceIndex(vm);
        const length = target.length(index.length);
        const count = await countExpr.reduce(vm);
        bigint(count, "2nd argument of ARRAYSHIFT must be a number");
        const fill = await fillExpr.reduce(vm);
        if (count > 0) {
            for(let i = length - 1; i >= count; --i){
                const value = target.get(vm, [
                    ...index,
                    i - Number(count)
                ]);
                target.set(vm, value, [
                    ...index,
                    i
                ]);
            }
            for(let i1 = count - 1n; i1 >= 0; --i1){
                target.set(vm, fill, [
                    ...index,
                    Number(i1)
                ]);
            }
        } else if (count < 0) {
            for(let i2 = 0; i2 < length + Number(count); ++i2){
                const value1 = target.get(vm, [
                    ...index,
                    i2 - Number(count)
                ]);
                target.set(vm, value1, [
                    ...index,
                    i2
                ]);
            }
            for(let i3 = length + Number(count); i3 < length; ++i3){
                target.set(vm, fill, [
                    ...index,
                    i3
                ]);
            }
        }
        return null;
    }
}
const PARSER15 = arg3R3(expr, expr, expr);
class Bar extends Statement {
    arg;
    newline;
    constructor(raw, newline = false){
        super(raw);
        this.arg = new Lazy(raw, PARSER15);
        this.newline = newline;
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const [valueExpr, maxExpr, lengthExpr] = this.arg.get();
        const value = await valueExpr.reduce(vm);
        bigint(value, "1st argument of BAR must be a number");
        const max = await maxExpr.reduce(vm);
        bigint(max, "2nd argument of BAR must be a number");
        const length = await lengthExpr.reduce(vm);
        bigint(length, "3rd argument of BAR must be a number");
        const filled = length * value / max;
        const text = "[" + "*".repeat(Number(filled)) + ".".repeat(Number(length - filled)) + "]";
        yield* vm.printer.print(text, new Set());
        if (this.newline) {
            yield* vm.printer.newline();
        }
        return null;
    }
}
const PARSER16 = arg1R1(Identifier);
class Begin extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER16);
    }
    async *run() {
        return {
            type: "begin",
            keyword: this.arg.get()
        };
    }
}
const PARSER17 = arg0R0();
class Break extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER17, raw);
    }
    async *run() {
        return {
            type: "break"
        };
    }
}
class CallF extends Statement {
    static async *exec(vm, target, argExpr) {
        const realTarget = target.toUpperCase();
        cond(vm.fnMap.has(realTarget), `Function ${realTarget} does not exist`);
        const arg = [];
        for (const a of argExpr){
            arg.push(await a?.reduce(vm));
        }
        const result = yield* vm.fnMap.get(realTarget).run(vm, arg);
        switch(result?.type){
            case "begin":
                return result;
            case "goto":
                return result;
            case "break":
                return result;
            case "continue":
                return result;
            case "throw":
                return result;
            case "return":
                return null;
            case "quit":
                return result;
            case undefined:
                return null;
        }
    }
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
    }
    async *run(vm) {
        const [target, argExpr] = this.arg.get();
        return yield* CallF.exec(vm, target, argExpr);
    }
}
class CallFormF extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER("(,"));
    }
    async *run(vm) {
        const [targetExpr, argExpr] = this.arg.get();
        const target = await targetExpr.reduce(vm);
        string(target, "1st argument of CALLFORMF must be a string");
        return yield* CallF.exec(vm, target, argExpr);
    }
}
const PARSER18 = arg1R1(expr);
class CallTrain extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER18);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        bigint(value, "Argument of CALLTRAIN must be a number");
        return null;
    }
}
const PARSER19 = arg0R0();
class CbgClear extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER19, raw);
    }
    async *run() {
        throw notImpl("CBGCLEAR");
        return null;
    }
}
const PARSER20 = arg0R0();
class CbgClearButton extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER20, raw);
    }
    async *run() {
        throw notImpl("CBGCLEARBUTTON");
        return null;
    }
}
const PARSER21 = arg0R0();
class CbgRemoveBmap extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER21, raw);
    }
    async *run() {
        throw notImpl("CBGREMOVEBMAP");
        return null;
    }
}
const savefile = {
    global: "global.sav",
    game: (i)=>"save" + i.toString().padStart(2, "0") + ".sav"
};
const PARSER22 = arg1R1(expr);
class ChkData extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER22);
    }
    async *run(vm) {
        const index = await this.arg.get().reduce(vm);
        bigint(index, "1st argument of CHKDATA must be a number");
        let result;
        let message = "";
        const file = savefile.game(Number(index));
        const raw = await vm.external.getSavedata(file);
        if (raw == null) {
            result = 1n;
            message = "----";
        } else {
            try {
                const parsed = JSON.parse(raw);
                number(parsed.code, `Save file ${file} is not in a valid format`);
                number(parsed.version, `Save file ${file} is not in a valid format`);
                string(parsed.data.comment, `Save file ${file} is not in a valid format`);
                const code = vm.code.csv.gamebase.code ?? 0;
                const version = vm.code.csv.gamebase.version ?? 0;
                if (parsed.code !== code) {
                    result = 2n;
                    message = "";
                } else if (parsed.version !== version) {
                    result = 3n;
                    message = "";
                } else {
                    result = 0n;
                    message = parsed.data.comment;
                }
            } catch  {
                result = 4n;
                message = "";
            }
        }
        vm.getValue("RESULT").set(vm, result, [
            0
        ]);
        vm.getValue("RESULTS").set(vm, message, [
            0
        ]);
        return null;
    }
}
const PARSER23 = arg1R1(expr);
class ChkFont extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER23);
    }
    async *run(vm) {
        const arg = await this.arg.get().reduce(vm);
        string(arg, "1st argument of CHKFONT should be a string");
        const result = vm.external.getFont(arg) ? 1n : 0n;
        vm.getValue("RESULT").set(vm, result, [
            0
        ]);
        return null;
    }
}
const PARSER24 = argNR1(variable, expr);
class ClearBit extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER24);
    }
    async *run(vm) {
        const [destExpr, ...bitExpr] = this.arg.get();
        const value = await destExpr.reduce(vm);
        bigint(value, "1st argument of CLEARBIT must be a number");
        const bitList = [];
        for(let i = 0; i < bitExpr.length; ++i){
            const bit = await bitExpr[i].reduce(vm);
            bigint(bit, `${i + 1}th Argument of CLEARBIT must be a number`);
            bitList.push(bit);
        }
        let result = value;
        for (const bit1 of bitList){
            result &= ~(1n << bit1);
        }
        destExpr.getCell(vm).set(vm, result, await destExpr.reduceIndex(vm));
        return null;
    }
}
const PARSER25 = arg1R1(expr);
class ClearLine extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER25);
    }
    async *run(vm) {
        const count = await this.arg.get().reduce(vm);
        bigint(count, "Argument of CLEARLINE must be an integer!");
        yield* vm.printer.clear(Number(count));
        return null;
    }
}
const PARSER26 = arg0R0();
class ClearTextBox extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER26, raw);
    }
    async *run() {
        throw notImpl("CLEARTEXTBOX");
        return null;
    }
}
const PARSER27 = arg0R0();
class Continue extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER27, raw);
    }
    async *run() {
        return {
            type: "continue"
        };
    }
}
const PARSER28 = arg2R2(expr, expr);
class CopyChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER28);
    }
    async *run() {
        throw notImpl("COPYCHARA");
        return null;
    }
}
const PARSER29 = arg0R0();
class CUpCheck extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER29, raw);
    }
    async *run(vm) {
        const length = Math.min(vm.getValue("PALAM").length(1), vm.getValue("CUP").length(1), vm.getValue("CDOWN").length(1));
        for(let i = 0; i < length; ++i){
            const up = vm.getValue("CUP").get(vm, [
                i
            ]);
            const down = vm.getValue("CDOWN").get(vm, [
                i
            ]);
            const palam = vm.getValue("PALAM").get(vm, [
                i
            ]);
            if (up <= 0 && down <= 0) {
                continue;
            }
            const result = palam + up - down;
            vm.getValue("PALAM").set(vm, result, [
                i
            ]);
            vm.getValue("CUP").set(vm, 0n, [
                i
            ]);
            vm.getValue("CDOWN").set(vm, 0n, [
                i
            ]);
            if (!vm.printer.skipDisp) {
                const name = vm.code.csv.palam.get(i);
                let text = `${name} ${palam}`;
                if (up > 0) {
                    text += `+${up}`;
                }
                if (down > 0) {
                    text += `-${down}`;
                }
                text += `=${result}`;
                yield* vm.printer.print(text, new Set([
                    "L"
                ]));
            }
        }
        return null;
    }
}
const PARSER30 = arg0R0();
class CurrentAlign extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER30, raw);
    }
    async *run() {
        throw notImpl("CURRENTALIGN");
        return null;
    }
}
const PARSER31 = arg0R0();
class CurrentRedraw extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER31, raw);
    }
    async *run(vm) {
        vm.getValue("RESULT").set(vm, vm.printer.draw ? 1n : 0n, [
            0
        ]);
        return null;
    }
}
const PARSER32 = arg1R1(charSeq());
class CustomDrawLine extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER32);
    }
    async *run(vm) {
        const value = this.arg.get();
        yield* vm.printer.line(value);
        return null;
    }
}
const PARSER33 = arg5R1(variable, expr, expr, expr, expr);
class VarSet extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER33);
    }
    async *run(vm) {
        const [destExpr, indexExpr, valueExpr, startExpr, endExpr] = this.arg.get();
        const index = await indexExpr?.reduce(vm) ?? 0n;
        bigint(index, "2nd argument of CVARSET must be a number");
        const value = await valueExpr?.reduce(vm);
        const start = await startExpr?.reduce(vm) ?? 0n;
        bigint(start, "4th argument of CVARSET must be a number");
        const end = await endExpr?.reduce(vm) ?? BigInt(vm.characterList.length);
        bigint(end, "5th argument of CVARSET must be a number");
        for(let i = start; i < end; ++i){
            const character = vm.characterList[Number(i)];
            const cell = character.getValue(destExpr.name);
            if (value != null) {
                cell.set(vm, value, [
                    Number(index)
                ]);
            } else {
                if (cell.type === "number") {
                    cell.set(vm, 0n, [
                        Number(index)
                    ]);
                } else {
                    cell.set(vm, "", [
                        Number(index)
                    ]);
                }
            }
        }
        return null;
    }
}
const PARSER34 = arg0R0();
class DebugClear extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER34, raw);
    }
    async *run() {
        throw notImpl("DEBUGCLEAR");
        return null;
    }
}
const PARSER35 = arg1R0(charSeq()).map((str)=>str ?? "");
class DebugPrint extends Statement {
    flags;
    value;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.value = new Lazy(raw, PARSER35);
    }
    async *run(_vm) {
        return null;
    }
}
const PARSER36 = arg1R0(form[""]).map((form)=>form ?? new Form([
        {
            value: ""
        }
    ]));
class DebugPrintForm extends Statement {
    flags;
    arg;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.arg = new Lazy(raw, PARSER36);
    }
    async *run(_vm) {
        return null;
    }
}
const PARSER37 = arg0R0();
class DelAllChara extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER37, raw);
    }
    async *run() {
        throw notImpl("DELALLCHARA");
        return null;
    }
}
const PARSER38 = argNR0(expr);
class DelChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER38);
    }
    async *run(vm) {
        const arg = this.arg.get();
        const indexList = [];
        for(let i = 0; i < arg.length; ++i){
            const index = await arg[i].reduce(vm);
            bigint(index, `${i + 1}th argument of DELCHARA should be a number`);
            indexList.push(index);
        }
        indexList.sort();
        indexList.reverse();
        for (const index1 of indexList){
            vm.characterList.splice(Number(index1), 1);
        }
        return null;
    }
}
const PARSER39 = arg1R1(expr);
class DelData extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER39);
    }
    async *run(vm) {
        const index = await this.arg.get().reduce(vm);
        bigint(index, "Argument of DELDATA must be a number");
        throw notImpl("DELDATA");
        return null;
    }
}
const PARSER40 = arg0R0();
class DrawLine extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER40, raw);
    }
    async *run(vm) {
        yield* vm.printer.line();
        return null;
    }
}
const PARSER41 = arg1R1(form[""]);
class DrawLineForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER41);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        yield* vm.printer.line(value);
        return null;
    }
}
const PARSER42 = arg0R0();
class DumpRand extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER42, raw);
    }
    async *run(vm) {
        vm.getValue("RANDDATA").set(vm, BigInt(vm.random.state), []);
        return null;
    }
}
const PARSER43 = arg1R1(form[""]);
class EncodeToUni extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER43);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        string(value, "1st argument of ENCODETOUNI must be a string");
        const buffer = Buffer.from(value, "utf8");
        vm.getValue("RESULT").set(vm, BigInt(buffer.byteLength), [
            0
        ]);
        for(let i = 0; i < buffer.byteLength; ++i){
            vm.getValue("RESULT").set(vm, BigInt(buffer[i]), [
                i + 1
            ]);
        }
        return null;
    }
}
const PARSER44 = arg1R1(expr);
class Escape extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER44);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        string(value, "1st argument of ESCAPE must be a string");
        let result = value;
        result = result.replace("\\", "\\\\");
        result = result.replace("*", "\\*");
        result = result.replace("+", "\\+");
        result = result.replace("?", "\\?");
        result = result.replace("|", "\\|");
        result = result.replace("{", "\\}");
        result = result.replace("[", "\\[");
        result = result.replace("(", "\\(");
        result = result.replace(")", "\\)");
        result = result.replace("^", "\\^");
        result = result.replace("$", "\\$");
        result = result.replace(".", "\\.");
        result = result.replace("#", "\\#");
        vm.getValue("RESULTS").set(vm, result, [
            0
        ]);
        return null;
    }
}
const PARSER45 = arg0R0();
class FontBold extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER45, raw);
    }
    async *run(vm) {
        vm.printer.font.bold = !vm.printer.font.bold;
        return null;
    }
}
const PARSER46 = arg0R0();
class FontItalic extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER46, raw);
    }
    async *run(vm) {
        vm.printer.font.italic = !vm.printer.font.italic;
        return null;
    }
}
const PARSER47 = arg0R0();
class FontRegular extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER47, raw);
    }
    async *run(vm) {
        vm.printer.font.bold = false;
        vm.printer.font.italic = false;
        vm.printer.font.strike = false;
        vm.printer.font.underline = false;
        return null;
    }
}
const PARSER48 = arg1R1(expr);
class FontStyle extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER48);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        bigint(value, "Argument of FONTSTYLE must be an integer!");
        vm.printer.font.bold = (value & 1n << 0n) !== 0n;
        vm.printer.font.italic = (value & 1n << 1n) !== 0n;
        vm.printer.font.strike = (value & 1n << 2n) !== 0n;
        vm.printer.font.underline = (value & 1n << 3n) !== 0n;
        return null;
    }
}
const PARSER49 = arg0R0();
class ForceWait extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER49, raw);
    }
    async *run() {
        throw notImpl("FORCEWAIT");
        return null;
    }
}
const PARSER50 = arg2R2(expr, expr);
class GetExpLv extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER50);
    }
    async *run(vm) {
        const [valExpr, maxExpr] = this.arg.get();
        const value = await valExpr.reduce(vm);
        bigint(value, "1st argument of GETEXPLV must be a number");
        const max = await maxExpr.reduce(vm);
        bigint(max, "2nd argument of GETEXPLV must be a number");
        let result = max;
        for(let i = 0n; i <= max; ++i){
            if (value < vm.getValue("EXPLV").get(vm, [
                Number(i)
            ])) {
                result = i - 1n;
                break;
            }
        }
        vm.getValue("RESULT").set(vm, result, [
            0
        ]);
        return null;
    }
}
const PARSER51 = arg0R0();
class GetFont extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER51, raw);
    }
    async *run(vm) {
        const result = vm.printer.font.name;
        vm.getValue("RESULTS").set(vm, result, [
            0
        ]);
        return null;
    }
}
var P9 = Object.create;
var J7 = Object.defineProperty;
var Q11 = Object.getOwnPropertyDescriptor;
var G9 = Object.getOwnPropertyNames;
var K11 = Object.getPrototypeOf, R8 = Object.prototype.hasOwnProperty;
var X12 = (d, f)=>()=>(f || d((f = {
            exports: {}
        }).exports, f), f.exports);
var tt1 = (d, f, y, g)=>{
    if (f && typeof f == "object" || typeof f == "function") for (let m of G9(f))!R8.call(d, m) && m !== y && J7(d, m, {
        get: ()=>f[m],
        enumerable: !(g = Q11(f, m)) || g.enumerable
    });
    return d;
};
var nt1 = (d, f, y)=>(y = d != null ? P9(K11(d)) : {}, tt1(f || !d || !d.__esModule ? J7(y, "default", {
        value: d,
        enumerable: !0
    }) : y, d));
var Z9 = X12((j, N)=>{
    (function(d, f) {
        typeof j == "object" && typeof N < "u" ? N.exports = f() : typeof define == "function" && define.amd ? define(f) : d.dayjs = f();
    })(j, function() {
        "use strict";
        var d = "millisecond", f = "second", y = "minute", g = "hour", m = "day", W = "week", D = "month", U = "quarter", p = "year", O = "date", V = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d+)?$/, q = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, B = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
        }, C = function(i, n, t) {
            var r = String(i);
            return !r || r.length >= n ? i : "" + Array(n + 1 - r.length).join(t) + i;
        }, E = {
            s: C,
            z: function(i) {
                var n = -i.utcOffset(), t = Math.abs(n), r = Math.floor(t / 60), e = t % 60;
                return (n <= 0 ? "+" : "-") + C(r, 2, "0") + ":" + C(e, 2, "0");
            },
            m: function i(n, t) {
                if (n.date() < t.date()) return -i(t, n);
                var r = 12 * (t.year() - n.year()) + (t.month() - n.month()), e = n.clone().add(r, D), u = t - e < 0, s = n.clone().add(r + (u ? -1 : 1), D);
                return +(-(r + (t - e) / (u ? e - s : s - e)) || 0);
            },
            a: function(i) {
                return i < 0 ? Math.ceil(i) || 0 : Math.floor(i);
            },
            p: function(i) {
                return ({
                    M: D,
                    y: p,
                    w: W,
                    d: m,
                    D: O,
                    h: g,
                    m: y,
                    s: f,
                    ms: d,
                    Q: U
                })[i] || String(i || "").toLowerCase().replace(/s$/, "");
            },
            u: function(i) {
                return i === void 0;
            }
        }, b = "en", _ = {};
        _[b] = B;
        var I = function(i) {
            return i instanceof L;
        }, x = function(i, n, t) {
            var r;
            if (!i) return b;
            if (typeof i == "string") _[i] && (r = i), n && (_[i] = n, r = i);
            else {
                var e = i.name;
                _[e] = i, r = e;
            }
            return !t && r && (b = r), r || !t && b;
        }, $ = function(i, n) {
            if (I(i)) return i.clone();
            var t = typeof n == "object" ? n : {};
            return t.date = i, t.args = arguments, new L(t);
        }, a = E;
        a.l = x, a.i = I, a.w = function(i, n) {
            return $(i, {
                locale: n.$L,
                utc: n.$u,
                x: n.$x,
                $offset: n.$offset
            });
        };
        var L = function() {
            function i(t) {
                this.$L = x(t.locale, null, !0), this.parse(t);
            }
            var n = i.prototype;
            return n.parse = function(t) {
                this.$d = function(r) {
                    var e = r.date, u = r.utc;
                    if (e === null) return new Date(NaN);
                    if (a.u(e)) return new Date;
                    if (e instanceof Date) return new Date(e);
                    if (typeof e == "string" && !/Z$/i.test(e)) {
                        var s = e.match(V);
                        if (s) {
                            var o = s[2] - 1 || 0, c = (s[7] || "0").substring(0, 3);
                            return u ? new Date(Date.UTC(s[1], o, s[3] || 1, s[4] || 0, s[5] || 0, s[6] || 0, c)) : new Date(s[1], o, s[3] || 1, s[4] || 0, s[5] || 0, s[6] || 0, c);
                        }
                    }
                    return new Date(e);
                }(t), this.$x = t.x || {}, this.init();
            }, n.init = function() {
                var t = this.$d;
                this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
            }, n.$utils = function() {
                return a;
            }, n.isValid = function() {
                return this.$d.toString() !== "Invalid Date";
            }, n.isSame = function(t, r) {
                var e = $(t);
                return this.startOf(r) <= e && e <= this.endOf(r);
            }, n.isAfter = function(t, r) {
                return $(t) < this.startOf(r);
            }, n.isBefore = function(t, r) {
                return this.endOf(r) < $(t);
            }, n.$g = function(t, r, e) {
                return a.u(t) ? this[r] : this.set(e, t);
            }, n.unix = function() {
                return Math.floor(this.valueOf() / 1e3);
            }, n.valueOf = function() {
                return this.$d.getTime();
            }, n.startOf = function(t, r) {
                var e = this, u = !!a.u(r) || r, s = a.p(t), o = function(Y, M) {
                    var w = a.w(e.$u ? Date.UTC(e.$y, M, Y) : new Date(e.$y, M, Y), e);
                    return u ? w : w.endOf(m);
                }, c = function(Y, M) {
                    return a.w(e.toDate()[Y].apply(e.toDate("s"), (u ? [
                        0,
                        0,
                        0,
                        0
                    ] : [
                        23,
                        59,
                        59,
                        999
                    ]).slice(M)), e);
                }, h = this.$W, l = this.$M, S = this.$D, v = "set" + (this.$u ? "UTC" : "");
                switch(s){
                    case p:
                        return u ? o(1, 0) : o(31, 11);
                    case D:
                        return u ? o(1, l) : o(0, l + 1);
                    case W:
                        var H = this.$locale().weekStart || 0, T = (h < H ? h + 7 : h) - H;
                        return o(u ? S - T : S + (6 - T), l);
                    case m:
                    case O:
                        return c(v + "Hours", 0);
                    case g:
                        return c(v + "Minutes", 1);
                    case y:
                        return c(v + "Seconds", 2);
                    case f:
                        return c(v + "Milliseconds", 3);
                    default:
                        return this.clone();
                }
            }, n.endOf = function(t) {
                return this.startOf(t, !1);
            }, n.$set = function(t, r) {
                var e, u = a.p(t), s = "set" + (this.$u ? "UTC" : ""), o = (e = {}, e[m] = s + "Date", e[O] = s + "Date", e[D] = s + "Month", e[p] = s + "FullYear", e[g] = s + "Hours", e[y] = s + "Minutes", e[f] = s + "Seconds", e[d] = s + "Milliseconds", e)[u], c = u === m ? this.$D + (r - this.$W) : r;
                if (u === D || u === p) {
                    var h = this.clone().set(O, 1);
                    h.$d[o](c), h.init(), this.$d = h.set(O, Math.min(this.$D, h.daysInMonth())).$d;
                } else o && this.$d[o](c);
                return this.init(), this;
            }, n.set = function(t, r) {
                return this.clone().$set(t, r);
            }, n.get = function(t) {
                return this[a.p(t)]();
            }, n.add = function(t, r) {
                var e, u = this;
                t = Number(t);
                var s = a.p(r), o = function(l) {
                    var S = $(u);
                    return a.w(S.date(S.date() + Math.round(l * t)), u);
                };
                if (s === D) return this.set(D, this.$M + t);
                if (s === p) return this.set(p, this.$y + t);
                if (s === m) return o(1);
                if (s === W) return o(7);
                var c = (e = {}, e[y] = 6e4, e[g] = 36e5, e[f] = 1e3, e)[s] || 1, h = this.$d.getTime() + t * c;
                return a.w(h, this);
            }, n.subtract = function(t, r) {
                return this.add(-1 * t, r);
            }, n.format = function(t) {
                var r = this;
                if (!this.isValid()) return "Invalid Date";
                var e = t || "YYYY-MM-DDTHH:mm:ssZ", u = a.z(this), s = this.$locale(), o = this.$H, c = this.$m, h = this.$M, l = s.weekdays, S = s.months, v = function(M, w, k, A) {
                    return M && (M[w] || M(r, e)) || k[w].substr(0, A);
                }, H = function(M) {
                    return a.s(o % 12 || 12, M, "0");
                }, T = s.meridiem || function(M, w, k) {
                    var A = M < 12 ? "AM" : "PM";
                    return k ? A.toLowerCase() : A;
                }, Y = {
                    YY: String(this.$y).slice(-2),
                    YYYY: this.$y,
                    M: h + 1,
                    MM: a.s(h + 1, 2, "0"),
                    MMM: v(s.monthsShort, h, S, 3),
                    MMMM: v(S, h),
                    D: this.$D,
                    DD: a.s(this.$D, 2, "0"),
                    d: String(this.$W),
                    dd: v(s.weekdaysMin, this.$W, l, 2),
                    ddd: v(s.weekdaysShort, this.$W, l, 3),
                    dddd: l[this.$W],
                    H: String(o),
                    HH: a.s(o, 2, "0"),
                    h: H(1),
                    hh: H(2),
                    a: T(o, c, !0),
                    A: T(o, c, !1),
                    m: String(c),
                    mm: a.s(c, 2, "0"),
                    s: String(this.$s),
                    ss: a.s(this.$s, 2, "0"),
                    SSS: a.s(this.$ms, 3, "0"),
                    Z: u
                };
                return e.replace(q, function(M, w) {
                    return w || Y[M] || u.replace(":", "");
                });
            }, n.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, n.diff = function(t, r, e) {
                var u, s = a.p(r), o = $(t), c = 6e4 * (o.utcOffset() - this.utcOffset()), h = this - o, l = a.m(this, o);
                return l = (u = {}, u[p] = l / 12, u[D] = l, u[U] = l / 3, u[W] = (h - c) / 6048e5, u[m] = (h - c) / 864e5, u[g] = h / 36e5, u[y] = h / 6e4, u[f] = h / 1e3, u)[s] || h, e ? l : a.a(l);
            }, n.daysInMonth = function() {
                return this.endOf(D).$D;
            }, n.$locale = function() {
                return _[this.$L];
            }, n.locale = function(t, r) {
                if (!t) return this.$L;
                var e = this.clone(), u = x(t, r, !0);
                return u && (e.$L = u), e;
            }, n.clone = function() {
                return a.w(this.$d, this);
            }, n.toDate = function() {
                return new Date(this.valueOf());
            }, n.toJSON = function() {
                return this.isValid() ? this.toISOString() : null;
            }, n.toISOString = function() {
                return this.$d.toISOString();
            }, n.toString = function() {
                return this.$d.toUTCString();
            }, i;
        }(), F = L.prototype;
        return $.prototype = F, [
            [
                "$ms",
                d
            ],
            [
                "$s",
                f
            ],
            [
                "$m",
                y
            ],
            [
                "$H",
                g
            ],
            [
                "$W",
                m
            ],
            [
                "$M",
                D
            ],
            [
                "$y",
                p
            ],
            [
                "$D",
                O
            ]
        ].forEach(function(i) {
            F[i[1]] = function(n) {
                return this.$g(n, i[0], i[1]);
            };
        }), $.extend = function(i, n) {
            return i.$i || (i(n, L, $), i.$i = !0), $;
        }, $.locale = x, $.isDayjs = I, $.unix = function(i) {
            return $(1e3 * i);
        }, $.en = _[b], $.Ls = _, $.p = {}, $;
    });
});
var et1 = nt1(Z9()), { default: z9 , ...it1 } = et1, st1 = z9 !== void 0 ? z9 : it1;
const UNIX_EPOCH = 719162 * 24 * 60 * 60;
const PARSER52 = arg0R0();
class GetMillisecond extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER52, raw);
    }
    async *run(vm) {
        const time = st1(vm.external.getTime());
        vm.getValue("RESULT").set(vm, BigInt(time.valueOf() - UNIX_EPOCH * 1000), [
            0
        ]);
        return null;
    }
}
const PARSER53 = arg2R2(expr, expr);
class GetPalamLv extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER53);
    }
    async *run(vm) {
        const [valExpr, maxExpr] = this.arg.get();
        const value = await valExpr.reduce(vm);
        bigint(value, "1st argument of GETPALAMLV must be a number");
        const max = await maxExpr.reduce(vm);
        bigint(max, "2nd argument of GETPALAMLV must be a number");
        let result = max;
        for(let i = 0n; i <= max; ++i){
            if (value < vm.getValue("PALAMLV").get(vm, [
                Number(i)
            ])) {
                result = i - 1n;
                break;
            }
        }
        vm.getValue("RESULT").set(vm, result, [
            0
        ]);
        return null;
    }
}
const UNIX_EPOCH1 = 719162 * 24 * 60 * 60;
const PARSER54 = arg0R0();
class GetSecond extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER54, raw);
    }
    async *run(vm) {
        const time = st1(vm.external.getTime());
        vm.getValue("RESULT").set(vm, BigInt(time.unix() - UNIX_EPOCH1), [
            0
        ]);
        return null;
    }
}
const PARSER55 = arg0R0();
class GetStyle extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER55, raw);
    }
    async *run() {
        throw notImpl("GETSTYLE");
        return null;
    }
}
const PARSER56 = arg0R0();
class GetTime extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER56, raw);
    }
    async *run(vm) {
        const time = st1(vm.external.getTime());
        vm.getValue("RESULT").set(vm, BigInt(parseInt(time.format("YYYYMMDDHHmmssSSS"))), [
            0
        ]);
        vm.getValue("RESULTS").set(vm, time.format("YYYYMMDD HH:mm:ss"), [
            0
        ]);
        return null;
    }
}
const PARSER57 = arg1R1(form[""]);
class GotoForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER57);
    }
    async *run(vm) {
        const arg = await this.arg.get().reduce(vm);
        const target = arg.toUpperCase();
        const context = vm.context();
        if (!context.fn.thunk.labelMap.has(target)) {
            throw notFound("Label", target);
        }
        return {
            type: "goto",
            label: target
        };
    }
}
const PARSER58 = arg1R0(Int);
class Input extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER58);
    }
    async *run(vm) {
        const arg = this.arg.get();
        const input = yield* vm.printer.input(true, arg != null);
        cond(input != null, "Input value for INPUT should be a valid number");
        let value = Number(input);
        if (arg != null && input === "") {
            value = arg;
        }
        number(value, "Input value for INPUT should be a valid number");
        yield* vm.printer.print(value.toString(), new Set([
            "S"
        ]));
        vm.getValue("RESULT").set(vm, BigInt(value), [
            0
        ]);
        return null;
    }
}
const PARSER59 = arg1R0(charSeq());
class InputS extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER59);
    }
    async *run(vm) {
        const arg = this.arg.get();
        let input = yield* vm.printer.input(false, arg != null);
        string(input, "Input value for INPUTS should be a valid string");
        if (arg != null && input === "") {
            input = arg;
        }
        yield* vm.printer.print(input, new Set([
            "S"
        ]));
        vm.getValue("RESULTS").set(vm, input, [
            0
        ]);
        return null;
    }
}
const PARSER60 = arg0R0();
class InitRand extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER60, raw);
    }
    async *run(vm) {
        vm.random.state = Number(vm.getValue("RANDDATA").get(vm, []));
        return null;
    }
}
const PARSER61 = argNR1(variable, expr);
class InvertBit extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER61);
    }
    async *run(vm) {
        const [destExpr, ...bitExpr] = this.arg.get();
        const value = await destExpr.reduce(vm);
        bigint(value, "1st argument of INVERTBIT must be a number");
        const bitList = [];
        for(let i = 0; i < bitExpr.length; ++i){
            const bit = await bitExpr[i].reduce(vm);
            bigint(bit, `${i + 2}th argument of INVERTBIT must be a number`);
            bitList.push(bit);
        }
        let result = value;
        for (const bit1 of bitList){
            result ^= 1n << bit1;
        }
        destExpr.getCell(vm).set(vm, result, await destExpr.reduceIndex(vm));
        return null;
    }
}
const PARSER62 = arg0R0();
class IsActive extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER62, raw);
    }
    async *run() {
        throw notImpl("ISACTIVE");
        return null;
    }
}
const PARSER63 = arg0R0();
class IsSkip extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER63, raw);
    }
    async *run() {
        throw notImpl("ISSKIP");
        return null;
    }
}
class JumpForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER("("));
    }
    async *run(vm) {
        const [targetExpr, argExpr] = this.arg.get();
        const target = await targetExpr.reduce(vm);
        return yield* Jump.exec(vm, target, argExpr);
    }
}
class Int2DValue {
    type = "number";
    name;
    value;
    static normalizeIndex(name, index) {
        if (index.length === 0) {
            return [
                0,
                0
            ];
        } else if (index.length === 1) {
            return [
                index[0],
                0
            ];
        } else if (index.length === 2) {
            return index;
        } else if (index.length === 3 && index[2] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("2D", name, index);
        }
    }
    constructor(name, size){
        const realSize = size ?? [
            100,
            100
        ];
        cond(realSize.length === 2, `${name} is not a ${realSize.length}D variable`);
        this.name = name;
        this.value = new Array(realSize[0]).fill(0).map(()=>new Array(realSize[1]).fill(0n));
    }
    reset(value) {
        for(let i = 0; i < this.value.length; ++i){
            for(let j = 0; j < this.value[i].length; ++j){
                this.value[i][j] = 0n;
            }
        }
        for(let i1 = 0; i1 < value.length; ++i1){
            for(let j1 = 0; j1 < value[i1].length; ++j1){
                this.value[i1][j1] = BigInt(value[i1][j1]);
            }
        }
        return this;
    }
    get(_vm, index) {
        const realIndex = Int2DValue.normalizeIndex(this.name, index);
        return this.value[realIndex[0]][realIndex[1]];
    }
    set(_vm, value, index) {
        const realIndex = Int2DValue.normalizeIndex(this.name, index);
        bigint(value, "Cannot assign a string to a numeric variable");
        this.value[realIndex[0]][realIndex[1]] = value;
    }
    rangeSet(_vm, value, _index, _range) {
        bigint(value, "Cannot assign a string to a numeric variable");
        for(let i = 0; i < this.value.length; ++i){
            for(let j = 0; j < this.value[i].length; ++j){
                this.value[i][j] = value;
            }
        }
    }
    length(depth) {
        switch(depth){
            case 0:
                return this.value.length;
            case 1:
                return this.value[0].length;
            case 2:
                return 1;
            default:
                throw new Error(`2D variable doesn't have a value at depth ${depth}`);
        }
    }
}
class Int3DValue {
    type = "number";
    name;
    value;
    static normalizeIndex(name, index) {
        if (index.length === 0) {
            return [
                0,
                0,
                0
            ];
        } else if (index.length === 1) {
            return [
                index[0],
                0,
                0
            ];
        } else if (index.length === 2) {
            return [
                index[0],
                index[1],
                0
            ];
        } else if (index.length === 3) {
            return index;
        } else if (index.length === 4 && index[3] === 0) {
            return index.slice(0, -1);
        } else {
            throw invalidIndex("3D", name, index);
        }
    }
    constructor(name, size){
        const realSize = size ?? [
            100,
            100,
            100
        ];
        cond(realSize.length === 3, `${name} is not a ${realSize.length}D variable`);
        this.name = name;
        this.value = new Array(realSize[0]).fill(0).map(()=>new Array(realSize[1]).fill(0).map(()=>new Array(realSize[2]).fill(0n)));
    }
    reset(value) {
        for(let i = 0; i < this.value.length; ++i){
            for(let j = 0; j < this.value[i].length; ++j){
                for(let k = 0; k < this.value[i][j].length; ++k){
                    this.value[i][j][k] = 0n;
                }
            }
        }
        for(let i1 = 0; i1 < value.length; ++i1){
            for(let j1 = 0; j1 < value[i1].length; ++j1){
                for(let k1 = 0; k1 < value[i1][j1].length; ++k1){
                    this.value[i1][j1][k1] = BigInt(value[i1][j1][k1]);
                }
            }
        }
        return this;
    }
    get(_vm, index) {
        const realIndex = Int3DValue.normalizeIndex(this.name, index);
        return this.value[realIndex[0]][realIndex[1]][realIndex[2]];
    }
    set(_vm, value, index) {
        const realIndex = Int3DValue.normalizeIndex(this.name, index);
        bigint(value, "Cannot assign a string to a numeric variable");
        this.value[realIndex[0]][realIndex[1]][realIndex[2]] = BigInt(value);
    }
    rangeSet(_vm, value, _index, _range) {
        bigint(value, "Cannot assign a string to a numeric variable");
        for(let i = 0; i < this.value.length; ++i){
            for(let j = 0; j < this.value[i].length; ++j){
                for(let k = 0; k < this.value[i][j].length; ++k){
                    this.value[i][j][k] = value;
                }
            }
        }
    }
    length(depth) {
        switch(depth){
            case 0:
                return this.value.length;
            case 1:
                return this.value[0].length;
            case 2:
                return this.value[0][0].length;
            case 3:
                return 1;
            default:
                throw new Error(`3D variable doesn't have a value at depth ${depth}`);
        }
    }
}
const PARSER64 = arg1R1(expr);
class LoadData extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER64);
    }
    async *run(vm) {
        const index = await this.arg.get().reduce(vm);
        bigint(index, "Argument of LOADDATA must be a number");
        const file = savefile.game(Number(index));
        const raw = await vm.external.getSavedata(file);
        nonNull(raw, `Save file ${file} does not exist`);
        try {
            const parsed = JSON.parse(raw);
            string(parsed.data.comment, "");
            array(parsed.data.characters, "");
            const newCharacters = [];
            for (const character of parsed.data.characters){
                const newCharacter = new Character(vm, {
                    no: 0,
                    name: "",
                    callname: "",
                    nickname: "",
                    mastername: "",
                    base: new Map(),
                    maxBase: new Map(),
                    mark: new Map(),
                    exp: new Map(),
                    abl: new Map(),
                    talent: new Map(),
                    relation: new Map(),
                    cflag: new Map(),
                    equip: new Map(),
                    juel: new Map(),
                    cstr: new Map()
                });
                for (const [name, value] of Object.entries(character)){
                    const cell = newCharacter.getValue(name);
                    if (cell instanceof Int0DValue) {
                        string(value, "");
                        cell.reset(BigInt(value));
                    } else if (cell instanceof Int1DValue) {
                        strArray(value, "");
                        cell.reset(value.map((v)=>BigInt(v)));
                    } else if (cell instanceof Str0DValue) {
                        string(value, "");
                        cell.reset(value);
                    } else if (cell instanceof Str1DValue) {
                        strArray(value, "");
                        cell.reset(value);
                    }
                }
                newCharacters.push(newCharacter);
            }
            vm.characterList = newCharacters;
            for (const [name1, value1] of Object.entries(parsed.data.variables)){
                const cell1 = vm.getValue(name1);
                if (cell1 instanceof Int0DValue) {
                    string(value1, "");
                    cell1.reset(BigInt(value1));
                } else if (cell1 instanceof Int1DValue) {
                    strArray(value1, "");
                    cell1.reset(value1.map((v)=>BigInt(v)));
                } else if (cell1 instanceof Int2DValue) {
                    strArray2D(value1, "");
                    cell1.reset(value1.map((v0)=>v0.map((v1)=>BigInt(v1))));
                } else if (cell1 instanceof Int3DValue) {
                    strArray3D(value1, "");
                    cell1.reset(value1.map((v0)=>v0.map((v1)=>v1.map((v2)=>BigInt(v2)))));
                } else if (cell1 instanceof Str0DValue) {
                    string(value1, "");
                    cell1.reset(value1);
                } else if (cell1 instanceof Str1DValue) {
                    strArray(value1, "");
                    cell1.reset(value1);
                } else {
                    throw new Error("");
                }
            }
            vm.getValue("LASTLOAD_VERSION").set(vm, BigInt(parsed.version), []);
            vm.getValue("LASTLOAD_TEXT").set(vm, parsed.data.comment, []);
        } catch  {
            throw new Error(`Save file ${file} is not in a valid format`);
        }
        return {
            type: "begin",
            keyword: "DATALOADED"
        };
    }
}
const PARSER65 = arg0R0();
class LoadGame extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER65, raw);
    }
    async *run() {
        return {
            type: "begin",
            keyword: "LOADGAME"
        };
    }
}
const PARSER66 = arg0R0();
class LoadGlobal extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER66, raw);
    }
    async *run(vm) {
        const file = savefile.global;
        const raw = await vm.external.getSavedata(file);
        try {
            nonNull(raw, "");
            const parsed = JSON.parse(raw);
            const code = vm.code.csv.gamebase.code ?? 0;
            const version = vm.code.csv.gamebase.version ?? 0;
            cond(parsed.code === code, "");
            cond(parsed.version === version, "");
            for (const [name, value] of Object.entries(parsed.data)){
                const cell = vm.getValue(name);
                if (cell instanceof Int0DValue) {
                    string(value, "");
                    cell.reset(BigInt(value));
                } else if (cell instanceof Int1DValue) {
                    strArray(value, "");
                    cell.reset(value.map((v)=>BigInt(v)));
                } else if (cell instanceof Int2DValue) {
                    strArray2D(value, "");
                    cell.reset(value.map((v0)=>v0.map((v1)=>BigInt(v1))));
                } else if (cell instanceof Int3DValue) {
                    strArray3D(value, "");
                    cell.reset(value.map((v0)=>v0.map((v1)=>v1.map((v2)=>BigInt(v2)))));
                } else if (cell instanceof Str0DValue) {
                    string(value, "");
                    cell.reset(value);
                } else if (cell instanceof Str1DValue) {
                    strArray(value, "");
                    cell.reset(value);
                } else {
                    throw new Error("");
                }
            }
            vm.getValue("RESULT").set(vm, 1n, [
                0
            ]);
        } catch  {
            vm.getValue("RESULT").set(vm, 0n, [
                0
            ]);
        }
        return null;
    }
}
const PARSER67 = argNR0(expr);
class Method extends Statement {
    name;
    arg;
    constructor(name, raw){
        super(raw);
        this.name = name;
        this.arg = new Lazy(raw, PARSER67);
    }
    async *run(vm) {
        const arg = this.arg.get();
        let result;
        switch(this.name){
            case "ABS":
                result = await abs(vm, arg);
                break;
            case "BARSTR":
                result = await barStr(vm, arg);
                break;
            case "CSVABL":
                result = BigInt(await csvAbl(vm, arg));
                break;
            case "CSVBASE":
                result = BigInt(await csvBase(vm, arg));
                break;
            case "CSVCALLNAME":
                result = await csvCallname(vm, arg);
                break;
            case "CSVCFLAG":
                result = BigInt(await csvCflag(vm, arg));
                break;
            case "CSVCSTR":
                result = await csvCstr(vm, arg);
                break;
            case "CSVEQUIP":
                result = BigInt(await csvEquip(vm, arg));
                break;
            case "CSVEXP":
                result = BigInt(await csvExp(vm, arg));
                break;
            case "CSVJUEL":
                result = BigInt(await csvJuel(vm, arg));
                break;
            case "CSVMARK":
                result = BigInt(await csvMark(vm, arg));
                break;
            case "CSVMASTERNAME":
                result = await csvMastername(vm, arg);
                break;
            case "CSVNAME":
                result = await csvName(vm, arg);
                break;
            case "CSVNICKNAME":
                result = await csvNickname(vm, arg);
                break;
            case "CSVRELATION":
                result = BigInt(await csvRelation(vm, arg));
                break;
            case "CSVTALENT":
                result = BigInt(await csvTalent(vm, arg));
                break;
            case "EXISTCSV":
                result = BigInt(await existCsv(vm, arg));
                break;
            case "FINDCHARA":
                result = await findChara(vm, arg);
                break;
            case "FINDLASTCHARA":
                result = await findLastChara(vm, arg);
                break;
            case "GETBGCOLOR":
                result = BigInt(getBgColor(vm, arg));
                break;
            case "GETBIT":
                result = BigInt(await getBit(vm, arg));
                break;
            case "GETCHARA":
                result = BigInt(await getChara(vm, arg));
                break;
            case "GETCOLOR":
                result = BigInt(getColor(vm, arg));
                break;
            case "GETDEFBGCOLOR":
                result = BigInt(getDefBgColor(vm, arg));
                break;
            case "GETDEFCOLOR":
                result = BigInt(getDefColor(vm, arg));
                break;
            case "GETFOCUSCOLOR":
                result = BigInt(getFocusColor(vm, arg));
                break;
            case "GROUPMATCH":
                result = BigInt(await groupMatch(vm, arg));
                break;
            case "INRANGE":
                result = BigInt(await inRange(vm, arg));
                break;
            case "LIMIT":
                result = await limit(vm, arg);
                break;
            case "LINEISEMPTY":
                result = BigInt(lineIsEmpty(vm, arg));
                break;
            case "MATCH":
                result = BigInt(await match(vm, arg));
                break;
            case "MAX":
                result = await max(vm, arg);
                break;
            case "MAXARRAY":
                result = await maxArray(vm, arg);
                break;
            case "MIN":
                result = await min(vm, arg);
                break;
            case "MINARRAY":
                result = await minArray(vm, arg);
                break;
            case "POWER":
                result = await power(vm, arg);
                break;
            case "RAND":
                result = await rand(vm, arg);
                break;
            case "SIGN":
                result = BigInt(await sign(vm, arg));
                break;
            case "SQRT":
                result = await sqrt(vm, arg);
                break;
            case "STRLENS":
                result = BigInt(await strLenS(vm, arg));
                break;
            case "STRLENSU":
                result = BigInt(await strLenSU(vm, arg));
                break;
            case "SUMARRAY":
                result = await sumArray(vm, arg);
                break;
            case "TOINT":
                result = BigInt(await toInt(vm, arg));
                break;
            case "TOSTR":
                result = await toStr(vm, arg);
                break;
            case "VARSIZE":
                result = BigInt(await varSize(vm, arg));
                break;
            case "UNICODE":
                result = await unicode(vm, arg);
                break;
            default:
                throw internal(`${this.name} is not a valid method command`);
        }
        if (typeof result === "bigint") {
            vm.getValue("RESULT").set(vm, result, [
                0
            ]);
        } else {
            vm.getValue("RESULTS").set(vm, result, [
                0
            ]);
        }
        return null;
    }
}
const PARSER68 = arg0R0();
class MouseSkip extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER68, raw);
    }
    async *run() {
        throw notImpl("MOUSESKIP");
        return null;
    }
}
const PARSER69 = arg0R0();
class MouseX extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER69, raw);
    }
    async *run() {
        throw notImpl("MOUSEX");
        return null;
    }
}
const PARSER70 = arg0R0();
class MouseY extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER70, raw);
    }
    async *run() {
        throw notImpl("mousey");
        return null;
    }
}
const PARSER71 = arg1R0(Int);
class OneInput extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER71);
    }
    async *run(vm) {
        const arg = this.arg.get();
        const input = yield* vm.printer.input(true, arg != null);
        cond(input != null, "First value of input for ONEINPUT should be a valid number");
        let value = Number(input[0]);
        if (arg != null && input === "") {
            value = arg;
        }
        number(value, "First value of input for ONEINPUT should be a valid number");
        yield* vm.printer.print(value.toString(), new Set([
            "S"
        ]));
        vm.getValue("RESULT").set(vm, BigInt(value), [
            0
        ]);
        return null;
    }
}
const PARSER72 = arg1R0(charSeq());
class OneInputS extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER72);
    }
    async *run(vm) {
        const arg = this.arg.get();
        let input = yield* vm.printer.input(false, arg != null);
        string(input, "Input value for ONEINPUTS should be a valid string");
        if (arg != null && input === "") {
            input = arg;
        }
        yield* vm.printer.print(input, new Set([
            "S"
        ]));
        vm.getValue("RESULTS").set(vm, input[0], [
            0
        ]);
        return null;
    }
}
const PARSER73 = arg0R0();
class OutputLog extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER73, raw);
    }
    async *run() {
        throw notImpl("OUTPUTLOG");
        return null;
    }
}
const PARSER74 = argNR1(expr, expr);
class PickupChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER74);
    }
    async *run(vm) {
        const argExpr = this.arg.get();
        const arg = [];
        for(let i = 0; i < argExpr.length; ++i){
            const value = await argExpr[i].reduce(vm);
            bigint(value, `${i + 1}th argument of PICKUPCHARA should be a number`);
            cond(value >= 0 && value < vm.characterList.length, `${i + 1}th argument of PICKUPCHARA is out of range`);
            arg.push(value);
        }
        let target = -1n;
        let assi = -1n;
        let master = -1n;
        const characterList = [];
        for(let i1 = 0n; i1 < arg.length; ++i1){
            const index = arg[Number(i1)];
            if (index === vm.getValue("TARGET").get(vm, [])) {
                target = i1;
            }
            if (index === vm.getValue("ASSI").get(vm, [])) {
                assi = i1;
            }
            if (index === vm.getValue("MASTER").get(vm, [])) {
                master = i1;
            }
            characterList.push(vm.characterList[Number(i1)]);
        }
        vm.getValue("TARGET").set(vm, target, []);
        vm.getValue("ASSI").set(vm, assi, []);
        vm.getValue("MASTER").set(vm, master, []);
        vm.characterList = characterList;
        return null;
    }
}
const PARSER75 = arg1R0(charSeq()).map((str)=>str ?? "");
class Print extends Statement {
    flags;
    value;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.value = new Lazy(raw, PARSER75);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        yield* vm.printer.print(this.value.get(), this.flags);
        return null;
    }
}
const PARSER76 = arg2R2(expr, expr);
class PrintButton extends Statement {
    align;
    arg;
    constructor(raw, align){
        super(raw);
        this.align = align;
        this.arg = new Lazy(raw, PARSER76);
    }
    async *run(vm) {
        const [textExpr, valueExpr] = this.arg.get();
        const text = await textExpr.reduce(vm);
        string(text, "1st argument of PRINTBUTTON must be a string");
        const value = await valueExpr.reduce(vm);
        yield* vm.printer.button(text, typeof value === "string" ? value : value.toString(), this.align);
        return null;
    }
}
const PARSER77 = arg1R0(charSeq()).map((str)=>str ?? "");
class PrintC extends Statement {
    align;
    flags;
    value;
    constructor(align, flags, raw){
        super(raw);
        this.align = align;
        this.flags = new Set(flags);
        this.value = new Lazy(raw, PARSER77);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const value = this.value.get();
        yield* vm.printer.print(value, this.flags, this.align);
        return null;
    }
}
const PARSER78 = arg0R0();
class PrintCPerLine extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER78, raw);
    }
    async *run(vm) {
        vm.getValue("RESULT").set(vm, BigInt(vm.printCPerLine), [
            0
        ]);
        return null;
    }
}
const DATA = /^DATA(\s+|$)/i;
const DATAFORM = /^DATAFORM\s+/i;
const DATAFORM_EMPTY = /^DATAFORM$/i;
const DATALIST = /^DATALIST$/i;
const ENDLIST = /^ENDLIST$/i;
const ENDDATA = /^ENDDATA$/i;
const PARSER_CONST = arg1R0(charSeq()).map((value)=>new Const(value ?? ""));
const PARSER_FORM = arg1R1(form[""]);
class PrintData extends Statement {
    static parse(flags, lines, from) {
        let index = from + 1;
        const data = [];
        while(true){
            if (lines.length <= index) {
                throw parser("Unexpected end of thunk in PRINTDATA expression");
            }
            const current = lines[index];
            index += 1;
            if (DATA.test(current.content)) {
                data.push(new Lazy(current.slice("DATA".length), PARSER_CONST));
            } else if (DATAFORM.test(current.content)) {
                data.push(new Lazy(current.slice("DATAFORM".length), PARSER_FORM));
            } else if (DATAFORM_EMPTY.test(current.content)) {
                data.push(new Lazy(current.slice("DATAFORM".length), PARSER_CONST));
            } else if (DATALIST.test(current.content) || ENDLIST.test(current.content)) {} else if (ENDDATA.test(current.content)) {
                return [
                    new PrintData(lines[from], flags, data),
                    index - from
                ];
            } else {
                throw parser("Unexpected statement in PRINTDATA expression");
            }
        }
    }
    flags;
    data;
    constructor(raw, flags, data){
        super(raw);
        this.flags = new Set(flags);
        this.data = data;
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const index = vm.random.next() % this.data.length;
        const value = await this.data[index].get().reduce(vm);
        string(value, "Item of PRINTDATA must be a string");
        yield* vm.printer.print(value, this.flags);
        return null;
    }
}
const PARSER79 = arg1R0(form[""]).map((form)=>form ?? new Form([
        {
            value: ""
        }
    ]));
class PrintForm extends Statement {
    flags;
    arg;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.arg = new Lazy(raw, PARSER79);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const value = await this.arg.get().reduce(vm);
        yield* vm.printer.print(value, this.flags);
        return null;
    }
}
const PARSER80 = arg1R0(form[""]).map((form)=>form ?? new Form([
        {
            value: ""
        }
    ]));
class PrintFormC extends Statement {
    align;
    flags;
    arg;
    constructor(align, flags, raw){
        super(raw);
        this.align = align;
        this.flags = new Set(flags);
        this.arg = new Lazy(raw, PARSER80);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const value = await this.arg.get().reduce(vm);
        yield* vm.printer.print(value, this.flags, this.align);
        return null;
    }
}
const PARSER81 = arg1R1(expr);
class PrintFormS extends Statement {
    flags;
    arg;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.arg = new Lazy(raw, PARSER81);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const form1 = await this.arg.get().reduce(vm);
        string(form1, "1st argument of PRINTFORMS must be a string");
        const text = await form[""].tryParse(form1).reduce(vm);
        string(text, "1st argument of PRINTFORMS must be reduced to a string");
        yield* vm.printer.print(text, this.flags);
        return null;
    }
}
const PARSER82 = arg1R1(expr);
class PrintPalam extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER82);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const index = await this.arg.get().reduce(vm);
        bigint(index, "1st argument of PRINT_PALAM must be a number");
        const palamName = vm.getValue("PALAMNAME");
        const validName = [];
        for(let i = 0; i < palamName.length(0); ++i){
            const name = palamName.get(vm, [
                i
            ]);
            if (name !== "") {
                validName.push(name);
            }
        }
        for(let i1 = 0; i1 < validName.length; ++i1){
            const name1 = validName[i1];
            const value = vm.getValue("PALAM").get(vm, [
                Number(index),
                i1
            ]);
            const palamLv = [
                vm.getValue("PALAMLV").get(vm, [
                    0
                ]),
                vm.getValue("PALAMLV").get(vm, [
                    1
                ]),
                vm.getValue("PALAMLV").get(vm, [
                    2
                ]),
                vm.getValue("PALAMLV").get(vm, [
                    3
                ]),
                vm.getValue("PALAMLV").get(vm, [
                    4
                ])
            ];
            let text = name1;
            if (value >= palamLv[4]) {
                text += "[" + "*".repeat(10) + "]";
            } else if (value >= palamLv[3]) {
                const filled = Number(10n * value / palamLv[4]);
                text += "[" + "*".repeat(filled) + ".".repeat(10 - filled) + "]";
            } else if (value >= palamLv[2]) {
                const filled1 = Number(10n * value / palamLv[3]);
                text += "[" + ">".repeat(filled1) + ".".repeat(10 - filled1) + "]";
            } else if (value >= palamLv[1]) {
                const filled2 = Number(10n * value / palamLv[2]);
                text += "[" + "=".repeat(filled2) + ".".repeat(10 - filled2) + "]";
            } else {
                const filled3 = Number(10n * value / palamLv[1]);
                text += "[" + "-".repeat(filled3) + ".".repeat(10 - filled3) + "]";
            }
            text += value.toString();
            yield* vm.printer.print(text, new Set(), "LEFT");
            if ((i1 + 1) % vm.printCPerLine === 0) {
                yield* vm.printer.newline();
            }
        }
        yield* vm.printer.newline();
        return null;
    }
}
const PARSER_CONST1 = arg1R0(charSeq()).map((str)=>new Const(str ?? ""));
const PARSER_FORM1 = arg1R0(form[""]).map((form)=>form ?? new Const(""));
class PrintPlain extends Statement {
    arg;
    constructor(postfix, raw){
        super(raw);
        switch(postfix){
            case null:
                {
                    this.arg = new Lazy(raw, PARSER_CONST1);
                    break;
                }
            case "FORM":
                {
                    this.arg = new Lazy(raw, PARSER_FORM1);
                }
        }
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const text = await this.arg.get().reduce(vm);
        string(text, "1st argument of PRINTPLAIN must be a string");
        yield* vm.printer.print(text, new Set());
        return null;
    }
}
const PARSER83 = arg1R1(expr);
class PrintS extends Statement {
    flags;
    arg;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.arg = new Lazy(raw, PARSER83);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const value = await this.arg.get().reduce(vm);
        string(value, "1st argument of PRINTS must be a string");
        yield* vm.printer.print(value, this.flags);
        return null;
    }
}
const PARSER84 = arg0R0();
class PrintShopItem extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER84, raw);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        const itemName = vm.getValue("ITEMNAME");
        const validItem = [];
        for(let i = 0; i < itemName.length(0); ++i){
            const name = itemName.get(vm, [
                i
            ]);
            if (name !== "") {
                validItem.push(i);
            }
        }
        for(let i1 = 0; i1 < validItem.length; ++i1){
            const index = validItem[i1];
            const name1 = itemName.get(vm, [
                index
            ]);
            const price = vm.getValue("ITEMPRICE").get(vm, [
                index
            ]);
            const text = `[${index}] ${name1}(${price}$)`;
            yield* vm.printer.print(text, new Set(), "LEFT");
            if ((i1 + 1) % vm.printCPerLine === 0) {
                yield* vm.printer.newline();
            }
        }
        yield* vm.printer.newline();
        return null;
    }
}
const PARSER85 = argNR0(Hn1.alt(Hn1.string("'").then(charSeq(",").map((str)=>new Const(str))), expr));
class PrintV extends Statement {
    flags;
    value;
    constructor(flags, raw){
        super(raw);
        this.flags = new Set(flags);
        this.value = new Lazy(raw, PARSER85);
    }
    async *run(vm) {
        if (vm.printer.skipDisp) {
            return null;
        }
        let text = "";
        for (const value of this.value.get()){
            text += (await value.reduce(vm)).toString();
        }
        yield* vm.printer.print(text, this.flags);
        return null;
    }
}
const PARSER86 = arg1R1(form[""]);
class PutForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER86);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        string(value, "1st argument of PUTFORM should be a number");
        const cell = vm.getValue("SAVEDATA_TEXT");
        cell.set(vm, cell.get(vm, []) + value, []);
        return null;
    }
}
const PARSER87 = arg0R0();
class Quit extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER87, raw);
    }
    async *run() {
        return {
            type: "quit"
        };
    }
}
const PARSER88 = arg1R1(expr);
class Randomize extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER88);
    }
    async *run(vm) {
        const seed = await this.arg.get().reduce(vm);
        bigint(seed, "1st argument of RANDOMIZE must be a number");
        vm.random.state = Number(seed);
        return null;
    }
}
const PARSER89 = arg1R1(expr);
class Redraw extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER89);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        bigint(value, "Argument of REDRAW must be a number");
        cond(value > 0 && value <= 3, "Argument of REDRAW must be between 0 and 3");
        switch(value){
            case 0n:
                vm.printer.draw = false;
                break;
            case 1n:
                vm.printer.draw = true;
                break;
            case 2n:
                vm.printer.draw = false;
                yield* vm.printer.flush();
                break;
            case 3n:
                vm.printer.draw = true;
                yield* vm.printer.flush();
                break;
        }
        return null;
    }
}
const PARSER90 = arg0R0();
class ResetBgColor extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER90, raw);
    }
    async *run(vm) {
        vm.printer.background = vm.printer.defaultBackground;
        return null;
    }
}
const PARSER91 = arg0R0();
class ResetColor extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER91, raw);
    }
    async *run(vm) {
        vm.printer.color = vm.printer.defaultColor;
        return null;
    }
}
const PARSER92 = arg0R0();
class ResetData extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER92, raw);
    }
    async *run(vm) {
        await vm.reset();
        return null;
    }
}
const PARSER93 = arg0R0();
class ResetGlobal extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER93, raw);
    }
    async *run() {
        throw notImpl("RESETGLOBAL");
        return null;
    }
}
const PARSER94 = arg1R1(expr);
class ResetStain extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER94);
    }
    async *run(vm) {
        const num = await this.arg.get().reduce(vm);
        bigint(num, "1st Argument of RESET_STAIN should be an integer");
        cond(vm.characterList.length > num, `Character #${num} does not exist`);
        const character = vm.characterList[Number(num)];
        character.getValue("STAIN").reset([
            0,
            0,
            2,
            1,
            8
        ]);
        return null;
    }
}
const PARSER95 = arg0R0();
class Restart extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER95, raw);
    }
    async *run() {
        return {
            type: "goto",
            label: Fn2.START_OF_FN
        };
    }
}
const PARSER96 = argNR0(expr);
class Return extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER96);
    }
    async *run(vm) {
        const result = [];
        for (const expr of this.arg.get()){
            result.push(await expr.reduce(vm));
        }
        return {
            type: "return",
            value: result
        };
    }
}
const PARSER97 = arg1R1(expr);
class ReturnF extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER97);
    }
    async *run(vm) {
        return {
            type: "return",
            value: [
                await this.arg.get().reduce(vm)
            ]
        };
    }
}
const PARSER98 = arg1R0(form[""]);
class ReuseLastLine extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER98);
    }
    async *run(vm) {
        const value = await this.arg.get()?.reduce(vm) ?? "";
        string(value, "Argument of REUSELASTLINE must be a string");
        yield* vm.printer.print(value, new Set([
            "S"
        ]));
        vm.printer.isLineTemp = true;
        return null;
    }
}
class Dim {
    name;
    type;
    prefix;
    size;
    value;
    constructor(name, type, prefix, size, value){
        this.name = name;
        this.type = type;
        this.size = size;
        this.prefix = new Set();
        this.value = value;
        for (const p of prefix){
            this.prefix.add(p.toUpperCase());
        }
    }
    isDynamic() {
        return this.prefix.has("DYNAMIC");
    }
    isGlobal() {
        return this.prefix.has("GLOBAL");
    }
    isSave() {
        return this.prefix.has("SAVEDATA");
    }
    isChar() {
        return this.prefix.has("CHARADATA");
    }
    async build(vm) {
        if (this.value != null && this.value.length === 0 && this.type === "number") {
            const value = await this.value[0].reduce(vm);
            bigint(value, "Default value for 0D #DIM must be a number");
            return new Int0DValue(this.name).reset(value);
        } else if (this.value != null && this.value.length === 0 && this.type === "string") {
            const value1 = await this.value[0].reduce(vm);
            string(value1, "Default value for 0D #DIMS must be a string");
            return new Str0DValue(this.name).reset(value1);
        } else if (this.value != null && this.value.length === 1 && this.type === "number") {
            const value2 = await Promise.all(this.value.map((v)=>v.reduce(vm)));
            bigintArray(value2, "Default value for 1D #DIM must be a number array");
            return new Int1DValue(this.name, [
                value2.length
            ]).reset(value2);
        } else if (this.value != null && this.value.length === 1 && this.type === "string") {
            const value3 = await Promise.all(this.value.map((v)=>v.reduce(vm)));
            strArray(value3, "Default value for 1D #DIMS must be a string array");
            return new Str1DValue(this.name, [
                value3.length
            ]).reset(value3);
        } else if (this.size.length === 0 && this.type === "number" && !this.isChar()) {
            return new Int0DValue(this.name);
        } else if (this.size.length === 0 && this.type === "string" && !this.isChar()) {
            return new Str0DValue(this.name);
        } else if (this.size.length === 1 && this.type === "number" && !this.isChar()) {
            const size = await this.size[0].reduce(vm);
            bigint(size, "Size of an array must be an integer");
            return new Int1DValue(this.name, [
                Number(size)
            ]);
        } else if (this.size.length === 1 && this.type === "string" && !this.isChar()) {
            const size1 = await this.size[0].reduce(vm);
            bigint(size1, "Size of an array must be an integer");
            return new Str1DValue(this.name, [
                Number(size1)
            ]);
        } else if (this.size.length === 2 && this.type === "number" && !this.isChar()) {
            const size0 = await this.size[0].reduce(vm);
            bigint(size0, "Size of an array must be an integer");
            const size11 = await this.size[1].reduce(vm);
            bigint(size11, "Size of an array must be an integer");
            return new Int2DValue(this.name, [
                Number(size0),
                Number(size11)
            ]);
        } else if (this.size.length === 3 && this.type === "number" && !this.isChar()) {
            const size01 = await this.size[0].reduce(vm);
            bigint(size01, "Size of an array must be an integer");
            const size12 = await this.size[1].reduce(vm);
            bigint(size12, "Size of an array must be an integer");
            const size2 = await this.size[2].reduce(vm);
            bigint(size2, "Size of an array must be an integer");
            return new Int3DValue(this.name, [
                Number(size01),
                Number(size12),
                Number(size2)
            ]);
        } else if (this.size.length === 0 && this.type === "number" && this.isChar()) {
            return new IntChar0DValue(this.name);
        } else if (this.size.length === 1 && this.type === "number" && this.isChar()) {
            const size02 = await this.size[0].reduce(vm);
            bigint(size02, "Size of an array must be an integer");
            return new IntChar1DValue(this.name, [
                Number(size02)
            ]);
        } else if (this.size.length === 0 && this.type === "string" && this.isChar()) {
            return new StrChar0DValue(this.name);
        } else if (this.size.length === 1 && this.type === "string" && this.isChar()) {
            const size03 = await this.size[0].reduce(vm);
            bigint(size03, "Size of an array must be an integer");
            return new StrChar1DValue(this.name, [
                Number(size03)
            ]);
        } else {
            throw parser("Invalid #DIM(S) definition found");
        }
    }
}
const whitelist = [
    "DAY",
    "MONEY",
    "ITEM",
    "FLAG",
    "TFLAG",
    "UP",
    "PALAMLV",
    "EXPLV",
    "EJAC",
    "DOWN",
    "RESULT",
    "COUNT",
    "TARGET",
    "ASSI",
    "MASTER",
    "NOITEM",
    "LOSEBASE",
    "SELECTCOM",
    "PREVCOM",
    "TIME",
    "ITEMSALES",
    "PLAYER",
    "NEXTCOM",
    "PBAND",
    "BOUGHT",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "RANDDATA",
    "SAVESTR",
    "TSTR",
    "ISASSI",
    "NO",
    "BASE",
    "MAXBASE",
    "ABL",
    "TALENT",
    "EXP",
    "MARK",
    "PALAM",
    "SOURCE",
    "EX",
    "CFLAG",
    "JUEL",
    "RELATION",
    "EQUIP",
    "TEQUIP",
    "STAIN",
    "GOTJUEL",
    "NOWEX",
    "DOWNBASE",
    "CUP",
    "CDOWN",
    "TCVAR",
    "NAME",
    "CALLNAME",
    "NICKNAME",
    "MASTERNAME",
    "CSTR",
    "DITEMTYPE",
    "DA",
    "DB",
    "DC",
    "DD",
    "DE",
    "TA",
    "TB"
];
const PARSER99 = arg2R2(expr, expr);
class SaveData extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER99);
    }
    async *run(vm) {
        const [indexExpr, commentExpr] = this.arg.get();
        const index = await indexExpr.reduce(vm);
        bigint(index, "1st argument of SAVEDATA must be a number");
        const comment = await commentExpr.reduce(vm);
        string(comment, "2nd argument of SAVEDATA must be a string");
        const saveData = {
            code: vm.code.csv.gamebase.code ?? 0,
            version: vm.code.csv.gamebase.version ?? 0,
            data: {
                comment,
                characters: [],
                variables: {}
            }
        };
        for(let i = 0; i < vm.characterList.length; ++i){
            saveData.data.characters.push({});
        }
        const nameList = [
            ...whitelist
        ];
        for (const property of vm.code.header){
            if (property instanceof Dim && property.isSave() && !property.isGlobal()) {
                nameList.push(property.name);
            }
        }
        for (const name of nameList){
            const cell = vm.getValue(name);
            if (cell instanceof Int0DValue) {
                saveData.data.variables[name] = cell.value.toString();
            } else if (cell instanceof Int1DValue) {
                saveData.data.variables[name] = cell.value.map((value)=>value.toString());
            } else if (cell instanceof Int2DValue) {
                saveData.data.variables[name] = cell.value.map((value0)=>value0.map((value1)=>value1.toString()));
            } else if (cell instanceof Int3DValue) {
                saveData.data.variables[name] = cell.value.map((value0)=>value0.map((value1)=>value1.map((value2)=>value2.toString())));
            } else if (cell instanceof Str0DValue || cell instanceof Str1DValue) {
                saveData.data.variables[name] = cell.value;
            } else if (cell instanceof IntChar0DValue) {
                for(let i1 = 0; i1 < vm.characterList.length; ++i1){
                    const characterCell = vm.characterList[i1].getValue(name);
                    saveData.data.characters[i1][name] = characterCell.value.toString();
                }
            } else if (cell instanceof IntChar1DValue) {
                for(let i2 = 0; i2 < vm.characterList.length; ++i2){
                    const characterCell1 = vm.characterList[i2].getValue(name);
                    saveData.data.characters[i2][name] = characterCell1.value.map((value)=>value.toString());
                }
            } else if (cell instanceof StrChar0DValue || cell instanceof StrChar1DValue) {
                for(let i3 = 0; i3 < vm.characterList.length; ++i3){
                    const characterCell2 = vm.characterList[i3].getValue(name);
                    saveData.data.characters[i3][name] = characterCell2.value;
                }
            }
        }
        await vm.external.setSavedata(savefile.game(Number(index)), JSON.stringify(saveData));
        return null;
    }
}
const PARSER100 = arg0R0();
class SaveGame extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER100, raw);
    }
    async *run() {
        return {
            type: "begin",
            keyword: "SAVEGAME"
        };
    }
}
const PARSER101 = arg0R0();
class SaveGlobal extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER101, raw);
    }
    async *run(vm) {
        const saveData = {
            code: vm.code.csv.gamebase.code ?? 0,
            version: vm.code.csv.gamebase.version ?? 0,
            data: {}
        };
        saveData.data.GLOBAL = vm.getValue("GLOBAL").value.map((value)=>value.toString());
        saveData.data.GLOBALS = vm.getValue("GLOBALS").value;
        for (const property of vm.code.header){
            if (property instanceof Dim && property.isSave() && property.isGlobal()) {
                const cell = vm.getValue(property.name);
                if (cell instanceof Int0DValue) {
                    saveData.data[property.name] = cell.value.toString();
                } else if (cell instanceof Int1DValue) {
                    saveData.data[property.name] = cell.value.map((value)=>value.toString());
                } else if (cell instanceof Int2DValue) {
                    saveData.data[property.name] = cell.value.map((value0)=>value0.map((value1)=>value1.toString()));
                } else if (cell instanceof Int3DValue) {
                    saveData.data[property.name] = cell.value.map((value0)=>value0.map((value1)=>value1.map((value2)=>value2.toString())));
                } else if (cell instanceof Str0DValue) {
                    saveData.data[property.name] = cell.value;
                } else if (cell instanceof Str1DValue) {
                    saveData.data[property.name] = cell.value;
                }
            }
        }
        await vm.external.setSavedata(savefile.global, JSON.stringify(saveData));
        return null;
    }
}
const PARSER102 = Hn1.alt(arg3R3(expr, expr, expr), arg1R1(expr));
class SetBgColor extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER102);
    }
    async *run(vm) {
        const parsed = this.arg.get();
        let color;
        if (Array.isArray(parsed)) {
            const r = await parsed[0].reduce(vm);
            const g = await parsed[1].reduce(vm);
            const b = await parsed[2].reduce(vm);
            bigint(r, "1st argument of SETBGCOLOR must be an integer");
            bigint(g, "2nd argument of SETBGCOLOR must be an integer");
            bigint(b, "3rd argument of SETBGCOLOR must be an integer");
            color = r.toString(16).padStart(2, "0") + g.toString(16).padStart(2, "0") + b.toString(16).padStart(2, "0");
        } else {
            const rgb = await parsed.reduce(vm);
            bigint(rgb, "Argument of SETBGCOLOR must be an integer");
            color = rgb.toString(16).padStart(6, "0");
        }
        vm.printer.background = color;
        return null;
    }
}
const PARSER103 = arg1R1(charSeq());
class SetBgColorByName extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER103);
    }
    async *run(_vm) {
        throw notImpl("SETBGCOLORBYNAME");
        return null;
    }
}
const PARSER104 = argNR1(variable, expr);
class SetBit extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER104);
    }
    async *run(vm) {
        const [destExpr, ...bitExpr] = this.arg.get();
        const dest = destExpr.getCell(vm);
        const value = await destExpr.reduce(vm);
        bigint(value, "1st argument of SETBIT must be a number");
        const bitList = [];
        for(let i = 0; i < bitExpr.length; ++i){
            const bit = await bitExpr[i].reduce(vm);
            bigint(bit, `${i + 2}th argument of INVERTBIT must be a number`);
            bitList.push(bit);
        }
        let result = value;
        for (const bit1 of bitList){
            result |= 1n << bit1;
        }
        dest.set(vm, result, await destExpr.reduceIndex(vm));
        return null;
    }
}
const PARSER105 = Hn1.alt(arg3R3(expr, expr, expr), arg1R1(expr));
class SetColor extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER105);
    }
    async *run(vm) {
        const parsed = this.arg.get();
        let color;
        if (Array.isArray(parsed)) {
            const r = await parsed[0].reduce(vm);
            const g = await parsed[1].reduce(vm);
            const b = await parsed[2].reduce(vm);
            bigint(r, "1st argument of SETCOLOR must be an integer");
            bigint(g, "2nd argument of SETCOLOR must be an integer");
            bigint(b, "3rd argument of SETCOLOR must be an integer");
            color = r.toString(16).padStart(2, "0") + g.toString(16).padStart(2, "0") + b.toString(16).padStart(2, "0");
        } else {
            const rgb = await parsed.reduce(vm);
            bigint(rgb, "Argument of SETCOLOR must be an integer");
            color = rgb.toString(16).padStart(6, "0");
        }
        vm.printer.color = color;
        return null;
    }
}
const PARSER106 = arg1R1(charSeq());
class SetColorByName extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER106);
    }
    async *run(_vm) {
        throw notImpl("SETCOLORBYNAME");
        return null;
    }
}
const PARSER107 = arg1R0(expr);
class SetFont extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER107);
    }
    async *run(vm) {
        const font = await this.arg.get()?.reduce(vm) ?? "";
        string(font, "Argument of SETFONT must be a string");
        vm.printer.font.name = font;
        return null;
    }
}
const PARSER108 = arg1R1(expr);
class SkipDisp extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER108);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        bigint(value, "Argument of SKIPDISP must be a number");
        vm.printer.skipDisp = value !== 0n;
        return null;
    }
}
const PARSER109 = arg2R0(variable, alt("FORWARD", "BACK"));
class SortChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER109);
    }
    async *run(vm) {
        let [varExpr, order] = this.arg.get();
        varExpr = varExpr ?? new Variable("NO", []);
        order = order ?? "FORWARD";
        const cell = varExpr.getCell(vm);
        const target = vm.getValue("TARGET").get(vm, []);
        const assi = vm.getValue("ASSI").get(vm, []);
        const master = vm.getValue("MASTER").get(vm, []);
        const characterList = vm.characterList.map((character, index)=>({
                character,
                index
            }));
        if (master >= 0) {
            characterList.splice(Number(master), 1);
        }
        if (cell instanceof IntChar0DValue) {
            characterList.sort((a, b)=>{
                const left = cell.get(vm, [
                    a.index
                ]);
                const right = cell.get(vm, [
                    b.index
                ]);
                const compare = Number(left - right);
                return order === "FORWARD" ? compare : -compare;
            });
        } else if (cell instanceof IntChar1DValue) {
            const index = await varExpr.reduceIndex(vm);
            characterList.sort((a, b)=>{
                const left = cell.get(vm, [
                    a.index,
                    ...index
                ]);
                const right = cell.get(vm, [
                    b.index,
                    ...index
                ]);
                const compare = Number(left - right);
                return order === "FORWARD" ? compare : -compare;
            });
        } else if (cell instanceof StrChar0DValue) {
            characterList.sort((a, b)=>{
                const left = cell.get(vm, [
                    a.index
                ]);
                const right = cell.get(vm, [
                    b.index
                ]);
                const compare = left.localeCompare(right);
                return order === "FORWARD" ? compare : -compare;
            });
        } else if (cell instanceof StrChar1DValue) {
            const index1 = await varExpr.reduceIndex(vm);
            characterList.sort((a, b)=>{
                const left = cell.get(vm, [
                    a.index,
                    ...index1
                ]);
                const right = cell.get(vm, [
                    b.index,
                    ...index1
                ]);
                const compare = left.localeCompare(right);
                return order === "FORWARD" ? compare : -compare;
            });
        } else {
            throw misc("Sort key of SORTCHARA is not a character variable");
        }
        for(let i = 0; i < characterList.length; ++i){
            if (characterList[i].index === Number(target)) {
                vm.getValue("TARGET").set(vm, BigInt(i), []);
            }
            if (characterList[i].index === Number(assi)) {
                vm.getValue("ASSI").set(vm, BigInt(i), []);
            }
        }
        if (master >= 0) {
            characterList.splice(Number(master), 0, {
                character: vm.characterList[Number(master)],
                index: -1
            });
        }
        vm.characterList = characterList.map(({ character  })=>character);
        return null;
    }
}
const PARSER110 = arg3R3(expr, expr, variable);
class Split extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER110);
    }
    async *run(vm) {
        const [valueExpr, sepExpr, destExpr] = this.arg.get();
        const value = await valueExpr.reduce(vm);
        string(value, "1st argument of SPLIT must be a string!");
        const sep = await sepExpr.reduce(vm);
        string(sep, "2nd argument of SPLIT must be a number!");
        const dest = destExpr.getCell(vm);
        const index = await destExpr.reduceIndex(vm);
        const chunkList = value.split(sep);
        for(let i = 0; i < chunkList.length; ++i){
            dest.set(vm, chunkList[i], [
                ...index,
                i
            ]);
        }
        vm.getValue("RESULT").set(vm, BigInt(chunkList.length), [
            0
        ]);
        return null;
    }
}
const PARSER111 = arg0R0();
class StopCallTrain extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER111, raw);
    }
    async *run() {
        throw notImpl("STOPCALLTRAIN");
        return null;
    }
}
const DATA1 = /^DATA(\s+|$)/i;
const DATAFORM1 = /^DATAFORM\s+/i;
const DATAFORM_EMPTY1 = /^DATAFORM$/i;
const DATALIST1 = /^DATALIST$/i;
const ENDLIST1 = /^ENDLIST$/i;
const ENDDATA1 = /^ENDDATA$/i;
const PARSER_ARG = arg1R1(variable);
const PARSER_CONST2 = arg1R0(charSeq()).map((value)=>new Const(value ?? ""));
const PARSER_FORM2 = arg1R1(form[""]);
class StrData extends Statement {
    static parse(lines, from) {
        let index = from + 1;
        const data = [];
        while(true){
            if (lines.length <= index) {
                throw parser("Unexpected end of thunk in STRDATA expression");
            }
            const current = lines[index];
            index += 1;
            if (DATA1.test(current.content)) {
                data.push(new Lazy(current.slice("DATA".length), PARSER_CONST2));
            } else if (DATAFORM1.test(current.content)) {
                data.push(new Lazy(current.slice("DATAFORM".length), PARSER_FORM2));
            } else if (DATAFORM_EMPTY1.test(current.content)) {
                data.push(new Lazy(current.slice("DATAFORM".length), PARSER_CONST2));
            } else if (DATALIST1.test(current.content) || ENDLIST1.test(current.content)) {} else if (ENDDATA1.test(current.content)) {
                return [
                    new StrData(lines[from].slice("STRADATA".length), data),
                    index - from
                ];
            } else {
                throw parser("Unexpected statement in STRDATA expression");
            }
        }
    }
    arg;
    data;
    constructor(raw, data){
        super(raw);
        this.arg = new Lazy(raw, PARSER_ARG);
        this.data = data;
    }
    async *run(vm) {
        const dest = this.arg.get();
        const index = vm.random.next() % this.data.length;
        const value = await this.data[index].get().reduce(vm);
        string(value, "Item of STRDATA must be a string");
        dest.getCell(vm).set(vm, value, await dest.reduceIndex(vm));
        return null;
    }
}
const PARSER112 = arg2R2(expr, expr);
class StrFind extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER112);
    }
    async *run(vm) {
        const [valueExpr, searchExpr] = this.arg.get();
        const value = await valueExpr.reduce(vm);
        string(value, "1st argument of STRFIND must be a string!");
        const search = await searchExpr.reduce(vm);
        string(search, "2nd argument of STRFIND must be a string!");
        vm.getValue("RESULT").set(vm, BigInt(value.indexOf(search)), [
            0
        ]);
        return null;
    }
}
const PARSER113 = arg2R2(expr, expr);
class StrFindU extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER113);
    }
    async *run(vm) {
        const [valueExpr, searchExpr] = this.arg.get();
        const value = await valueExpr.reduce(vm);
        string(value, "1st argument of STRFINDU must be a string!");
        const search = await searchExpr.reduce(vm);
        string(search, "2nd argument of STRFINDU must be a string!");
        vm.getValue("RESULT").set(vm, BigInt(value.indexOf(search)), [
            0
        ]);
        return null;
    }
}
const PARSER114 = arg1R1(charSeq());
class StrLen extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER114);
    }
    async *run(vm) {
        const value = this.arg.get();
        string(value, "Argument of STRLEN must be a string!");
        vm.getValue("RESULT").set(vm, BigInt(value.length), [
            0
        ]);
        return null;
    }
}
const PARSER115 = arg1R1(form[""]);
class StrLenForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER115);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        string(value, "Argument of STRLENFORM must be a string!");
        vm.getValue("RESULT").set(vm, BigInt(value.length), [
            0
        ]);
        return null;
    }
}
const PARSER116 = arg1R1(form[""]);
class StrLenFormU extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER116);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        string(value, "Argument of STRLENFORMU must be a string!");
        vm.getValue("RESULT").set(vm, BigInt(value.length), [
            0
        ]);
        return null;
    }
}
const PARSER117 = arg1R1(charSeq());
class StrLen1 extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER117);
    }
    async *run(vm) {
        const value = this.arg.get();
        string(value, "Argument of STRLENU must be a string!");
        vm.getValue("RESULT").set(vm, BigInt(value.length), [
            0
        ]);
        return null;
    }
}
const PARSER118 = arg3R3(expr, expr, expr);
class Substring extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER118);
    }
    async *run(vm) {
        const [valueExpr, startExpr, endExpr] = this.arg.get();
        const value = await valueExpr.reduce(vm);
        string(value, "1st argument of SUBSTRING must be a string!");
        const start = await startExpr.reduce(vm);
        bigint(start, "2nd argument of SUBSTRING must be a number!");
        const end = await endExpr.reduce(vm);
        bigint(end, "3rd argument of SUBSTRING must be a number!");
        if (end < 0) {
            vm.getValue("RESULTS").set(vm, value.slice(Number(start)), [
                0
            ]);
        } else {
            vm.getValue("RESULTS").set(vm, value.slice(Number(start), Number(end)), [
                0
            ]);
        }
        return null;
    }
}
const PARSER119 = arg3R3(expr, expr, expr);
class SubstringU extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER119);
    }
    async *run(vm) {
        const [valueExpr, startExpr, endExpr] = this.arg.get();
        const value = await valueExpr.reduce(vm);
        string(value, "1st argument of SUBSTRINGU must be a string!");
        const start = await startExpr.reduce(vm);
        bigint(start, "2nd argument of SUBSTRINGU must be a number!");
        const end = await endExpr.reduce(vm);
        bigint(end, "3rd argument of SUBSTRINGU must be a number!");
        if (end < 0) {
            vm.getValue("RESULTS").set(vm, value.slice(Number(start)), [
                0
            ]);
        } else {
            vm.getValue("RESULTS").set(vm, value.slice(Number(start), Number(end)), [
                0
            ]);
        }
        return null;
    }
}
const PARSER120 = arg2R2(variable, variable);
class Swap extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER120);
    }
    async *run(vm) {
        const [leftExpr, rightExpr] = this.arg.get();
        const left = leftExpr.getCell(vm);
        const leftIndex = await leftExpr.reduceIndex(vm);
        const right = rightExpr.getCell(vm);
        const rightIndex = await rightExpr.reduceIndex(vm);
        const leftValue = left.get(vm, leftIndex);
        const rightValue = right.get(vm, rightIndex);
        left.set(vm, rightValue, leftIndex);
        right.set(vm, leftValue, rightIndex);
        return null;
    }
}
const PARSER121 = arg2R2(expr, expr);
class SwapChara extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER121);
    }
    async *run(vm) {
        const [leftExpr, rightExpr] = this.arg.get();
        const left = await leftExpr.reduce(vm);
        bigint(left, "1st argument of SWAPCHARA must be a number");
        const right = await rightExpr.reduce(vm);
        bigint(right, "2nd argument of SWAPCHARA must be a number");
        const temp = vm.characterList[Number(left)];
        vm.characterList[Number(left)] = vm.characterList[Number(right)];
        vm.characterList[Number(right)] = temp;
        return null;
    }
}
const PARSER122 = arg1R1(form[""]);
class Throw extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER122);
    }
    async *run(vm) {
        const value = await this.arg.get().reduce(vm);
        string(value, "Argument of THROW must be a string");
        return {
            type: "throw",
            value
        };
    }
}
const PARSER123 = arg2R2(variable, Float);
class Times extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER123);
    }
    async *run(vm) {
        const [dest, value] = this.arg.get();
        const original = await dest.reduce(vm);
        bigint(original, "1st argument of TIMES must be a number");
        const index = await dest.reduceIndex(vm);
        let result = 0n;
        let remaining = value;
        for(let i = 0; i < 100; ++i){
            if (remaining === 0) {
                break;
            }
            const high = Math.floor(remaining);
            result += original * BigInt(high) / 100n ** BigInt(i);
            remaining = (remaining - high) * 100;
        }
        dest.getCell(vm).set(vm, result, index);
        return null;
    }
}
const PARSER124 = arg4R2(expr, expr, expr, charSeq());
class TInput extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER124);
    }
    async *run(vm) {
        const [timeoutExpr, defExpr, showExpr, message] = this.arg.get();
        const timeout = await timeoutExpr.reduce(vm);
        bigint(timeout, "1st argument of TINPUT should be a number");
        const def = await defExpr.reduce(vm);
        bigint(def, "2nd argument of TINPUT should be a number");
        const show = await showExpr?.reduce(vm) ?? 0n;
        bigint(show, "3rd argument of TINPUT should be a number");
        const input = yield* vm.printer.tinput(true, Number(timeout), show === 1n);
        let value;
        if (input == null) {
            if (message != null) {
                yield* vm.printer.print(message, new Set([
                    "S"
                ]));
            }
            value = def;
        } else {
            value = BigInt(input);
        }
        yield* vm.printer.print(value.toString(), new Set([
            "S"
        ]));
        vm.getValue("RESULT").set(vm, value, [
            0
        ]);
        return null;
    }
}
const PARSER125 = arg4R2(expr, expr, expr, charSeq());
class TInputS extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER125);
    }
    async *run(vm) {
        const [timeoutExpr, defExpr, showExpr, message] = this.arg.get();
        const timeout = await timeoutExpr.reduce(vm);
        bigint(timeout, "1st argument of TINPUTS should be a number");
        const def = await defExpr.reduce(vm);
        string(def, "2nd argument of TINPUTS should be a string");
        const show = await showExpr?.reduce(vm) ?? 0n;
        bigint(show, "3rd argument of TINPUTS should be a number");
        const input = yield* vm.printer.tinput(false, Number(timeout), show === 1n);
        let value;
        if (input == null) {
            if (message != null) {
                yield* vm.printer.print(message, new Set([
                    "S"
                ]));
            }
            value = def;
        } else {
            value = input;
        }
        yield* vm.printer.print(value, new Set([
            "S"
        ]));
        vm.getValue("RESULTS").set(vm, value, [
            0
        ]);
        return null;
    }
}
const PARSER126 = arg4R2(expr, expr, expr, charSeq());
class TOneInput extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER126);
    }
    async *run(vm) {
        const [timeoutExpr, defExpr, showExpr, message] = this.arg.get();
        const timeout = await timeoutExpr.reduce(vm);
        bigint(timeout, "1st argument of TONEINPUT should be a number");
        const def = await defExpr.reduce(vm);
        bigint(def, "2nd argument of TONEINPUT should be a number");
        const show = await showExpr?.reduce(vm) ?? 0n;
        bigint(show, "3rd argument of TONEINPUT should be a number");
        const input = yield* vm.printer.tinput(true, Number(timeout), show === 1n);
        let value;
        if (input == null) {
            if (message != null) {
                yield* vm.printer.print(message, new Set([
                    "S"
                ]));
            }
            value = def;
        } else {
            value = BigInt(input[0]);
        }
        yield* vm.printer.print(value.toString(), new Set([
            "S"
        ]));
        vm.getValue("RESULT").set(vm, value, [
            0
        ]);
        return null;
    }
}
const PARSER127 = arg4R2(expr, expr, expr, charSeq());
class TOneInputS extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER127);
    }
    async *run(vm) {
        const [timeoutExpr, defExpr, showExpr, message] = this.arg.get();
        const timeout = await timeoutExpr.reduce(vm);
        bigint(timeout, "1st argument of TONEINPUTS should be a number");
        const def = await defExpr.reduce(vm);
        string(def, "2nd argument of TONEINPUTS should be a string");
        const show = await showExpr?.reduce(vm) ?? 0n;
        bigint(show, "3rd argument of TONEINPUTS should be a number");
        const input = yield* vm.printer.tinput(false, Number(timeout), show === 1n);
        let value;
        if (input == null) {
            if (message != null) {
                yield* vm.printer.print(message, new Set([
                    "S"
                ]));
            }
            value = def;
        } else {
            value = input;
        }
        yield* vm.printer.print(value, new Set([
            "S"
        ]));
        vm.getValue("RESULTS").set(vm, value, [
            0
        ]);
        return null;
    }
}
class TryCall extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
    }
    async *run(vm) {
        const [target, argExpr] = this.arg.get();
        const realTarget = target.toUpperCase();
        if (vm.fnMap.has(realTarget)) {
            return yield* Call.exec(vm, realTarget, argExpr);
        }
        return null;
    }
}
class TryCallForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER("(,"));
    }
    async *run(vm) {
        const [targetExpr, argExpr] = this.arg.get();
        const target = (await targetExpr.reduce(vm)).toUpperCase();
        if (vm.fnMap.has(target)) {
            return yield* Call.exec(vm, target, argExpr);
        }
        return null;
    }
}
const PARSER128 = arg1R1(Identifier);
class TryGoto extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER128);
    }
    async *run(vm) {
        const target = this.arg.get().toUpperCase();
        const context = vm.context();
        if (context.fn.thunk.labelMap.has(target)) {
            return yield* Goto.exec(vm, target);
        }
        return null;
    }
}
const PARSER129 = arg1R1(form[""]);
class TryGotoForm extends Statement {
    static parse(arg) {
        return new TryGotoForm(arg);
    }
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER129);
    }
    async *run(vm) {
        const target = (await this.arg.get().reduce(vm)).toUpperCase();
        const context = vm.context();
        if (context.fn.thunk.labelMap.has(target)) {
            return yield* Goto.exec(vm, target);
        }
        return null;
    }
}
class TryJump extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
    }
    async *run(vm) {
        const [target, argExpr] = this.arg.get();
        const realTarget = target.toUpperCase();
        if (vm.fnMap.has(realTarget)) {
            return yield* Jump.exec(vm, realTarget, argExpr);
        }
        return null;
    }
}
class TryJumpForm extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER("("));
    }
    async *run(vm) {
        const [targetExpr, argExpr] = this.arg.get();
        const target = (await targetExpr.reduce(vm)).toUpperCase();
        if (vm.fnMap.has(target)) {
            return yield* Jump.exec(vm, target, argExpr);
        }
        return null;
    }
}
const PARSER130 = arg0R0();
class UpCheck extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER130, raw);
    }
    async *run(vm) {
        const length = Math.min(vm.getValue("PALAM").length(1), vm.getValue("UP").length(0), vm.getValue("DOWN").length(0));
        for(let i = 0; i < length; ++i){
            const up = vm.getValue("UP").get(vm, [
                i
            ]);
            const down = vm.getValue("DOWN").get(vm, [
                i
            ]);
            const palam = vm.getValue("PALAM").get(vm, [
                i
            ]);
            if (up <= 0 && down <= 0) {
                continue;
            }
            const result = palam + up - down;
            vm.getValue("PALAM").set(vm, result, [
                i
            ]);
            vm.getValue("UP").set(vm, 0n, [
                i
            ]);
            vm.getValue("DOWN").set(vm, 0n, [
                i
            ]);
            if (!vm.printer.skipDisp) {
                const name = vm.code.csv.palam.get(i);
                let text = `${name} ${palam}`;
                if (up > 0) {
                    text += `+${up}`;
                }
                if (down > 0) {
                    text += `-${down}`;
                }
                text += `=${result}`;
                yield* vm.printer.print(text, new Set([
                    "L"
                ]));
            }
        }
        return null;
    }
}
const PARSER131 = arg4R1(variable, expr, expr, expr);
class VarSet1 extends Statement {
    arg;
    constructor(raw){
        super(raw);
        this.arg = new Lazy(raw, PARSER131);
    }
    async *run(vm) {
        const [destExpr, valueExpr, startExpr, endExpr] = this.arg.get();
        const dest = destExpr.getCell(vm);
        const index = await destExpr.reduceIndex(vm);
        const start = await startExpr?.reduce(vm) ?? 0n;
        bigint(start, "3rd argument of VARSET must be a number");
        const end = await endExpr?.reduce(vm) ?? BigInt(dest.length(index.length));
        bigint(end, "4th argument of VARSET must be a number");
        if (valueExpr != null) {
            const value = await valueExpr.reduce(vm);
            dest.rangeSet(vm, value, index, [
                Number(start),
                Number(end)
            ]);
        } else {
            if (dest.type === "number") {
                dest.rangeSet(vm, 0n, index, [
                    Number(start),
                    Number(end)
                ]);
            } else {
                dest.rangeSet(vm, "", index, [
                    Number(start),
                    Number(end)
                ]);
            }
        }
        return null;
    }
}
const PARSER132 = arg0R0();
class Wait extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER132, raw);
    }
    async *run(vm) {
        yield* vm.printer.wait(false);
        return null;
    }
}
const PARSER133 = arg0R0();
class WaitAnyKey extends Statement {
    constructor(raw){
        super(raw);
        tryParse(PARSER133, raw);
    }
    async *run() {
        throw notImpl("WAITANYKEY");
        return null;
    }
}
class Slice {
    file;
    line;
    from;
    to;
    content;
    constructor(file, line, content, from, to){
        this.file = file;
        this.line = line;
        this.content = content;
        this.from = from ?? 0;
        this.to = to ?? content.length;
    }
    slice(from, to) {
        const newFrom = this.from + (from ?? 0);
        let newTo;
        if (to == null) {
            newTo = this.to;
        } else {
            newTo = Math.min(this.to, this.from + to);
        }
        return new Slice(this.file, this.line, this.content, newFrom, newTo);
    }
    get() {
        return this.content.slice(this.from, this.to);
    }
    length() {
        return this.to - this.from;
    }
}
function normalize(raw) {
    if (raw.startsWith("\uFEFF") || raw.startsWith("\uFFEF")) {
        return raw.slice(1);
    }
    return raw;
}
function toLines(raw) {
    const converted = raw.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
    return converted.map((content, index)=>new Slice("", index, content));
}
function preprocess(lines, macros) {
    const fn = [
        (prev)=>prev.map((line)=>new Slice("", line.line, line.content.replace(/;.*$/, ""))),
        (prev)=>prev.map((line)=>new Slice("", line.line, line.content.trim())),
        (prev)=>prev.filter((line)=>line.content.length > 0),
        (prev)=>{
            const result = [];
            let index = 0;
            while(index < prev.length){
                const line = prev[index];
                if (line.content === "[SKIPSTART]") {
                    index += prev.slice(index).findIndex((l)=>l.content === "[SKIPEND]") + 1;
                } else if (line.content === "[IF_DEBUG]") {
                    index += prev.slice(index).findIndex((l)=>l.content === "[ENDIF]") + 1;
                } else {
                    result.push(line);
                    index += 1;
                }
            }
            return result;
        },
        (prev)=>{
            let result = [];
            let index = 0;
            while(index < prev.length){
                const line = prev[index];
                if (/^\[IF .*\]$/.test(line.content)) {
                    const name = line.content.slice("[IF ".length, -1 * "]".length);
                    index += 1;
                    const endIndex = index + prev.slice(index).findIndex((l)=>l.content === "[ENDIF]");
                    if (macros.has(name)) {
                        result = result.concat(prev.slice(index, endIndex));
                    }
                    index = endIndex + 1;
                } else {
                    result.push(line);
                    index += 1;
                }
            }
            return result;
        },
        (prev)=>{
            const result = [];
            let index = 0;
            while(index < prev.length){
                const line = prev[index];
                if (line.content === "{") {
                    const endIndex = index + prev.slice(index).findIndex((l)=>l.content === "}");
                    const subLines = prev.slice(index + 1, endIndex);
                    result.push(new Slice(subLines[0].file, subLines[0].line, subLines.map((l)=>l.content).join("")));
                    index = endIndex + 1;
                } else {
                    result.push(line);
                    index += 1;
                }
            }
            return result;
        }
    ];
    return fn.reduce((acc, val)=>val(acc), lines);
}
class Define {
    name;
    expr;
    constructor(name, expr){
        this.name = name;
        this.expr = expr;
    }
}
class LocalSize {
    size;
    constructor(size){
        this.size = size;
    }
    async apply(vm, fn) {
        const size = await this.size.reduce(vm);
        bigint(size, "Argument of LOCALSIZE should be a number");
        vm.staticMap.get(fn).set("LOCAL", new Int1DValue("LOCAL", [
            Number(size)
        ]));
    }
}
class LocalSSize {
    size;
    constructor(size){
        this.size = size;
    }
    async apply(vm, fn) {
        const size = await this.size.reduce(vm);
        bigint(size, "Argument of LOCALSIZE should be a number");
        vm.staticMap.get(fn).set("LOCALS", new Str1DValue("LOCALS", [
            Number(size)
        ]));
    }
}
class Method1 {
}
class Single {
}
const parser1 = Hn1.string("#").then(Hn1.alt(Hn1.regex(/DEFINE/i).skip(WS1).then(Hn1.seqMap(Identifier, WS1, expr, (name, _2, expr)=>new Define(name, expr))), Hn1.regex(/PRI/i).then(arg0R0()).map(()=>new Order("PRI")), Hn1.regex(/LATER/i).map(()=>new Order("LATER")), Hn1.regex(/SINGLE/i).map(()=>new Single()), Hn1.regex(/FUNCTIONS/i).map(()=>new Method1()), Hn1.regex(/FUNCTION/i).map(()=>new Method1()), Hn1.regex(/LOCALSIZE/i).skip(WS1).then(expr).map((expr)=>new LocalSize(expr)), Hn1.regex(/LOCALSSIZE/i).skip(WS1).then(expr).map((expr)=>new LocalSSize(expr)), Hn1.regex(/DIM/i).skip(WS1).then(Hn1.seqMap(Hn1.alt(Hn1.regex(/CONST/i).skip(WS1), Hn1.regex(/DYNAMIC/i).skip(WS1), Hn1.regex(/GLOBAL/i).skip(WS1), Hn1.regex(/REF/i).skip(WS1), Hn1.regex(/SAVEDATA/i).skip(WS1), Hn1.regex(/CHARADATA/i).skip(WS1)).many(), sepBy1(",", Identifier, expr), Hn1.alt(Hn1.string("=").trim(WS0).then(sepBy0(",", expr)), Hn1.succeed(undefined)), Hn1.string(",").fallback(null), (prefix, [name, ...size], value)=>new Dim(name, "number", prefix, size, value))), Hn1.regex(/DIMS/i).skip(WS1).then(Hn1.seqMap(Hn1.alt(Hn1.regex(/CONST/i).skip(WS1), Hn1.regex(/DYNAMIC/i).skip(WS1), Hn1.regex(/GLOBAL/i).skip(WS1), Hn1.regex(/REF/i).skip(WS1), Hn1.regex(/SAVEDATA/i).skip(WS1), Hn1.regex(/CHARADATA/i).skip(WS1)).many(), sepBy1(",", Identifier, expr), Hn1.alt(Hn1.string("=").trim(WS0).then(sepBy0(",", expr)), Hn1.succeed(undefined)), Hn1.string(",").fallback(null), (prefix, [name, ...size], value)=>new Dim(name, "string", prefix, size, value)))));
function parseERB(files, macros) {
    const result = [];
    for (const [name, content] of files){
        const normalized = normalize(content);
        const lines = preprocess(toLines(normalized), macros);
        for (const line of lines){
            line.file = name;
        }
        let index = 0;
        while(lines.length > index){
            const [fn, consumed] = parseFn(lines, index);
            result.push(fn);
            index += consumed;
        }
    }
    return result;
}
const CASE = /^CASE\s+/i;
const LOOP = /^LOOP\s+/i;
const NEXT = /^NEXT$/i;
const IF = /^IF\s+/i;
const REND = /^REND$/i;
const CATCH = /^CATCH$/i;
const CATCH1 = /^CATCH$/i;
const CATCH2 = /^CATCH$/i;
const CATCH3 = /^CATCH$/i;
const CATCH4 = /^CATCH$/i;
const CATCH5 = /^CATCH$/i;
const WEND = /^WEND$/i;
class Thunk {
    statement;
    labelMap;
    constructor(statement){
        this.statement = [];
        this.labelMap = new Map();
        for(let i = 0; i < statement.length; ++i){
            const s = statement[i];
            if (typeof s === "string") {
                this.labelMap.set(s, this.statement.length);
            } else {
                this.statement.push(s);
            }
        }
        for(let i1 = 0; i1 < this.statement.length; ++i1){
            const s1 = this.statement[i1];
            if (s1 instanceof Case) {
                for (const branch of s1.branch){
                    branch[1].labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
                }
                s1.def.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
            } else if (s1 instanceof For) {
                s1.thunk.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
            } else if (s1 instanceof If1) {
                for (const [, , thunk] of s1.ifThunk){
                    thunk.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
                }
                s1.elseThunk.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
            } else if (s1 instanceof Repeat) {
                s1.thunk.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
            } else if (s1 instanceof While) {
                s1.thunk.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
            } else if (s1 instanceof DoWhile) {
                s1.thunk.labelMap.forEach((_, l)=>this.labelMap.set(l, i1));
            }
        }
    }
    async *run(vm, label) {
        let start = 0;
        if (label != null) {
            start = this.labelMap.get(label) ?? 0;
        }
        for(let i = start; i < this.statement.length; ++i){
            const statement = this.statement[i];
            const result = yield* vm.run(statement, label);
            switch(result?.type){
                case "begin":
                    return result;
                case "goto":
                    {
                        if (this.labelMap.has(result.label)) {
                            return yield* this.run(vm, result.label);
                        } else {
                            return result;
                        }
                    }
                case "break":
                    return result;
                case "continue":
                    return result;
                case "throw":
                    return result;
                case "return":
                    return result;
                case "quit":
                    return result;
                case undefined:
                    continue;
            }
        }
        return null;
    }
}
function parseFn(lines, from) {
    let index = from;
    const defIndex = index;
    index += 1;
    const propIndex = index;
    while(lines.length > index){
        if (!lines[index].content.startsWith("#")) {
            break;
        }
        index += 1;
    }
    const bodyIndex = index;
    while(lines.length > index){
        if (lines[index].content.startsWith("@")) {
            break;
        }
        index += 1;
    }
    const argParser = sepBy0(",", Hn1.seq(variable, Hn1.alt(Hn1.string("=").trim(WS0).then(Int).map((val)=>BigInt(val)), Hn1.string("=").trim(WS0).then(Str), Hn1.string("=").trim(WS0).then(variable), Hn1.succeed(null))));
    const defParser = Hn1.string("@").then(Hn1.seq(Identifier.skip(WS0), Hn1.alt(wrap("(", ")", argParser), Hn1.string(",").trim(WS0).then(argParser), Hn1.succeed([]))));
    const definition = tryParse(defParser, lines[defIndex]);
    const property = [];
    for(let i = propIndex; i < bodyIndex; ++i){
        property.push(tryParse(parser1, lines[i]));
    }
    const [body] = parseThunk(lines.slice(bodyIndex, index), 0);
    return [
        new Fn2(definition[0], definition[1], property, body),
        index - from
    ];
}
function parseThunk(lines, from, until) {
    const body = [];
    let index = from;
    while(index < lines.length){
        const current = lines[index];
        if (until != null && until(current.content)) {
            break;
        }
        if (current.content.startsWith("$")) {
            body.push(current.content.slice(1));
            index += 1;
        } else {
            const [statement, consumed] = parseStatement(lines, index);
            body.push(statement);
            index += consumed;
        }
    }
    return [
        new Thunk(body),
        index - from
    ];
}
const ID_REGEX = /^[^\+\-\*\/\%\=\!\<\>\|\&\^\~\?\#\(\)\{\}\[\]\.\,\:\$\\\'\"\@\;\s]+/;
function parseStatement(lines, index) {
    const current = lines[index];
    const match = ID_REGEX.exec(current.content);
    if (match != null) {
        const IDENTIFIER = match[0].toUpperCase();
        if (commandParser[IDENTIFIER] != null) {
            const arg = current.slice(match[0].length);
            return commandParser[IDENTIFIER](arg, lines, index);
        }
    }
    return [
        new Assign(current),
        1
    ];
}
const ENDCATCH = /^ENDCATCH$/i;
class TryCCall extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        const [thenThunk, consumedT] = parseThunk(lines, index, (l)=>CATCH.test(l));
        index += consumedT + 1;
        const [catchThunk, consumedC] = parseThunk(lines, index, (l)=>ENDCATCH.test(l));
        index += consumedC + 1;
        return [
            new TryCCall(arg, thenThunk, catchThunk),
            index - from
        ];
    }
    arg;
    thenThunk;
    catchThunk;
    constructor(raw, thenThunk, catchThunk){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
        this.thenThunk = thenThunk;
        this.catchThunk = catchThunk;
    }
    async *run(vm, label) {
        if (label != null && this.thenThunk.labelMap.has(label)) {
            return yield* this.thenThunk.run(vm, label);
        }
        if (label != null && this.catchThunk.labelMap.has(label)) {
            return yield* this.catchThunk.run(vm, label);
        }
        const [target, argExpr] = this.arg.get();
        const realTarget = target.toUpperCase();
        if (vm.fnMap.has(realTarget)) {
            yield* Call.exec(vm, realTarget, argExpr);
            return yield* this.thenThunk.run(vm, label);
        } else {
            return yield* this.catchThunk.run(vm, label);
        }
    }
}
const ENDCATCH1 = /^ENDCATCH$/i;
class TryCCallForm extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        const [thenThunk, consumedT] = parseThunk(lines, index, (l)=>CATCH1.test(l));
        index += consumedT + 1;
        const [catchThunk, consumedC] = parseThunk(lines, index, (l)=>ENDCATCH1.test(l));
        index += consumedC + 1;
        return [
            new TryCCallForm(arg, thenThunk, catchThunk),
            index - from
        ];
    }
    arg;
    thenThunk;
    catchThunk;
    constructor(raw, thenThunk, catchThunk){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER(""));
        this.thenThunk = thenThunk;
        this.catchThunk = catchThunk;
    }
    async *run(vm, label) {
        if (label != null && this.thenThunk.labelMap.has(label)) {
            return yield* this.thenThunk.run(vm, label);
        }
        if (label != null && this.catchThunk.labelMap.has(label)) {
            return yield* this.catchThunk.run(vm, label);
        }
        const [targetExpr, argExpr] = this.arg.get();
        const target = (await targetExpr.reduce(vm)).toUpperCase();
        if (vm.fnMap.has(target)) {
            yield* Call.exec(vm, target, argExpr);
            return yield* this.thenThunk.run(vm, label);
        } else {
            return yield* this.catchThunk.run(vm, label);
        }
    }
}
const ENDCATCH2 = /^ENDCATCH$/i;
class TryCJump extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        if (lines.length <= index) {
            throw parser("Unexpected end of thunk in TRYCJUMP expression");
        } else if (!CATCH4.test(lines[index].content)) {
            throw parser("Could not find CATCH for TRYCJUMP expression");
        }
        index += 1;
        const [catchThunk, consumed] = parseThunk(lines, index, (l)=>ENDCATCH2.test(l));
        index += consumed + 1;
        return [
            new TryCJump(arg, catchThunk),
            index - from
        ];
    }
    arg;
    catchExpr;
    constructor(raw, catchExpr){
        super(raw);
        this.arg = new Lazy(raw, Call.PARSER);
        this.catchExpr = catchExpr;
    }
    async *run(vm, label) {
        const [target, argExpr] = this.arg.get();
        const realTarget = target.toUpperCase();
        if (vm.fnMap.has(realTarget)) {
            return yield* Jump.exec(vm, realTarget, argExpr);
        } else {
            return yield* this.catchExpr.run(vm, label);
        }
    }
}
const ENDCATCH3 = /^ENDCATCH$/i;
class TryCJumpForm extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        if (lines.length <= index) {
            throw parser("Unexpected end of thunk in TRYCJUMPFORM expression");
        } else if (!CATCH5.test(lines[index].content)) {
            throw parser("Could not find CATCH for TRYCJUMPFORM expression");
        }
        index += 1;
        const [catchThunk, consumed] = parseThunk(lines, index, (l)=>ENDCATCH3.test(l));
        index += consumed + 1;
        return [
            new TryCJumpForm(arg, catchThunk),
            index - from
        ];
    }
    arg;
    catchThunk;
    constructor(raw, catchThunk){
        super(raw);
        this.arg = new Lazy(raw, CallForm.PARSER(""));
        this.catchThunk = catchThunk;
    }
    async *run(vm, label) {
        const [targetExpr, argExpr] = this.arg.get();
        const target = (await targetExpr.reduce(vm)).toUpperCase();
        if (vm.fnMap.has(target)) {
            return yield* Jump.exec(vm, target, argExpr);
        } else {
            return yield* this.catchThunk.run(vm, label);
        }
    }
}
const ENDCATCH4 = /^ENDCATCH$/i;
const PARSER134 = arg1R1(Identifier);
class TryCGoto extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        if (lines.length <= index) {
            throw parser("Unexpected end of thunk in TRYCGOTO expression");
        } else if (!CATCH2.test(lines[index].content)) {
            throw parser("Could not find CATCH for TRYCGOTO expression");
        }
        index += 1;
        const [catchThunk, consumed] = parseThunk(lines, index, (l)=>ENDCATCH4.test(l));
        index += consumed + 1;
        return [
            new TryCGoto(arg, catchThunk),
            index - from
        ];
    }
    arg;
    catchThunk;
    constructor(raw, catchThunk){
        super(raw);
        this.arg = new Lazy(raw, PARSER134);
        this.catchThunk = catchThunk;
    }
    async *run(vm, label) {
        const target = this.arg.get().toUpperCase();
        const context = vm.context();
        if (context.fn.thunk.labelMap.has(target)) {
            return yield* Goto.exec(vm, target);
        } else {
            return yield* this.catchThunk.run(vm, label);
        }
    }
}
const ENDCATCH5 = /^ENDCATCH$/i;
const PARSER135 = arg1R1(form[""]);
class TryCGotoForm extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        if (lines.length <= index) {
            throw parser("Unexpected end of thunk in TRYCGOTOFORM expression");
        } else if (!CATCH3.test(lines[index].content)) {
            throw parser("Could not find CATCH for TRYCGOTOFORM expression");
        }
        index += 1;
        const [catchThunk, consumed] = parseThunk(lines, index, (l)=>ENDCATCH5.test(l));
        index += consumed + 1;
        return [
            new TryCGotoForm(arg, catchThunk),
            index - from
        ];
    }
    arg;
    catchThunk;
    constructor(raw, catchThunk){
        super(raw);
        this.arg = new Lazy(raw, PARSER135);
        this.catchThunk = catchThunk;
    }
    async *run(vm, label) {
        const target = (await this.arg.get().reduce(vm)).toUpperCase();
        const context = vm.context();
        if (context.fn.thunk.labelMap.has(target)) {
            return yield* Goto.exec(vm, target);
        } else {
            return yield* this.catchThunk.run(vm, label);
        }
    }
}
const ELSEIF = /^ELSEIF\s+/i;
const ELSE = /^ELSE$/i;
const ENDIF = /^ENDIF$/i;
const PARSER136 = arg1R1(expr);
class If1 extends Statement {
    static parse(lines, from) {
        let index = from;
        const ifThunk = [];
        let elseThunk = new Thunk([]);
        while(true){
            if (lines.length <= index) {
                throw parser("Unexpected end of thunk in IF expression");
            }
            const current = lines[index];
            index += 1;
            if (IF.test(current.content)) {
                const [thunk, consumed] = parseThunk(lines, index, (l)=>ELSEIF.test(l) || ELSE.test(l) || ENDIF.test(l));
                ifThunk.push([
                    current.slice("IF".length),
                    thunk
                ]);
                index += consumed;
            } else if (ELSEIF.test(current.content)) {
                const [thunk1, consumed1] = parseThunk(lines, index, (l)=>ELSEIF.test(l) || ELSE.test(l) || ENDIF.test(l));
                ifThunk.push([
                    current.slice("ELSEIF".length),
                    thunk1
                ]);
                index += consumed1;
            } else if (ELSE.test(current.content)) {
                const [thunk2, consumed2] = parseThunk(lines, index, (l)=>ENDIF.test(l));
                elseThunk = thunk2;
                index += consumed2;
            } else if (ENDIF.test(current.content)) {
                return [
                    new If1(ifThunk, elseThunk),
                    index - from
                ];
            } else {
                throw parser("Unexpected statement in IF expression");
            }
        }
    }
    ifThunk;
    elseThunk;
    constructor(ifThunk, elseThunk){
        super(ifThunk[0][0]);
        this.ifThunk = ifThunk.map(([raw, thunk])=>[
                raw,
                new Lazy(raw, PARSER136),
                thunk
            ]);
        this.elseThunk = elseThunk;
    }
    async *run(vm, label) {
        if (label != null) {
            for (const [, , thunk] of this.ifThunk){
                if (thunk.labelMap.has(label)) {
                    return yield* thunk.run(vm, label);
                }
            }
            if (this.elseThunk.labelMap.has(label)) {
                return yield* this.elseThunk.run(vm, label);
            }
        }
        for (const [, cond, thunk1] of this.ifThunk){
            const condValue = await cond.get().reduce(vm);
            bigint(condValue, "Condition should be an integer");
            if (condValue !== 0n) {
                return yield* thunk1.run(vm);
            }
        }
        return yield* this.elseThunk.run(vm);
    }
}
const CASEELSE = /^CASEELSE$/i;
const ENDSELECT = /^ENDSELECT$/i;
const PARSER_EXPR = arg1R1(expr);
const PARSER_BRANCH = argNR0(Hn1.alt(Hn1.seqMap(Int, Hn1.regex(/TO/i).trim(WS1).then(Int), (from, to)=>({
        type: "range",
        from: BigInt(from),
        to: BigInt(to)
    })), Hn1.seqMap(Hn1.regex(/IS/i).then(alt("<=", "<", ">=", ">").trim(WS0)), expr, (op, value)=>({
        type: "compare",
        op,
        value
    })), Int.map((value)=>({
        type: "equal",
        value: BigInt(value)
    })), Str.map((value)=>({
        type: "equal",
        value
    }))));
class Case extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        const branch = [];
        let def = new Thunk([]);
        while(true){
            if (lines.length <= index) {
                throw parser("Unexpected end of thunk in CASE expression");
            }
            const current = lines[index];
            index += 1;
            if (CASE.test(current.get())) {
                const [thunk, consumed] = parseThunk(lines, index, (l)=>CASE.test(l) || CASEELSE.test(l) || ENDSELECT.test(l));
                branch.push([
                    current.slice("CASE".length),
                    thunk
                ]);
                index += consumed;
            } else if (CASEELSE.test(current.get())) {
                const [thunk1, consumed1] = parseThunk(lines, index, (l)=>ENDSELECT.test(l));
                def = thunk1;
                index += consumed1;
            } else if (ENDSELECT.test(current.get())) {
                return [
                    new Case(arg, branch, def),
                    index - from
                ];
            } else {
                throw parser("Unexpected statement in CASE expression");
            }
        }
    }
    arg;
    branch;
    def;
    constructor(raw, branch, def){
        super(raw);
        this.arg = new Lazy(raw, PARSER_EXPR);
        this.branch = branch.map(([cond, thunk])=>[
                new Lazy(cond, PARSER_BRANCH),
                thunk
            ]);
        this.def = def;
    }
    async *run(vm, label) {
        if (label != null) {
            for (const [, thunk] of this.branch){
                if (thunk.labelMap.has(label)) {
                    return yield* thunk.run(vm, label);
                }
            }
        }
        const value = await this.arg.get().reduce(vm);
        for (const [cond, expr] of this.branch){
            const satisfied = cond.get().some((c)=>{
                switch(c.type){
                    case "equal":
                        return c.value === value;
                    case "range":
                        return c.from <= value && value <= c.to;
                    case "compare":
                        {
                            bigint(value, "CASE IS ... should be used for an integer value");
                            switch(c.op){
                                case "<":
                                    return value < c.value;
                                case "<=":
                                    return value <= c.value;
                                case ">":
                                    return value > c.value;
                                case ">=":
                                    return value >= c.value;
                            }
                        }
                }
            });
            if (satisfied) {
                return yield* expr.run(vm);
            }
        }
        return null;
    }
}
const PARSER137 = arg1R1(expr);
class Repeat extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        const [thunk, consumed] = parseThunk(lines, index, (l)=>REND.test(l));
        index += consumed + 1;
        return [
            new Repeat(arg, thunk),
            index - from
        ];
    }
    arg;
    thunk;
    constructor(raw, thunk){
        super(raw);
        this.arg = new Lazy(raw, PARSER137);
        this.thunk = thunk;
    }
    async *run(vm, label) {
        if (label != null) {
            if (this.thunk.labelMap.has(label)) {
                return yield* this.thunk.run(vm, label);
            }
        }
        const condition = await this.arg.get().reduce(vm);
        bigint(condition, "Condition for REPEAT should be an integer");
        loop: for(let i = 0n; i < condition; ++i){
            vm.getValue("COUNT").set(vm, i, []);
            const result = yield* this.thunk.run(vm);
            switch(result?.type){
                case "begin":
                    return result;
                case "goto":
                    return result;
                case "break":
                    break loop;
                case "continue":
                    continue loop;
                case "throw":
                    return result;
                case "return":
                    return result;
                case "quit":
                    return result;
                case undefined:
                    continue loop;
            }
        }
        return null;
    }
}
const PARSER138 = arg4R3(variable, expr, expr, expr);
class For extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        const [thunk, consumed] = parseThunk(lines, index, (l)=>NEXT.test(l));
        index += consumed + 1;
        return [
            new For(arg, thunk),
            index - from
        ];
    }
    arg;
    thunk;
    constructor(raw, thunk){
        super(raw);
        this.arg = new Lazy(raw, PARSER138);
        this.thunk = thunk;
    }
    async *run(vm, label) {
        if (label != null) {
            if (this.thunk.labelMap.has(label)) {
                return yield* this.thunk.run(vm, label);
            }
        }
        const [counter, startExpr, endExpr, stepExpr] = this.arg.get();
        const start = await startExpr.reduce(vm);
        bigint(start, "Starting value for FOR should be an integer");
        const end = await endExpr.reduce(vm);
        bigint(end, "Ending value for FOR should be an integer");
        const step = await stepExpr?.reduce(vm) ?? 1n;
        bigint(step, "Step of FOR should be an integer");
        const index = await counter.reduceIndex(vm);
        loop: for(let i = start; i < end; i += step){
            counter.getCell(vm).set(vm, i, index);
            const result = yield* this.thunk.run(vm);
            switch(result?.type){
                case "begin":
                    return result;
                case "goto":
                    return result;
                case "break":
                    break loop;
                case "continue":
                    continue loop;
                case "throw":
                    return result;
                case "return":
                    return result;
                case "quit":
                    return result;
                case undefined:
                    continue loop;
            }
        }
        return null;
    }
}
const PARSER139 = arg1R1(expr);
class While extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        const [thunk, consumed] = parseThunk(lines, index, (l)=>WEND.test(l));
        index += consumed + 1;
        return [
            new While(arg, thunk),
            index - from
        ];
    }
    arg;
    thunk;
    constructor(raw, thunk){
        super(raw);
        this.arg = new Lazy(raw, PARSER139);
        this.thunk = thunk;
    }
    async *run(vm, label) {
        let firstLoop = true;
        while(true){
            let result;
            if (firstLoop && label != null && this.thunk.labelMap.has(label)) {
                result = yield* this.thunk.run(vm, label);
            } else {
                const condition = await this.arg.get().reduce(vm);
                bigint(condition, "Condition of WHILE should be an integer");
                if (condition === 0n) {
                    break;
                }
                result = yield* this.thunk.run(vm);
            }
            firstLoop = false;
            switch(result?.type){
                case "begin":
                    return result;
                case "goto":
                    return result;
                case "break":
                    return null;
                case "continue":
                    continue;
                case "throw":
                    return result;
                case "return":
                    return result;
                case "quit":
                    return result;
                case undefined:
                    continue;
            }
        }
        return null;
    }
}
const PARSER_ARG1 = arg0R0();
const PARSER_COND = arg1R1(expr);
class DoWhile extends Statement {
    static parse(arg, lines, from) {
        let index = from + 1;
        tryParse(PARSER_ARG1, arg);
        const [thunk, consumed] = parseThunk(lines, index, (l)=>LOOP.test(l));
        index += consumed;
        const condition = lines[index].slice("LOOP".length);
        index += 1;
        return [
            new DoWhile(condition, thunk),
            index - from
        ];
    }
    arg;
    thunk;
    constructor(raw, thunk){
        super(raw);
        this.arg = new Lazy(raw, PARSER_COND);
        this.thunk = thunk;
    }
    async *run(vm, label) {
        let firstLoop = true;
        while(true){
            const result = yield* this.thunk.run(vm, firstLoop ? label : undefined);
            const condition = await this.arg.get().reduce(vm);
            bigint(condition, "Condition of DO should be an integer");
            if (condition === 0n) {
                break;
            }
            firstLoop = false;
            switch(result?.type){
                case "begin":
                    return result;
                case "goto":
                    return result;
                case "break":
                    return null;
                case "continue":
                    continue;
                case "throw":
                    return result;
                case "return":
                    return result;
                case "quit":
                    return result;
                case undefined:
                    continue;
            }
        }
        return null;
    }
}
const commandParser = {
    PRINT: (arg)=>[
            new Print([], arg),
            1
        ],
    PRINTL: (arg)=>[
            new Print([
                "L"
            ], arg),
            1
        ],
    PRINTW: (arg)=>[
            new Print([
                "W"
            ], arg),
            1
        ],
    PRINTK: (arg)=>[
            new Print([
                "K"
            ], arg),
            1
        ],
    PRINTKL: (arg)=>[
            new Print([
                "K",
                "L"
            ], arg),
            1
        ],
    PRINTKW: (arg)=>[
            new Print([
                "K",
                "W"
            ], arg),
            1
        ],
    PRINTD: (arg)=>[
            new Print([
                "D"
            ], arg),
            1
        ],
    PRINTDL: (arg)=>[
            new Print([
                "D",
                "L"
            ], arg),
            1
        ],
    PRINTDW: (arg)=>[
            new Print([
                "D",
                "W"
            ], arg),
            1
        ],
    PRINTV: (arg)=>[
            new PrintV([], arg),
            1
        ],
    PRINTVL: (arg)=>[
            new PrintV([
                "L"
            ], arg),
            1
        ],
    PRINTVW: (arg)=>[
            new PrintV([
                "W"
            ], arg),
            1
        ],
    PRINTVK: (arg)=>[
            new PrintV([
                "K"
            ], arg),
            1
        ],
    PRINTVKL: (arg)=>[
            new PrintV([
                "K",
                "L"
            ], arg),
            1
        ],
    PRINTVKW: (arg)=>[
            new PrintV([
                "K",
                "W"
            ], arg),
            1
        ],
    PRINTVD: (arg)=>[
            new PrintV([
                "D"
            ], arg),
            1
        ],
    PRINTVDL: (arg)=>[
            new PrintV([
                "D",
                "L"
            ], arg),
            1
        ],
    PRINTVDW: (arg)=>[
            new PrintV([
                "D",
                "W"
            ], arg),
            1
        ],
    PRINTS: (arg)=>[
            new PrintS([], arg),
            1
        ],
    PRINTSL: (arg)=>[
            new PrintS([
                "L"
            ], arg),
            1
        ],
    PRINTSW: (arg)=>[
            new PrintS([
                "W"
            ], arg),
            1
        ],
    PRINTSK: (arg)=>[
            new PrintS([
                "K"
            ], arg),
            1
        ],
    PRINTSKL: (arg)=>[
            new PrintS([
                "K",
                "L"
            ], arg),
            1
        ],
    PRINTSKW: (arg)=>[
            new PrintS([
                "K",
                "W"
            ], arg),
            1
        ],
    PRINTSD: (arg)=>[
            new PrintS([
                "D"
            ], arg),
            1
        ],
    PRINTSDL: (arg)=>[
            new PrintS([
                "D",
                "L"
            ], arg),
            1
        ],
    PRINTSDW: (arg)=>[
            new PrintS([
                "D",
                "W"
            ], arg),
            1
        ],
    PRINTFORM: (arg)=>[
            new PrintForm([], arg),
            1
        ],
    PRINTFORML: (arg)=>[
            new PrintForm([
                "L"
            ], arg),
            1
        ],
    PRINTFORMW: (arg)=>[
            new PrintForm([
                "W"
            ], arg),
            1
        ],
    PRINTFORMK: (arg)=>[
            new PrintForm([
                "K"
            ], arg),
            1
        ],
    PRINTFORMKL: (arg)=>[
            new PrintForm([
                "K",
                "L"
            ], arg),
            1
        ],
    PRINTFORMKW: (arg)=>[
            new PrintForm([
                "K",
                "W"
            ], arg),
            1
        ],
    PRINTFORMD: (arg)=>[
            new PrintForm([
                "D"
            ], arg),
            1
        ],
    PRINTFORMDL: (arg)=>[
            new PrintForm([
                "D",
                "L"
            ], arg),
            1
        ],
    PRINTFORMDW: (arg)=>[
            new PrintForm([
                "D",
                "W"
            ], arg),
            1
        ],
    PRINTFORMS: (arg)=>[
            new PrintFormS([], arg),
            1
        ],
    PRINTFORMSL: (arg)=>[
            new PrintFormS([
                "L"
            ], arg),
            1
        ],
    PRINTFORMSW: (arg)=>[
            new PrintFormS([
                "W"
            ], arg),
            1
        ],
    PRINTFORMSK: (arg)=>[
            new PrintFormS([
                "K"
            ], arg),
            1
        ],
    PRINTFORMSKL: (arg)=>[
            new PrintFormS([
                "K",
                "L"
            ], arg),
            1
        ],
    PRINTFORMSKW: (arg)=>[
            new PrintFormS([
                "K",
                "W"
            ], arg),
            1
        ],
    PRINTFORMSD: (arg)=>[
            new PrintFormS([
                "D"
            ], arg),
            1
        ],
    PRINTFORMSDL: (arg)=>[
            new PrintFormS([
                "D",
                "L"
            ], arg),
            1
        ],
    PRINTFORMSDW: (arg)=>[
            new PrintFormS([
                "D",
                "W"
            ], arg),
            1
        ],
    PRINTSINGLE: (arg)=>[
            new Print([
                "S"
            ], arg),
            1
        ],
    PRINTSINGLEK: (arg)=>[
            new Print([
                "S",
                "K"
            ], arg),
            1
        ],
    PRINTSINGLED: (arg)=>[
            new Print([
                "S",
                "D"
            ], arg),
            1
        ],
    PRINTSINGLEV: (arg)=>[
            new PrintV([
                "S"
            ], arg),
            1
        ],
    PRINTSINGLEVK: (arg)=>[
            new PrintV([
                "S",
                "K"
            ], arg),
            1
        ],
    PRINTSINGLEVD: (arg)=>[
            new PrintV([
                "S",
                "D"
            ], arg),
            1
        ],
    PRINTSINGLES: (arg)=>[
            new PrintS([
                "S"
            ], arg),
            1
        ],
    PRINTSINGLESK: (arg)=>[
            new PrintS([
                "S",
                "K"
            ], arg),
            1
        ],
    PRINTSINGLESD: (arg)=>[
            new PrintS([
                "S",
                "D"
            ], arg),
            1
        ],
    PRINTSINGLEFORM: (arg)=>[
            new PrintForm([
                "S"
            ], arg),
            1
        ],
    PRINTSINGLEFORMK: (arg)=>[
            new PrintForm([
                "S",
                "K"
            ], arg),
            1
        ],
    PRINTSINGLEFORMD: (arg)=>[
            new PrintForm([
                "S",
                "D"
            ], arg),
            1
        ],
    PRINTSINGLEFORMS: (arg)=>[
            new PrintFormS([
                "S"
            ], arg),
            1
        ],
    PRINTSINGLEFORMSK: (arg)=>[
            new PrintFormS([
                "S",
                "K"
            ], arg),
            1
        ],
    PRINTSINGLEFORMSD: (arg)=>[
            new PrintFormS([
                "S",
                "D"
            ], arg),
            1
        ],
    PRINTC: (arg)=>[
            new PrintC("RIGHT", [], arg),
            1
        ],
    PRINTCK: (arg)=>[
            new PrintC("RIGHT", [
                "K"
            ], arg),
            1
        ],
    PRINTCD: (arg)=>[
            new PrintC("RIGHT", [
                "D"
            ], arg),
            1
        ],
    PRINTLC: (arg)=>[
            new PrintC("LEFT", [], arg),
            1
        ],
    PRINTLCK: (arg)=>[
            new PrintC("LEFT", [
                "K"
            ], arg),
            1
        ],
    PRINTLCD: (arg)=>[
            new PrintC("LEFT", [
                "D"
            ], arg),
            1
        ],
    PRINTFORMC: (arg)=>[
            new PrintFormC("RIGHT", [], arg),
            1
        ],
    PRINTFORMCK: (arg)=>[
            new PrintFormC("RIGHT", [
                "K"
            ], arg),
            1
        ],
    PRINTFORMCD: (arg)=>[
            new PrintFormC("RIGHT", [
                "D"
            ], arg),
            1
        ],
    PRINTFORMLC: (arg)=>[
            new PrintFormC("LEFT", [], arg),
            1
        ],
    PRINTFORMLCK: (arg)=>[
            new PrintFormC("LEFT", [
                "K"
            ], arg),
            1
        ],
    PRINTFORMLCD: (arg)=>[
            new PrintFormC("LEFT", [
                "D"
            ], arg),
            1
        ],
    PRINTBUTTON: (arg)=>[
            new PrintButton(arg),
            1
        ],
    PRINTBUTTONC: (arg)=>[
            new PrintButton(arg, "RIGHT"),
            1
        ],
    PRINTBUTTONLC: (arg)=>[
            new PrintButton(arg, "LEFT"),
            1
        ],
    PRINTPLAIN: (arg)=>[
            new PrintPlain(null, arg),
            1
        ],
    PRINTPLAINFORM: (arg)=>[
            new PrintPlain("FORM", arg),
            1
        ],
    PRINT_PALAM: (arg)=>[
            new PrintPalam(arg),
            1
        ],
    PRINT_SHOPITEM: (arg)=>[
            new PrintShopItem(arg),
            1
        ],
    TIMES: (arg)=>[
            new Times(arg),
            1
        ],
    DRAWLINE: (arg)=>[
            new DrawLine(arg),
            1
        ],
    CUSTOMDRAWLINE: (arg)=>[
            new CustomDrawLine(arg),
            1
        ],
    DRAWLINEFORM: (arg)=>[
            new DrawLineForm(arg),
            1
        ],
    REUSELASTLINE: (arg)=>[
            new ReuseLastLine(arg),
            1
        ],
    CLEARLINE: (arg)=>[
            new ClearLine(arg),
            1
        ],
    RESETCOLOR: (arg)=>[
            new ResetColor(arg),
            1
        ],
    RESETBGCOLOR: (arg)=>[
            new ResetBgColor(arg),
            1
        ],
    SETCOLOR: (arg)=>[
            new SetColor(arg),
            1
        ],
    SETBGCOLOR: (arg)=>[
            new SetBgColor(arg),
            1
        ],
    SETCOLORBYNAME: (arg)=>[
            new SetColorByName(arg),
            1
        ],
    SETBGCOLORBYNAME: (arg)=>[
            new SetBgColorByName(arg),
            1
        ],
    GETCOLOR: (arg)=>[
            new Method("GETCOLOR", arg),
            1
        ],
    GETDEFCOLOR: (arg)=>[
            new Method("GETDEFCOLOR", arg),
            1
        ],
    GETBGCOLOR: (arg)=>[
            new Method("GETBGCOLOR", arg),
            1
        ],
    GETDEFBGCOLOR: (arg)=>[
            new Method("GETDEFBGCOLOR", arg),
            1
        ],
    GETFOCUSCOLOR: (arg)=>[
            new Method("GETFOCUSCOLOR", arg),
            1
        ],
    FONTBOLD: (arg)=>[
            new FontBold(arg),
            1
        ],
    FONTITALIC: (arg)=>[
            new FontItalic(arg),
            1
        ],
    FONTREGULAR: (arg)=>[
            new FontRegular(arg),
            1
        ],
    FONTSTYLE: (arg)=>[
            new FontStyle(arg),
            1
        ],
    GETSTYLE: (arg)=>[
            new GetStyle(arg),
            1
        ],
    CHKFONT: (arg)=>[
            new ChkFont(arg),
            1
        ],
    SETFONT: (arg)=>[
            new SetFont(arg),
            1
        ],
    GETFONT: (arg)=>[
            new GetFont(arg),
            1
        ],
    ALIGNMENT: (arg)=>[
            new Alignment(arg),
            1
        ],
    CURRENTALIGN: (arg)=>[
            new CurrentAlign(arg),
            1
        ],
    REDRAW: (arg)=>[
            new Redraw(arg),
            1
        ],
    CURRENTREDRAW: (arg)=>[
            new CurrentRedraw(arg),
            1
        ],
    PRINTCPERLINE: (arg)=>[
            new PrintCPerLine(arg),
            1
        ],
    LINEISEMPTY: (arg)=>[
            new Method("LINEISEMPTY", arg),
            1
        ],
    SKIPDISP: (arg)=>[
            new SkipDisp(arg),
            1
        ],
    BAR: (arg)=>[
            new Bar(arg),
            1
        ],
    BARL: (arg)=>[
            new Bar(arg, true),
            1
        ],
    BARSTR: (arg)=>[
            new Method("BARSTR", arg),
            1
        ],
    ISSKIP: (arg)=>[
            new IsSkip(arg),
            1
        ],
    MOUSESKIP: (arg)=>[
            new MouseSkip(arg),
            1
        ],
    STRLEN: (arg)=>[
            new StrLen(arg),
            1
        ],
    STRLENS: (arg)=>[
            new Method("STRLENS", arg),
            1
        ],
    STRLENFORM: (arg)=>[
            new StrLenForm(arg),
            1
        ],
    STRLENU: (arg)=>[
            new StrLen1(arg),
            1
        ],
    STRLENSU: (arg)=>[
            new Method("STRLENSU", arg),
            1
        ],
    STRLENFORMU: (arg)=>[
            new StrLenFormU(arg),
            1
        ],
    SUBSTRING: (arg)=>[
            new Substring(arg),
            1
        ],
    SUBSTRINGU: (arg)=>[
            new SubstringU(arg),
            1
        ],
    STRFIND: (arg)=>[
            new StrFind(arg),
            1
        ],
    STRFINDU: (arg)=>[
            new StrFindU(arg),
            1
        ],
    SPLIT: (arg)=>[
            new Split(arg),
            1
        ],
    ESCAPE: (arg)=>[
            new Escape(arg),
            1
        ],
    UNICODE: (arg)=>[
            new Method("UNICODE", arg),
            1
        ],
    ENCODETOUNI: (arg)=>[
            new EncodeToUni(arg),
            1
        ],
    POWER: (arg)=>[
            new Method("POWER", arg),
            1
        ],
    ABS: (arg)=>[
            new Method("ABS", arg),
            1
        ],
    SIGN: (arg)=>[
            new Method("SIGN", arg),
            1
        ],
    SQRT: (arg)=>[
            new Method("SQRT", arg),
            1
        ],
    MAX: (arg)=>[
            new Method("MAX", arg),
            1
        ],
    MIN: (arg)=>[
            new Method("MIN", arg),
            1
        ],
    LIMIT: (arg)=>[
            new Method("LIMIT", arg),
            1
        ],
    INRANGE: (arg)=>[
            new Method("INRANGE", arg),
            1
        ],
    GETBIT: (arg)=>[
            new Method("GETBIT", arg),
            1
        ],
    SETBIT: (arg)=>[
            new SetBit(arg),
            1
        ],
    CLEARBIT: (arg)=>[
            new ClearBit(arg),
            1
        ],
    INVERTBIT: (arg)=>[
            new InvertBit(arg),
            1
        ],
    ADDCHARA: (arg)=>[
            new AddChara(arg),
            1
        ],
    ADDDEFCHARA: (arg)=>[
            new AddDefChara(arg),
            1
        ],
    ADDVOIDCHARA: (arg)=>[
            new AddVoidChara(arg),
            1
        ],
    DELCHARA: (arg)=>[
            new DelChara(arg),
            1
        ],
    DELALLCHARA: (arg)=>[
            new DelAllChara(arg),
            1
        ],
    GETCHARA: (arg)=>[
            new Method("GETCHARA", arg),
            1
        ],
    SWAPCHARA: (arg)=>[
            new SwapChara(arg),
            1
        ],
    SORTCHARA: (arg)=>[
            new SortChara(arg),
            1
        ],
    PICKUPCHARA: (arg)=>[
            new PickupChara(arg),
            1
        ],
    FINDCHARA: (arg)=>[
            new Method("FINDCHARA", arg),
            1
        ],
    FINDLASTCHARA: (arg)=>[
            new Method("FINDLASTCHARA", arg),
            1
        ],
    COPYCHARA: (arg)=>[
            new CopyChara(arg),
            1
        ],
    ADDCOPYCHARA: (arg)=>[
            new AddCopyChara(arg),
            1
        ],
    EXISTCSV: (arg)=>[
            new Method("EXISTCSV", arg),
            1
        ],
    SWAP: (arg)=>[
            new Swap(arg),
            1
        ],
    RESETDATA: (arg)=>[
            new ResetData(arg),
            1
        ],
    RESETGLOBAL: (arg)=>[
            new ResetGlobal(arg),
            1
        ],
    RESET_STAIN: (arg)=>[
            new ResetStain(arg),
            1
        ],
    CSVABL: (arg)=>[
            new Method("CSVABL", arg),
            1
        ],
    CSVBASE: (arg)=>[
            new Method("CSVBASE", arg),
            1
        ],
    CSVCALLNAME: (arg)=>[
            new Method("CSVCALLNAME", arg),
            1
        ],
    CSVCFLAG: (arg)=>[
            new Method("CSVCFLAG", arg),
            1
        ],
    CSVCSTR: (arg)=>[
            new Method("CSVCSTR", arg),
            1
        ],
    CSVEQUIP: (arg)=>[
            new Method("CSVEQUIP", arg),
            1
        ],
    CSVEXP: (arg)=>[
            new Method("CSVEXP", arg),
            1
        ],
    CSVJUEL: (arg)=>[
            new Method("CSVJUEL", arg),
            1
        ],
    CSVMARK: (arg)=>[
            new Method("CSVMARK", arg),
            1
        ],
    CSVMASTERNAME: (arg)=>[
            new Method("CSVMASTERNAME", arg),
            1
        ],
    CSVNAME: (arg)=>[
            new Method("CSVNAM", arg),
            1
        ],
    CSVNICKNAME: (arg)=>[
            new Method("CSVNICKNAME", arg),
            1
        ],
    CSVRELATION: (arg)=>[
            new Method("CSVRELATION", arg),
            1
        ],
    CSVTALENT: (arg)=>[
            new Method("CSVTALENT", arg),
            1
        ],
    GETPALAMLV: (arg)=>[
            new GetPalamLv(arg),
            1
        ],
    GETEXPLV: (arg)=>[
            new GetExpLv(arg),
            1
        ],
    VARSET: (arg)=>[
            new VarSet1(arg),
            1
        ],
    CVARSET: (arg)=>[
            new VarSet(arg),
            1
        ],
    ARRAYSHIFT: (arg)=>[
            new ArrayShift(arg),
            1
        ],
    ARRAYREMOVE: (arg)=>[
            new ArrayRemove(arg),
            1
        ],
    UPCHECK: (arg)=>[
            new UpCheck(arg),
            1
        ],
    CUPCHECK: (arg)=>[
            new CUpCheck(arg),
            1
        ],
    PUTFORM: (arg)=>[
            new PutForm(arg),
            1
        ],
    SAVEGAME: (arg)=>[
            new SaveGame(arg),
            1
        ],
    LOADGAME: (arg)=>[
            new LoadGame(arg),
            1
        ],
    SAVEDATA: (arg)=>[
            new SaveData(arg),
            1
        ],
    LOADDATA: (arg)=>[
            new LoadData(arg),
            1
        ],
    DELDATA: (arg)=>[
            new DelData(arg),
            1
        ],
    CHKDATA: (arg)=>[
            new ChkData(arg),
            1
        ],
    SAVEGLOBAL: (arg)=>[
            new SaveGlobal(arg),
            1
        ],
    LOADGLOBAL: (arg)=>[
            new LoadGlobal(arg),
            1
        ],
    OUTPUTLOG: (arg)=>[
            new OutputLog(arg),
            1
        ],
    GETTIME: (arg)=>[
            new GetTime(arg),
            1
        ],
    GETMILLISECOND: (arg)=>[
            new GetMillisecond(arg),
            1
        ],
    GETSECOND: (arg)=>[
            new GetSecond(arg),
            1
        ],
    FORCEWAIT: (arg)=>[
            new ForceWait(arg),
            1
        ],
    INPUT: (arg)=>[
            new Input(arg),
            1
        ],
    INPUTS: (arg)=>[
            new InputS(arg),
            1
        ],
    TINPUT: (arg)=>[
            new TInput(arg),
            1
        ],
    TINPUTS: (arg)=>[
            new TInputS(arg),
            1
        ],
    ONEINPUT: (arg)=>[
            new OneInput(arg),
            1
        ],
    ONEINPUTS: (arg)=>[
            new OneInputS(arg),
            1
        ],
    TONEINPUT: (arg)=>[
            new TOneInput(arg),
            1
        ],
    TONEINPUTS: (arg)=>[
            new TOneInputS(arg),
            1
        ],
    WAIT: (arg)=>[
            new Wait(arg),
            1
        ],
    WAITANYKEY: (arg)=>[
            new WaitAnyKey(arg),
            1
        ],
    BREAK: (arg)=>[
            new Break(arg),
            1
        ],
    CONTINUE: (arg)=>[
            new Continue(arg),
            1
        ],
    RANDOMIZE: (arg)=>[
            new Randomize(arg),
            1
        ],
    DUMPRAND: (arg)=>[
            new DumpRand(arg),
            1
        ],
    INITRAND: (arg)=>[
            new InitRand(arg),
            1
        ],
    BEGIN: (arg)=>[
            new Begin(arg),
            1
        ],
    CALLTRAIN: (arg)=>[
            new CallTrain(arg),
            1
        ],
    THROW: (arg)=>[
            new Throw(arg),
            1
        ],
    QUIT: (arg)=>[
            new Quit(arg),
            1
        ],
    CALL: (arg)=>[
            new Call(arg),
            1
        ],
    CALLFORM: (arg)=>[
            new CallForm(arg),
            1
        ],
    CALLF: (arg)=>[
            new CallF(arg),
            1
        ],
    CALLFORMF: (arg)=>[
            new CallFormF(arg),
            1
        ],
    TRYCALL: (arg)=>[
            new TryCall(arg),
            1
        ],
    TRYCALLFORM: (arg)=>[
            new TryCallForm(arg),
            1
        ],
    TRYCCALL: (arg, lines, from)=>TryCCall.parse(arg, lines, from),
    TRYCCALLFORM: (arg, lines, from)=>TryCCallForm.parse(arg, lines, from),
    JUMP: (arg)=>[
            new Jump(arg),
            1
        ],
    JUMPFORM: (arg)=>[
            new JumpForm(arg),
            1
        ],
    TRYJUMP: (arg)=>[
            new TryJump(arg),
            1
        ],
    TRYJUMPFORM: (arg)=>[
            new TryJumpForm(arg),
            1
        ],
    TRYCJUMP: (arg, lines, from)=>TryCJump.parse(arg, lines, from),
    TRYCJUMPFORM: (arg, lines, from)=>TryCJumpForm.parse(arg, lines, from),
    GOTO: (arg)=>[
            new Goto(arg),
            1
        ],
    GOTOFORM: (arg)=>[
            new GotoForm(arg),
            1
        ],
    TRYGOTO: (arg)=>[
            new TryGoto(arg),
            1
        ],
    TRYGOTOFORM: (arg)=>[
            new TryGotoForm(arg),
            1
        ],
    TRYCGOTO: (arg, lines, from)=>TryCGoto.parse(arg, lines, from),
    TRYCGOTOFORM: (arg, lines, from)=>TryCGotoForm.parse(arg, lines, from),
    RESTART: (arg)=>[
            new Restart(arg),
            1
        ],
    RETURN: (arg)=>[
            new Return(arg),
            1
        ],
    RETURNF: (arg)=>[
            new ReturnF(arg),
            1
        ],
    DEBUGPRINT: (arg)=>[
            new DebugPrint([], arg),
            1
        ],
    DEBUGPRINTL: (arg)=>[
            new DebugPrint([
                "L"
            ], arg),
            1
        ],
    DEBUGPRINTFORM: (arg)=>[
            new DebugPrintForm([], arg),
            1
        ],
    DEBUGPRINTFORML: (arg)=>[
            new DebugPrintForm([
                "L"
            ], arg),
            1
        ],
    DEBUGCLEAR: (arg)=>[
            new DebugClear(arg),
            1
        ],
    MOUSEX: (arg)=>[
            new MouseX(arg),
            1
        ],
    MOUSEY: (arg)=>[
            new MouseY(arg),
            1
        ],
    ISACTIVE: (arg)=>[
            new IsActive(arg),
            1
        ],
    CBGCLEAR: (arg)=>[
            new CbgClear(arg),
            1
        ],
    CBGCLEARBUTTON: (arg)=>[
            new CbgClearButton(arg),
            1
        ],
    CBGREMOVEBMAP: (arg)=>[
            new CbgRemoveBmap(arg),
            1
        ],
    CLEARTEXTBOX: (arg)=>[
            new ClearTextBox(arg),
            1
        ],
    STRDATA: (_arg, lines, from)=>StrData.parse(lines, from),
    STOPCALLTRAIN: (arg)=>[
            new StopCallTrain(arg),
            1
        ],
    PRINTDATA: (_arg, lines, from)=>PrintData.parse([], lines, from),
    PRINTDATAL: (_arg, lines, from)=>PrintData.parse([
            "L"
        ], lines, from),
    PRINTDATAW: (_arg, lines, from)=>PrintData.parse([
            "W"
        ], lines, from),
    PRINTDATAK: (_arg, lines, from)=>PrintData.parse([
            "K"
        ], lines, from),
    PRINTDATAKL: (_arg, lines, from)=>PrintData.parse([
            "K",
            "L"
        ], lines, from),
    PRINTDATAKW: (_arg, lines, from)=>PrintData.parse([
            "K",
            "W"
        ], lines, from),
    PRINTDATAD: (_arg, lines, from)=>PrintData.parse([
            "D"
        ], lines, from),
    PRINTDATADL: (_arg, lines, from)=>PrintData.parse([
            "D",
            "L"
        ], lines, from),
    PRINTDATADW: (_arg, lines, from)=>PrintData.parse([
            "D",
            "W"
        ], lines, from),
    SIF: (arg, lines, from)=>{
        const [statement, consumed] = parseStatement(lines, from + 1);
        return [
            new If1([
                [
                    arg,
                    new Thunk([
                        statement
                    ])
                ]
            ], new Thunk([])),
            consumed + 1
        ];
    },
    IF: (_arg, lines, from)=>If1.parse(lines, from),
    SELECTCASE: (arg, lines, from)=>Case.parse(arg, lines, from),
    REPEAT: (arg, lines, from)=>Repeat.parse(arg, lines, from),
    FOR: (arg, lines, from)=>For.parse(arg, lines, from),
    WHILE: (arg, lines, from)=>While.parse(arg, lines, from),
    DO: (arg, lines, from)=>DoWhile.parse(arg, lines, from)
};
function parseERH(files, macros) {
    const result = [];
    for (const [name, content] of files){
        const normalized = normalize(content);
        const lines = preprocess(toLines(normalized), macros);
        for (const line of lines){
            line.file = name;
        }
        for (const line1 of lines){
            result.push(tryParse(parser1, line1));
        }
    }
    return result;
}
const nonButton = Hn1.noneOf("[").many().tie();
const coreButton = Hn1.regex(/\[\s*[0-9]+\s*\]/);
const buttonParser = Hn1.alt(Hn1.seqMap(coreButton, optional(nonButton), (core, text)=>[
        core,
        core + (text ?? "")
    ]).many().skip(Hn1.eof), Hn1.seqMap(optional(nonButton), coreButton, (text, core)=>[
        core,
        (text ?? "") + core
    ]).many().skip(Hn1.eof), Hn1.seqMap(Hn1.seqMap(nonButton, coreButton, optional(nonButton), (left, core, right)=>[
        core,
        left + core + (right ?? "")
    ]), Hn1.seqMap(coreButton, optional(nonButton), (core, text)=>[
        core,
        core + (text ?? "")
    ]).many(), (first, rest)=>[
        first,
        ...rest
    ]).skip(Hn1.eof));
class Printer {
    buffer;
    chunks;
    align;
    font;
    defaultBackground;
    defaultColor;
    background;
    color;
    focus;
    lineCount;
    draw;
    skipDisp;
    isLineTemp;
    constructor(){
        this.buffer = [];
        this.chunks = [];
        this.align = "LEFT";
        this.font = {
            name: "",
            bold: false,
            italic: false,
            strike: false,
            underline: false
        };
        this.defaultBackground = "000000";
        this.defaultColor = "FFFFFF";
        this.background = this.defaultBackground;
        this.color = this.defaultColor;
        this.focus = "FFFF00";
        this.lineCount = 0;
        this.draw = true;
        this.skipDisp = false;
        this.isLineTemp = false;
    }
    async *clearTemp() {
        if (this.isLineTemp) {
            this.buffer.push({
                type: "clear",
                count: 1
            });
            this.isLineTemp = false;
        }
    }
    async *flush() {
        for (const output of this.buffer){
            yield output;
        }
        this.buffer = [];
    }
    async *newline() {
        if (this.isLineTemp) {
            this.buffer.push({
                type: "clear",
                count: 1
            });
            this.lineCount -= 1;
        }
        const merged = [];
        if (this.chunks.length > 0) {
            merged.push(this.chunks[0]);
            for(let i = 1; i < this.chunks.length; ++i){
                const chunk = this.chunks[i];
                const lastChunk = merged[merged.length - 1];
                if (chunk.type === "string" && lastChunk.type === "string" && chunk.cell == null && lastChunk.cell == null && chunk.style.font === lastChunk.style.font && chunk.style.color === lastChunk.style.color && chunk.style.bold === lastChunk.style.bold && chunk.style.italic === lastChunk.style.italic && chunk.style.underline === lastChunk.style.underline && chunk.style.strike === lastChunk.style.strike) {
                    lastChunk.text += chunk.text;
                } else {
                    merged.push(chunk);
                }
            }
        }
        const normalized = [];
        for (const chunk1 of merged){
            if (chunk1.type === "string") {
                const parsed = buttonParser.parse(chunk1.text);
                if (parsed.status && parsed.value.length > 0) {
                    for (const [core, text] of parsed.value){
                        const valueMatch = /\[\s*(?<value>[0-9]+)\s*\]/.exec(core);
                        normalized.push({
                            type: "button",
                            text,
                            value: valueMatch.groups.value,
                            cell: chunk1.cell,
                            style: {
                                ...chunk1.style
                            }
                        });
                    }
                } else {
                    normalized.push(chunk1);
                }
            } else {
                normalized.push(chunk1);
            }
        }
        this.buffer.push({
            type: "content",
            align: this.align,
            children: normalized
        });
        this.chunks = [];
        this.lineCount += 1;
        this.isLineTemp = false;
        if (this.draw) {
            yield* this.flush();
        }
    }
    async *print(text, flags, cell) {
        yield* this.clearTemp();
        if (flags.has("S") && this.chunks.length > 0) {
            yield* this.newline();
        }
        if (text.length > 0) {
            this.chunks.push({
                type: "string",
                text,
                cell,
                style: {
                    color: this.color,
                    focus: this.focus,
                    font: this.font.name,
                    bold: this.font.bold,
                    italic: this.font.italic,
                    strike: this.font.strike,
                    underline: this.font.underline
                }
            });
        }
        if (flags.has("S") || flags.has("L") || flags.has("W")) {
            yield* this.newline();
        }
        if (flags.has("W")) {
            yield* this.wait(false);
        }
        if (this.draw) {
            yield* this.flush();
        }
    }
    async *button(text, value, cell) {
        yield* this.clearTemp();
        this.chunks.push({
            type: "button",
            text,
            value,
            cell,
            style: {
                color: this.color,
                focus: this.focus,
                font: this.font.name,
                bold: this.font.bold,
                italic: this.font.italic,
                strike: this.font.strike,
                underline: this.font.underline
            }
        });
        if (this.draw) {
            yield* this.flush();
        }
    }
    async *line(value) {
        yield* this.clearTemp();
        this.buffer.push({
            type: "line",
            value
        });
        if (this.draw) {
            yield* this.flush();
        }
        this.lineCount += 1;
    }
    async *clear(count) {
        if (count > 0) {
            this.buffer.push({
                type: "clear",
                count
            });
            this.lineCount = Math.max(0, this.lineCount - count);
            this.isLineTemp = false;
        }
        if (this.draw) {
            yield* this.flush();
        }
    }
    async *wait(force) {
        yield* this.flush();
        if (this.chunks.length > 0) {
            yield* this.newline();
        }
        yield {
            type: "wait",
            force
        };
    }
    async *input(numeric, nullable) {
        yield* this.flush();
        if (this.chunks.length > 0) {
            yield* this.newline();
        }
        return yield {
            type: "input",
            numeric,
            nullable
        };
    }
    async *tinput(numeric, timeout, countdown) {
        yield* this.flush();
        if (this.chunks.length > 0) {
            yield* this.newline();
        }
        return yield {
            type: "tinput",
            numeric,
            timeout,
            countdown
        };
    }
}
class PRNG {
    state;
    constructor(){
        this.state = Math.floor(Math.random() * 2 ** 32);
    }
    next() {
        this.state += 0x6D2B79F5;
        let z = this.state;
        z = Math.imul(z ^ z >>> 15, z | 1);
        z ^= z + Math.imul(z ^ z >>> 7, z | 61);
        return (z ^ z >>> 14) >>> 0;
    }
}
const FILE = "BUILTIN.ERB";
async function* runScene(vm, scene) {
    const generator = scene();
    while(true){
        const next = generator.next();
        if (next.done === true) {
            return null;
        }
        const result = yield* vm.run(next.value);
        if (result != null && result.type !== "return") {
            return result;
        }
    }
}
function* eventStatement(vm, target) {
    for (const fn of vm.eventMap.get(target) ?? []){
        yield {
            raw: new Slice(FILE, 0, "CALL " + target, "CALL".length),
            run: async function*() {
                return yield* fn.run(vm, []);
            }
        };
    }
}
function* MAIN() {
    while(true){
        yield new Call(new Slice(FILE, 0, "CALL SHOW_SHOP", "CALL".length));
        yield new Input(new Slice(FILE, 0, "INPUT", "INPUT".length));
        yield new Call(new Slice(FILE, 0, "CALL USERSHOP", "CALL".length));
    }
}
async function* SHOP(vm) {
    return yield* runScene(vm, function*() {
        yield* eventStatement(vm, "EVENTSHOP");
        if (vm.fnMap.has("SYSTEM_AUTOSAVE")) {
            yield new Call(new Slice(FILE, 0, "CALL SYSTEM_AUTOSAVE", "CALL".length));
        } else {
            const now = st1(vm.external.getTime());
            vm.getValue("SAVEDATA_TEXT").set(vm, now.format("YYYY/MM/DD HH:mm:ss"), []);
            yield new Call(new Slice(FILE, 0, "CALL SAVEINFO", "CALL".length));
            yield new SaveData(new Slice(FILE, 0, "SAVEDATA 99 SAVEDATA_TEXT"));
        }
        yield* MAIN();
    });
}
async function* TRAIN(vm) {
    return yield* runScene(vm, function*() {
        vm.getValue("ASSIPLAY").set(vm, 0n, []);
        vm.getValue("PREVCOM").set(vm, -1n, []);
        vm.getValue("NEXTCOM").set(vm, -1n, []);
        vm.getValue("TFLAG").reset([]);
        vm.getValue("TSTR").reset([]);
        for (const character of vm.characterList){
            character.getValue("GOTJUEL").reset([]);
            character.getValue("TEQUIP").reset([]);
            character.getValue("EX").reset([]);
            character.getValue("STAIN").reset([
                0,
                0,
                2,
                1,
                8
            ]);
            character.getValue("PALAM").reset([]);
            character.getValue("SOURCE").reset([]);
            character.getValue("TCVAR").reset([]);
        }
        yield* eventStatement(vm, "EVENTTRAIN");
        while(true){
            const nextCom = vm.getValue("NEXTCOM").get(vm, []);
            if (nextCom >= 0) {
                vm.getValue("SELECTCOM").set(vm, nextCom, []);
                vm.getValue("NEXTCOM").set(vm, 0n, []);
            } else {
                const comAble = new Set();
                yield new Call(new Slice(FILE, 0, "CALL SHOW_STATUS", "CALL".length));
                const trainIds = [
                    ...vm.code.csv.train.keys()
                ];
                trainIds.sort((a, b)=>a - b);
                for(let i = 0; i < trainIds.length; ++i){
                    const id = trainIds[i];
                    vm.getValue("RESULT").set(vm, 1n, []);
                    if (vm.fnMap.has(`COM_ABLE${id}`)) {
                        yield new Call(new Slice(FILE, 0, `CALL COM_ABLE${id}`, "CALL".length));
                    }
                    if (vm.getValue("RESULT").get(vm, []) !== 0n) {
                        comAble.add(id);
                        const name = vm.code.csv.train.get(id);
                        const idString = id.toString().padStart(3, " ");
                        yield new PrintC("RIGHT", [], new Slice(FILE, 0, `PRINTC ${name}[${idString}]`, "PRINTC".length));
                        if (i % vm.printCPerLine === 0) {
                            yield new Print([
                                "L"
                            ], new Slice(FILE, 0, "PRINTL", "PRINTL".length));
                        }
                    }
                }
                yield new Call(new Slice(FILE, 0, "CALL SHOW_USERCOM", "CALL".length));
                yield new Input(new Slice(FILE, 0, "INPUT", "INPUT".length));
                const input = vm.getValue("RESULT").get(vm, [
                    0
                ]);
                if (comAble.has(Number(input))) {
                    vm.getValue("SELECTCOM").set(vm, input, []);
                } else {
                    vm.getValue("SELECTCOM").set(vm, -1n, []);
                }
            }
            while(true){
                let wait = false;
                const selectCom = vm.getValue("SELECTCOM").get(vm, []);
                if (selectCom >= 0) {
                    for (const character1 of vm.characterList){
                        character1.getValue("NOWEX").reset([]);
                    }
                    yield* eventStatement(vm, "EVENTCOM");
                    yield new Call(new Slice(FILE, 0, `CALL COM${selectCom}`, "CALL".length));
                    if (vm.getValue("RESULT").get(vm, [
                        0
                    ]) !== 0n) {
                        wait = true;
                        yield new Call(new Slice(FILE, 0, "CALL SOURCE_CHECK", "CALL".length));
                        for (const character2 of vm.characterList){
                            character2.getValue("SOURCE").reset([]);
                        }
                        yield* eventStatement(vm, "EVENTCOMEND");
                    }
                } else {
                    yield new Call(new Slice(FILE, 0, "CALL USERCOM", "CALL".length));
                }
                if (wait) {
                    yield new Wait(new Slice(FILE, 0, "WAIT", "WAIT".length));
                }
                break;
            }
        }
    });
}
async function* AFTERTRAIN(vm) {
    return yield* runScene(vm, function*() {
        vm.printer.skipDisp = false;
        yield* eventStatement(vm, "EVENTEND");
    });
}
async function* ABLUP(vm) {
    return yield* runScene(vm, function*() {
        while(true){
            vm.printer.skipDisp = false;
            yield new Call(new Slice(FILE, 0, "CALL SHOW_JUEL", "CALL".length));
            yield new Call(new Slice(FILE, 0, "CALL SHOW_ABLUP_SELECT", "CALL".length));
            yield new Input(new Slice(FILE, 0, "INPUT", "INPUT".length));
            const input = vm.getValue("RESULT").get(vm, []);
            if (input >= 0 && input < 100) {
                yield new TryCall(new Slice(FILE, 0, `TRYCALL ABLUP${input}`, "TRYCALL".length));
            } else {
                yield new Call(new Slice(FILE, 0, "CALL USERABLUP", "CALL".length));
            }
        }
    });
}
async function* TURNEND(vm) {
    return yield* runScene(vm, function*() {
        vm.printer.skipDisp = false;
        yield* eventStatement(vm, "EVENTTURNEND");
    });
}
async function* FIRST(vm) {
    return yield* runScene(vm, function*() {
        yield* eventStatement(vm, "EVENTFIRST");
    });
}
async function* TITLE(vm) {
    return yield* runScene(vm, function*() {
        yield new Call(new Slice(FILE, 0, "CALL SYSTEM_TITLE", "CALL".length));
    });
}
async function* DATALOADED(vm) {
    return yield* runScene(vm, function*() {
        yield new TryCall(new Slice(FILE, 0, "TRYCALL SYSTEM_LOADEND", "TRYCALL".length));
        yield* eventStatement(vm, "EVENTLOAD");
        yield* MAIN();
    });
}
class CharaNumValue {
    type = "number";
    name = "CHARANUM";
    value;
    constructor(){}
    reset() {
        throw internal(`${this.name} cannot be reset`);
    }
    get(vm, index) {
        cond(index.length === 0, "CHARANUM cannot be indexed");
        return BigInt(vm.characterList.length);
    }
    set(_vm, _value, _index) {
        throw new Error(`Cannot assign a value to ${this.name}`);
    }
    rangeSet(_vm, _value, _index, _range) {
        throw new Error(`Cannot assign a value to ${this.name}`);
    }
    length(depth) {
        switch(depth){
            case 0:
                return 1;
            default:
                throw new Error(`${this.name} doesn't have a value at depth ${depth}`);
        }
    }
}
class LineCountValue {
    type = "number";
    name = "LINECOUNT";
    value;
    constructor(){}
    reset() {
        throw internal(`${this.name} cannot be reset`);
    }
    get(vm, index) {
        cond(index.length === 0, "LINECOUNT cannot be indexed");
        return BigInt(vm.printer.lineCount);
    }
    set(_vm, _value, _index) {
        throw new Error(`Cannot assign a value to ${this.name}`);
    }
    rangeSet(_vm, _value, _index, _range) {
        throw new Error(`Cannot assign a value to ${this.name}`);
    }
    length(depth) {
        switch(depth){
            case 0:
                return 1;
            default:
                throw new Error(`${this.name} doesn't have a value at depth ${depth}`);
        }
    }
}
class RandValue {
    type = "number";
    name = "RAND";
    value;
    constructor(){}
    reset() {
        throw internal(`${this.name} cannot be reset`);
    }
    get(vm, index) {
        cond(index.length === 1, "RAND must be indexed by 1 value");
        return BigInt(Math.floor(vm.random.next() % index[0]));
    }
    set(_vm, _value, _index) {
        throw new Error("Cannot assign a value to RAND");
    }
    rangeSet(_vm, _value, _index, _range) {
        throw new Error("Cannot assign a value to RAND");
    }
    length(_depth) {
        throw new Error("Cannot get the length of RAND");
    }
}
const valueList = [
    [
        "DAY",
        Int1DValue
    ],
    [
        "MONEY",
        Int1DValue
    ],
    [
        "ITEM",
        Int1DValue
    ],
    [
        "FLAG",
        Int1DValue,
        [
            10000
        ],
        [
            "FLAG",
            "FLAGNAME"
        ]
    ],
    [
        "TFLAG",
        Int1DValue,
        [
            1000
        ],
        [
            "TFLAG",
            "TFLAGNAME"
        ]
    ],
    [
        "UP",
        Int1DValue
    ],
    [
        "PALAMLV",
        Int1DValue
    ],
    [
        "EXPLV",
        Int1DValue
    ],
    [
        "EJAC",
        Int1DValue
    ],
    [
        "DOWN",
        Int1DValue
    ],
    [
        "RESULT",
        Int1DValue
    ],
    [
        "COUNT",
        Int1DValue
    ],
    [
        "TARGET",
        Int1DValue
    ],
    [
        "ASSI",
        Int1DValue
    ],
    [
        "MASTER",
        Int1DValue
    ],
    [
        "NOITEM",
        Int1DValue
    ],
    [
        "LOSEBASE",
        Int1DValue
    ],
    [
        "SELECTCOM",
        Int1DValue
    ],
    [
        "ASSIPLAY",
        Int1DValue
    ],
    [
        "PREVCOM",
        Int1DValue
    ],
    [
        "TIME",
        Int1DValue
    ],
    [
        "ITEMSALES",
        Int1DValue
    ],
    [
        "PLAYER",
        Int1DValue
    ],
    [
        "NEXTCOM",
        Int1DValue
    ],
    [
        "PBAND",
        Int1DValue
    ],
    [
        "BOUGHT",
        Int1DValue
    ],
    [
        "A",
        Int1DValue
    ],
    [
        "B",
        Int1DValue
    ],
    [
        "C",
        Int1DValue
    ],
    [
        "D",
        Int1DValue
    ],
    [
        "E",
        Int1DValue
    ],
    [
        "F",
        Int1DValue
    ],
    [
        "G",
        Int1DValue
    ],
    [
        "H",
        Int1DValue
    ],
    [
        "I",
        Int1DValue
    ],
    [
        "J",
        Int1DValue
    ],
    [
        "K",
        Int1DValue
    ],
    [
        "L",
        Int1DValue
    ],
    [
        "M",
        Int1DValue
    ],
    [
        "N",
        Int1DValue
    ],
    [
        "O",
        Int1DValue
    ],
    [
        "P",
        Int1DValue
    ],
    [
        "Q",
        Int1DValue
    ],
    [
        "R",
        Int1DValue
    ],
    [
        "S",
        Int1DValue
    ],
    [
        "T",
        Int1DValue
    ],
    [
        "U",
        Int1DValue
    ],
    [
        "V",
        Int1DValue
    ],
    [
        "W",
        Int1DValue
    ],
    [
        "X",
        Int1DValue
    ],
    [
        "Y",
        Int1DValue
    ],
    [
        "Z",
        Int1DValue
    ],
    [
        "ITEMPRICE",
        Int1DValue,
        [
            1000
        ],
        [
            "ITEMNAME",
            "ITEMPRICE"
        ]
    ],
    [
        "RANDDATA",
        Int1DValue,
        [
            625
        ]
    ],
    [
        "SAVESTR",
        Str1DValue,
        [
            100
        ],
        [
            "SAVESTR",
            "SAVESTRNAME"
        ]
    ],
    [
        "STR",
        Str1DValue,
        [
            20000
        ],
        [
            "STR",
            "STRNAME"
        ]
    ],
    [
        "RESULTS",
        Str1DValue
    ],
    [
        "TSTR",
        Str1DValue,
        [
            100
        ],
        [
            "TSTR",
            "TSTRNAME"
        ]
    ],
    [
        "SAVEDATA_TEXT",
        Str0DValue
    ],
    [
        "ISASSI",
        IntChar0DValue
    ],
    [
        "NO",
        IntChar0DValue
    ],
    [
        "BASE",
        IntChar1DValue,
        [
            100
        ],
        [
            "BASE",
            "BASENAME",
            "MAXBASE"
        ]
    ],
    [
        "MAXBASE",
        IntChar1DValue,
        [
            100
        ],
        [
            "BASE",
            "BASENAME",
            "MAXBASE"
        ]
    ],
    [
        "ABL",
        IntChar1DValue,
        [
            100
        ],
        [
            "ABL",
            "ABLNAME"
        ]
    ],
    [
        "TALENT",
        IntChar1DValue,
        [
            1000
        ],
        [
            "TALENT",
            "TALENTNAME"
        ]
    ],
    [
        "EXP",
        IntChar1DValue,
        [
            100
        ],
        [
            "EXP",
            "EXPNAME"
        ]
    ],
    [
        "MARK",
        IntChar1DValue,
        [
            100
        ],
        [
            "MARK",
            "MARKNAME"
        ]
    ],
    [
        "PALAM",
        IntChar1DValue,
        [
            200
        ],
        [
            "PALAM",
            "PALAMNAME",
            "JUEL"
        ]
    ],
    [
        "SOURCE",
        IntChar1DValue,
        [
            1000
        ],
        [
            "SOURCE",
            "SOURCENAME"
        ]
    ],
    [
        "EX",
        IntChar1DValue,
        [
            100
        ],
        [
            "EX",
            "EXNAME"
        ]
    ],
    [
        "CFLAG",
        IntChar1DValue,
        [
            1000
        ],
        [
            "CFLAG",
            "CFLAGNAME"
        ]
    ],
    [
        "JUEL",
        IntChar1DValue,
        [
            200
        ],
        [
            "PALAM",
            "PALAMNAME",
            "JUEL"
        ]
    ],
    [
        "RELATION",
        IntChar1DValue,
        [
            1000
        ]
    ],
    [
        "EQUIP",
        IntChar1DValue,
        [
            100
        ],
        [
            "EQUIP",
            "EQUIPNAME"
        ]
    ],
    [
        "TEQUIP",
        IntChar1DValue,
        [
            100
        ],
        [
            "TEQUIP",
            "TEQUIPNAME"
        ]
    ],
    [
        "STAIN",
        IntChar1DValue,
        [
            1000
        ],
        [
            "STAIN",
            "STAINNAME"
        ]
    ],
    [
        "GOTJUEL",
        IntChar1DValue,
        [
            200
        ]
    ],
    [
        "NOWEX",
        IntChar1DValue,
        [
            1000
        ]
    ],
    [
        "DOWNBASE",
        IntChar1DValue,
        [
            1000
        ]
    ],
    [
        "CUP",
        IntChar1DValue,
        [
            1000
        ]
    ],
    [
        "CDOWN",
        IntChar1DValue,
        [
            1000
        ]
    ],
    [
        "TCVAR",
        IntChar1DValue,
        [
            100
        ],
        [
            "TCVAR",
            "TCVARNAME"
        ]
    ],
    [
        "NAME",
        StrChar0DValue
    ],
    [
        "CALLNAME",
        StrChar0DValue
    ],
    [
        "NICKNAME",
        StrChar0DValue
    ],
    [
        "MASTERNAME",
        StrChar0DValue
    ],
    [
        "CSTR",
        StrChar1DValue,
        [
            100
        ],
        [
            "CSTR",
            "CSTRNAME"
        ]
    ],
    [
        "DITEMTYPE",
        Int2DValue
    ],
    [
        "DA",
        Int2DValue
    ],
    [
        "DB",
        Int2DValue
    ],
    [
        "DC",
        Int2DValue
    ],
    [
        "DD",
        Int2DValue
    ],
    [
        "DE",
        Int2DValue
    ],
    [
        "TA",
        Int3DValue
    ],
    [
        "TB",
        Int3DValue
    ],
    [
        "ABLNAME",
        Str1DValue,
        [
            100
        ],
        [
            "ABL",
            "ABLNAME"
        ]
    ],
    [
        "EXPNAME",
        Str1DValue,
        [
            100
        ],
        [
            "EXP",
            "EXPNAME"
        ]
    ],
    [
        "TALENTNAME",
        Str1DValue,
        [
            1000
        ],
        [
            "TALENT",
            "TALENTNAME"
        ]
    ],
    [
        "PALAMNAME",
        Str1DValue,
        [
            200
        ],
        [
            "PALAM",
            "PALAMNAME",
            "JUEL"
        ]
    ],
    [
        "TRAINNAME",
        Str1DValue,
        [
            1000
        ]
    ],
    [
        "MARKNAME",
        Str1DValue,
        [
            100
        ],
        [
            "MARK",
            "MARKNAME"
        ]
    ],
    [
        "ITEMNAME",
        Str1DValue,
        [
            1000
        ],
        [
            "ITEMNAME",
            "ITEMPRICE"
        ]
    ],
    [
        "BASENAME",
        Str1DValue,
        [
            100
        ],
        [
            "BASE",
            "BASENAME"
        ]
    ],
    [
        "SOURCENAME",
        Str1DValue,
        [
            1000
        ],
        [
            "SOURCE",
            "SOURCENAME"
        ]
    ],
    [
        "EXNAME",
        Str1DValue,
        [
            100
        ],
        [
            "EX",
            "EXNAME"
        ]
    ],
    [
        "EQUIPNAME",
        Str1DValue,
        [
            100
        ],
        [
            "EQUIP",
            "EQUIPNAME"
        ]
    ],
    [
        "TEQUIPNAME",
        Str1DValue,
        [
            100
        ],
        [
            "TEQUIP",
            "TEQUIPNAME"
        ]
    ],
    [
        "FLAGNAME",
        Str1DValue,
        [
            10000
        ],
        [
            "FLAG",
            "FLAGNAME"
        ]
    ],
    [
        "TFLAGNAME",
        Str1DValue,
        [
            1000
        ],
        [
            "TFLAG",
            "TFLAGNAME"
        ]
    ],
    [
        "CFLAGNAME",
        Str1DValue,
        [
            1000
        ],
        [
            "CFLAG",
            "CFLAGNAME"
        ]
    ],
    [
        "TCVARNAME",
        Str1DValue,
        [
            100
        ],
        [
            "TCVAR",
            "TCVARNAME"
        ]
    ],
    [
        "CSTRNAME",
        Str1DValue,
        [
            100
        ],
        [
            "CSTR",
            "CSTRNAME"
        ]
    ],
    [
        "STAINNAME",
        Str1DValue,
        [
            1000
        ],
        [
            "STAIN",
            "STAINNAME"
        ]
    ],
    [
        "CDFLAGNAME1",
        Str1DValue,
        [
            1
        ]
    ],
    [
        "CDFLAGNAME2",
        Str1DValue,
        [
            1
        ]
    ],
    [
        "STRNAME",
        Str1DValue,
        [
            20000
        ],
        [
            "STR",
            "STRNAME"
        ]
    ],
    [
        "TSTRNAME",
        Str1DValue,
        [
            100
        ],
        [
            "TSTR",
            "TSTRNAME"
        ]
    ],
    [
        "SAVESTRNAME",
        Str1DValue,
        [
            100
        ],
        [
            "SAVESTR",
            "SAVESTRNAME"
        ]
    ],
    [
        "GLOBALNAME",
        Str1DValue,
        [
            1000
        ],
        [
            "GLOBAL",
            "GLOBALNAME"
        ]
    ],
    [
        "GLOBALSNAME",
        Str1DValue,
        [
            100
        ],
        [
            "GLOBALS",
            "GLOBALSNAME"
        ]
    ],
    [
        "GAMEBASE_AUTHOR",
        Str0DValue
    ],
    [
        "GAMEBASE_INFO",
        Str0DValue
    ],
    [
        "GAMEBASE_YEAR",
        Str0DValue
    ],
    [
        "GAMEBASE_TITLE",
        Str0DValue
    ],
    [
        "WINDOW_TITLE",
        Str0DValue
    ],
    [
        "MONEYLABEL",
        Str0DValue
    ],
    [
        "LASTLOAD_TEXT",
        Str0DValue
    ],
    [
        "GAMEBASE_GAMECODE",
        Int0DValue
    ],
    [
        "GAMEBASE_VERSION",
        Int0DValue
    ],
    [
        "GAMEBASE_ALLOWVERSION",
        Int0DValue
    ],
    [
        "GAMEBASE_DEFAULTCHARA",
        Int0DValue
    ],
    [
        "GAMEBASE_NOITEM",
        Int0DValue
    ],
    [
        "LASTLOAD_VERSION",
        Int0DValue
    ],
    [
        "LASTLOAD_NO",
        Int0DValue
    ],
    [
        "ISTIMEOUT",
        Int0DValue
    ],
    [
        "__INT_MAX__",
        Int0DValue
    ],
    [
        "__INT_MIN__",
        Int0DValue
    ]
];
const EVENT = [
    "EVENTFIRST",
    "EVENTTRAIN",
    "EVENTSHOP",
    "EVENTBUY",
    "EVENTCOM",
    "EVENTTURNEND",
    "EVENTCOMEND",
    "EVENTEND",
    "EVENTLOAD"
];
class VM {
    random;
    code;
    external;
    eventMap;
    fnMap;
    macroMap;
    templateMap;
    globalMap;
    staticMap;
    characterList;
    contextStack;
    printer;
    printCPerLine;
    constructor(code){
        this.random = new PRNG();
        this.code = code;
        this.eventMap = new Map();
        this.fnMap = new Map();
        this.macroMap = new Map();
        this.templateMap = new Map();
        this.globalMap = new Map();
        this.staticMap = new Map();
        this.characterList = [];
        this.contextStack = [];
        for (const fn of code.fnList){
            if (EVENT.includes(fn.name)) {
                if (!this.eventMap.has(fn.name)) {
                    this.eventMap.set(fn.name, []);
                }
                this.eventMap.get(fn.name).push(fn);
            } else {
                this.fnMap.set(fn.name, fn);
            }
        }
        for (const events of this.eventMap.values()){
            events.sort((a, b)=>{
                if (a.isFirst()) return -1;
                if (b.isFirst()) return 1;
                if (a.isLast()) return 1;
                if (b.isLast()) return -1;
                return 0;
            });
        }
        for (const property of code.header){
            if (property instanceof Define) {
                this.macroMap.set(property.name, property);
            }
        }
        for (const [id, character] of code.csv.character){
            this.templateMap.set(id, character);
        }
        this.globalMap.set("GLOBAL", new Int1DValue("GLOBAL", code.csv.varSize.get("GLOBAL")));
        this.globalMap.set("GLOBALS", new Str1DValue("GLOBALS", code.csv.varSize.get("GLOBALS")));
    }
    async reset() {
        this.printer = new Printer();
        this.printCPerLine = 3;
        const globalMap = this.globalMap;
        const { header , csv  } = this.code;
        const varSize = new Map(csv.varSize);
        for (const [name, Cls, size, mergeList] of valueList){
            let mergeSize;
            for (const mergeName of mergeList ?? []){
                if (varSize.has(mergeName)) {
                    const prev0 = (mergeSize ?? [
                        0
                    ])[0];
                    const size0 = varSize.get(mergeName)[0];
                    mergeSize = [
                        Math.max(prev0, size0)
                    ];
                }
            }
            const value = new Cls(name, mergeSize ?? varSize.get(name) ?? size);
            globalMap.set(name, value);
        }
        globalMap.set("RAND", new RandValue());
        globalMap.set("CHARANUM", new CharaNumValue());
        globalMap.set("LINECOUNT", new LineCountValue());
        globalMap.get("ITEMPRICE").reset(new Map([
            ...csv.item.entries()
        ].map(([key, val])=>[
                key,
                val.price
            ])));
        globalMap.get("STR").reset(csv.str);
        globalMap.get("PALAMLV").reset([
            0,
            100,
            500,
            3000,
            10000,
            30000,
            60000,
            100000,
            150000,
            250000
        ]);
        globalMap.get("EXPLV").reset([
            0,
            1,
            4,
            20,
            50,
            200
        ]);
        globalMap.get("ASSI").reset([
            -1
        ]);
        globalMap.get("TARGET").reset([
            1
        ]);
        globalMap.get("PBAND").reset([
            4
        ]);
        globalMap.get("EJAC").reset([
            10000
        ]);
        globalMap.get("RANDDATA").reset([
            this.random.state
        ]);
        globalMap.get("ABLNAME").reset(csv.abl);
        globalMap.get("EXPNAME").reset(csv.exp);
        globalMap.get("TALENTNAME").reset(csv.talent);
        globalMap.get("PALAMNAME").reset(csv.palam);
        globalMap.get("TRAINNAME").reset(csv.train);
        globalMap.get("MARKNAME").reset(csv.mark);
        globalMap.get("ITEMNAME").reset(new Map([
            ...csv.item.entries()
        ].map(([key, val])=>[
                key,
                val.name
            ])));
        globalMap.get("BASENAME").reset(csv.base);
        globalMap.get("SOURCENAME").reset(csv.source);
        globalMap.get("EXNAME").reset(csv.ex);
        globalMap.get("EQUIPNAME").reset(csv.equip);
        globalMap.get("TEQUIPNAME").reset(csv.tequip);
        globalMap.get("FLAGNAME").reset(csv.flag);
        globalMap.get("TFLAGNAME").reset(csv.tflag);
        globalMap.get("CFLAGNAME").reset(csv.cflag);
        globalMap.get("TCVARNAME").reset(csv.tcvar);
        globalMap.get("CSTRNAME").reset(csv.cstr);
        globalMap.get("STAINNAME").reset(csv.stain);
        globalMap.get("CDFLAGNAME1").reset(csv.cdflag1);
        globalMap.get("CDFLAGNAME2").reset(csv.cdflag2);
        globalMap.get("STRNAME").reset(csv.str);
        globalMap.get("TSTRNAME").reset(csv.tstr);
        globalMap.get("SAVESTRNAME").reset(csv.saveStr);
        globalMap.get("GLOBALNAME").reset(csv.global);
        globalMap.get("GLOBALSNAME").reset(csv.globalS);
        globalMap.get("GAMEBASE_AUTHOR").reset(csv.gamebase.author ?? "");
        globalMap.get("GAMEBASE_INFO").reset(csv.gamebase.info ?? "");
        globalMap.get("GAMEBASE_YEAR").reset(csv.gamebase.year ?? "");
        globalMap.get("GAMEBASE_TITLE").reset(csv.gamebase.title ?? "");
        globalMap.get("GAMEBASE_GAMECODE").reset(csv.gamebase.code ?? 0);
        globalMap.get("GAMEBASE_VERSION").reset(csv.gamebase.version ?? 0);
        globalMap.get("LASTLOAD_VERSION").reset(-1);
        globalMap.get("LASTLOAD_NO").reset(-1);
        globalMap.get("__INT_MAX__").reset(2n ** 63n - 1n);
        globalMap.get("__INT_MIN__").reset(-(2n ** 63n - 1n));
        for (const [i, name1] of csv.abl.entries()){
            globalMap.set(name1, new Int0DValue(name1).reset(i));
        }
        for (const [i1, name2] of csv.exp.entries()){
            globalMap.set(name2, new Int0DValue(name2).reset(i1));
        }
        for (const [i2, { name: name3  }] of csv.item.entries()){
            globalMap.set(name3, new Int0DValue(name3).reset(i2));
        }
        for (const [i3, name4] of csv.talent.entries()){
            globalMap.set(name4, new Int0DValue(name4).reset(i3));
        }
        for (const [i4, name5] of csv.mark.entries()){
            globalMap.set(name5, new Int0DValue(name5).reset(i4));
        }
        for (const [i5, name6] of csv.palam.entries()){
            globalMap.set(name6, new Int0DValue(name6).reset(i5));
        }
        for (const property of header){
            if (property instanceof Dim) {
                globalMap.set(property.name, await property.build(this));
            }
        }
        this.staticMap = new Map();
        this.staticMap.set("@DUMMY", new Map());
        let fnList = [
            ...this.fnMap.values()
        ];
        for (const events of this.eventMap.values()){
            fnList = fnList.concat(events);
        }
        for (const fn of fnList){
            this.staticMap.set(fn.name, new Map());
            this.staticMap.get(fn.name).set("LOCAL", new Int1DValue("LOCAL", varSize.get("LOCAL")));
            this.staticMap.get(fn.name).set("LOCALS", new Str1DValue("LOCALS", varSize.get("LOCALS")));
            for (const property1 of fn.property){
                if (property1 instanceof Dim && !property1.isDynamic()) {
                    this.staticMap.get(fn.name).set(property1.name, await property1.build(this));
                } else if (property1 instanceof LocalSize || property1 instanceof LocalSSize) {
                    await property1.apply(this, fn.name);
                }
            }
        }
        this.characterList = [];
    }
    configure(config) {
        this.printer.defaultColor = config.front;
        this.printer.defaultBackground = config.back;
        this.printer.color = config.front;
        this.printer.background = config.back;
        this.printer.focus = config.focus;
    }
    context() {
        return this.contextStack[this.contextStack.length - 1];
    }
    async pushContext(fn) {
        const context = {
            fn,
            dynamicMap: new Map(),
            refMap: new Map()
        };
        context.dynamicMap.set("ARG", new Int1DValue("ARG", this.code.csv.varSize.get("ARG")));
        context.dynamicMap.set("ARGS", new Str1DValue("ARGS", this.code.csv.varSize.get("ARGS")));
        for (const property of fn.property){
            if (property instanceof Dim && property.isDynamic()) {
                context.dynamicMap.set(property.name, await property.build(this));
            }
        }
        this.contextStack.push(context);
        return context;
    }
    popContext() {
        this.contextStack.pop();
    }
    getValue(name, scope) {
        if (scope != null) {
            if (!this.staticMap.has(scope)) {
                throw notFound("Scope", scope);
            }
            if (this.staticMap.get(scope).has(name)) {
                return this.staticMap.get(scope).get(name);
            } else {
                throw notFound("Variable", name + ":" + scope);
            }
        } else {
            const context = this.context();
            if (context.refMap.has(name)) {
                return this.getValue(context.refMap.get(name));
            } else if (context.dynamicMap.has(name)) {
                return context.dynamicMap.get(name);
            } else if (this.staticMap.get(context.fn.name).has(name)) {
                return this.staticMap.get(context.fn.name).get(name);
            } else if (this.globalMap.has(name)) {
                return this.globalMap.get(name);
            } else {
                throw new Error(`Variable ${name} does not exist`);
            }
        }
    }
    async *start(external) {
        this.external = external;
        await this.reset();
        this.contextStack = [];
        await this.pushContext(new Fn2("@DUMMY", [], [], new Thunk([])));
        let begin = "TITLE";
        while(true){
            let result = null;
            switch(begin.toUpperCase()){
                case "TITLE":
                    result = yield* TITLE(this);
                    break;
                case "FIRST":
                    result = yield* FIRST(this);
                    break;
                case "SHOP":
                    result = yield* SHOP(this);
                    break;
                case "TRAIN":
                    result = yield* TRAIN(this);
                    break;
                case "AFTERTRAIN":
                    result = yield* AFTERTRAIN(this);
                    break;
                case "ABLUP":
                    result = yield* ABLUP(this);
                    break;
                case "TURNEND":
                    result = yield* TURNEND(this);
                    break;
                case "DATALOADED":
                    result = yield* DATALOADED(this);
                    break;
                default:
                    throw notFound("Scene", begin);
            }
            switch(result?.type){
                case "begin":
                    begin = result.keyword;
                    continue;
                case "goto":
                    throw notFound("Label", result.label);
                case "break":
                    return null;
                case "continue":
                    return null;
                case "throw":
                    throw new Error(`Uncaught error ${result.value}`);
                case "return":
                    continue;
                case "quit":
                    return null;
                case undefined:
                    continue;
            }
        }
    }
    async *run(statement, label) {
        try {
            return yield* statement.run(this, label);
        } catch (e) {
            if (e instanceof EraJSError) {
                throw e;
            }
            const trace = [];
            for (const context of this.contextStack.slice(1)){
                trace.push(context.fn.name);
            }
            throw new EraJSError(e.message, statement.raw, trace);
        }
    }
}
function compile(files) {
    const csvFiles = new Map();
    const erhFiles = new Map();
    const erbFiles = new Map();
    for (const [file, content] of files){
        const FILE = file.toUpperCase();
        if (FILE.endsWith(".CSV")) {
            csvFiles.set(file.toUpperCase(), content);
        } else if (FILE.endsWith(".ERH")) {
            erhFiles.set(file.toUpperCase(), content);
        } else if (FILE.endsWith(".ERB")) {
            erbFiles.set(file.toUpperCase(), content);
        }
    }
    const csv = parseCSV(csvFiles);
    const macros = new Set();
    const header = parseERH(erhFiles, macros);
    for (const property of header){
        if (property instanceof Define) {
            macros.add(property.name);
        }
    }
    const fnList = parseERB(erbFiles, macros);
    return new VM({
        header,
        fnList,
        csv
    });
}
async function extract(zip) {
    const csvDir = Object.values(zip.files).find((zipObj)=>zipObj.dir && (zipObj.name.toUpperCase() === "CSV" || zipObj.name.toUpperCase() === "CSV/" || zipObj.name.toUpperCase().endsWith("/CSV") || zipObj.name.toUpperCase().endsWith("/CSV/")));
    if (csvDir == null) {
        throw new Error("CSV folder is not found");
    }
    const erbDir = Object.values(zip.files).find((zipObj)=>zipObj.dir && (zipObj.name.toUpperCase() === "ERB" || zipObj.name.toUpperCase() === "ERB/" || zipObj.name.toUpperCase().endsWith("/ERB") || zipObj.name.toUpperCase().endsWith("/ERB/")));
    if (erbDir == null) {
        throw new Error("ERB folder is not found");
    }
    const files = new Map();
    await Promise.all(Object.values(zip.files).map(async (zipObj)=>{
        if (!zipObj.name.startsWith(csvDir.name) && !zipObj.name.startsWith(erbDir.name)) {
            return;
        }
        files.set(zipObj.name.split("/").pop(), await zipObj.async("text"));
    }));
    return files;
}
function compile1(files) {
    return compile(files);
}
function O12(e) {
    for(var t = arguments.length, o = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)o[r - 1] = arguments[r];
    if (!1) ;
    throw Error("[Immer] minified error nr: " + e + (o.length ? " " + o.map(function(s) {
        return "'" + s + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function S7(e) {
    return !!e && !!e[v8];
}
function D6(e) {
    return !!e && (function(t) {
        if (!t || typeof t != "object") return !1;
        var o = Object.getPrototypeOf(t);
        if (o === null) return !0;
        var r = Object.hasOwnProperty.call(o, "constructor") && o.constructor;
        return r === Object || typeof r == "function" && Function.toString.call(r) === Pe8;
    }(e) || Array.isArray(e) || !!e[M8] || !!e.constructor[M8] || $10(e) || G10(e));
}
function N4(e, t, o) {
    o === void 0 && (o = !1), I8(e) === 0 ? (o ? Object.keys : k3)(e).forEach(function(r) {
        o && typeof r == "symbol" || t(r, e[r], e);
    }) : e.forEach(function(r, c) {
        return t(c, r, e);
    });
}
function I8(e) {
    var t = e[v8];
    return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(e) ? 1 : $10(e) ? 2 : G10(e) ? 3 : 0;
}
function x7(e, t) {
    return I8(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function V6(e, t) {
    return I8(e) === 2 ? e.get(t) : e[t];
}
function se7(e, t, o) {
    var r = I8(e);
    r === 2 ? e.set(t, o) : r === 3 ? (e.delete(t), e.add(o)) : e[t] = o;
}
function le7(e, t) {
    return e === t ? e !== 0 || 1 / e == 1 / t : e != e && t != t;
}
function $10(e) {
    return me8 && e instanceof Map;
}
function G10(e) {
    return Oe5 && e instanceof Set;
}
function m4(e) {
    return e.o || e.t;
}
function Q12(e) {
    if (Array.isArray(e)) return Array.prototype.slice.call(e);
    var t = pe11(e);
    delete t[v8];
    for(var o = k3(t), r = 0; r < o.length; r++){
        var c = o[r], l = t[c];
        l.writable === !1 && (l.writable = !0, l.configurable = !0), (l.get || l.set) && (t[c] = {
            configurable: !0,
            writable: !0,
            enumerable: l.enumerable,
            value: e[c]
        });
    }
    return Object.create(Object.getPrototypeOf(e), t);
}
function Z10(e, t) {
    return t === void 0 && (t = !1), ee11(e) || S7(e) || !D6(e) || (I8(e) > 1 && (e.set = e.add = e.clear = e.delete = he6), Object.freeze(e), t && N4(e, function(o, r) {
        return Z10(r, !0);
    }, !0)), e;
}
function he6() {
    O12(2);
}
function ee11(e) {
    return e == null || typeof e != "object" || Object.isFrozen(e);
}
function _3(e) {
    var t = L8[e];
    return t || O12(18, e), t;
}
function F6() {
    return R9;
}
function X13(e, t) {
    t && (_3("Patches"), e.u = [], e.s = [], e.v = t);
}
function U8(e) {
    H8(e), e.p.forEach(ve7), e.p = null;
}
function H8(e) {
    e === R9 && (R9 = e.l);
}
function oe8(e) {
    return R9 = {
        p: [],
        l: R9,
        h: e,
        m: !0,
        _: 0
    };
}
function ve7(e) {
    var t = e[v8];
    t.i === 0 || t.i === 1 ? t.j() : t.O = !0;
}
function Y9(e, t) {
    t._ = t.p.length;
    var o = t.p[0], r = e !== void 0 && e !== o;
    return t.h.g || _3("ES5").S(t, e, r), r ? (o[v8].P && (U8(t), O12(4)), D6(e) && (e = W11(t, e), t.l || J8(t, e)), t.u && _3("Patches").M(o[v8], e, t.u, t.s)) : e = W11(t, o, []), U8(t), t.u && t.v(t.u, t.s), e !== ne9 ? e : void 0;
}
function W11(e, t, o) {
    if (ee11(t)) return t;
    var r = t[v8];
    if (!r) return N4(t, function(l, s) {
        return ae9(e, r, t, l, s, o);
    }, !0), t;
    if (r.A !== e) return t;
    if (!r.P) return J8(e, r.t, !0), r.t;
    if (!r.I) {
        r.I = !0, r.A._--;
        var c = r.i === 4 || r.i === 5 ? r.o = Q12(r.k) : r.o;
        N4(r.i === 3 ? new Set(c) : c, function(l, s) {
            return ae9(e, r, c, l, s, o);
        }), J8(e, c, !1), o && e.u && _3("Patches").R(r, o, e.u, e.s);
    }
    return r.o;
}
function ae9(e, t, o, r, c, l) {
    if (S7(c)) {
        var s = W11(e, c, l && t && t.i !== 3 && !x7(t.D, r) ? l.concat(r) : void 0);
        if (se7(o, r, s), !S7(s)) return;
        e.m = !1;
    }
    if (D6(c) && !ee11(c)) {
        if (!e.h.F && e._ < 1) return;
        W11(e, c), t && t.A.l || J8(e, c);
    }
}
function J8(e, t, o) {
    o === void 0 && (o = !1), e.h.F && e.m && Z10(t, o);
}
function q9(e, t) {
    var o = e[v8];
    return (o ? m4(o) : e)[t];
}
function ie7(e, t) {
    if (t in e) for(var o = Object.getPrototypeOf(e); o;){
        var r = Object.getOwnPropertyDescriptor(o, t);
        if (r) return r;
        o = Object.getPrototypeOf(o);
    }
}
function w6(e) {
    e.P || (e.P = !0, e.l && w6(e.l));
}
function B10(e) {
    e.o || (e.o = Q12(e.t));
}
function C6(e, t, o) {
    var r = $10(t) ? _3("MapSet").N(t, o) : G10(t) ? _3("MapSet").T(t, o) : e.g ? function(c, l) {
        var s = Array.isArray(c), u = {
            i: s ? 1 : 0,
            A: l ? l.A : F6(),
            P: !1,
            I: !1,
            D: {},
            l,
            t: c,
            k: null,
            o: null,
            j: null,
            C: !1
        }, i = u, n = z10;
        s && (i = [
            u
        ], n = K12);
        var a = Proxy.revocable(i, n), f = a.revoke, h = a.proxy;
        return u.k = h, u.j = f, h;
    }(t, o) : _3("ES5").J(t, o);
    return (o ? o.A : F6()).p.push(r), r;
}
function de9(e) {
    return S7(e) || O12(22, e), function t(o) {
        if (!D6(o)) return o;
        var r, c = o[v8], l = I8(o);
        if (c) {
            if (!c.P && (c.i < 4 || !_3("ES5").K(c))) return c.t;
            c.I = !0, r = ue3(o, l), c.I = !1;
        } else r = ue3(o, l);
        return N4(r, function(s, u) {
            c && V6(c.t, s) === u || se7(r, s, t(u));
        }), l === 3 ? new Set(r) : r;
    }(e);
}
function ue3(e, t) {
    switch(t){
        case 2:
            return new Map(e);
        case 3:
            return Array.from(e);
    }
    return Q12(e);
}
var ce7, R9, re7 = typeof Symbol < "u" && typeof Symbol("x") == "symbol", me8 = typeof Map < "u", Oe5 = typeof Set < "u", fe8 = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", ne9 = re7 ? Symbol.for("immer-nothing") : ((ce7 = {})["immer-nothing"] = !0, ce7), M8 = re7 ? Symbol.for("immer-draftable") : "__$immer_draftable", v8 = re7 ? Symbol.for("immer-state") : "__$immer_state", T5 = typeof Symbol < "u" && Symbol.iterator || "@@iterator";
var Pe8 = "" + Object.prototype.constructor, k3 = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Object.getOwnPropertyNames, pe11 = Object.getOwnPropertyDescriptors || function(e) {
    var t = {};
    return k3(e).forEach(function(o) {
        t[o] = Object.getOwnPropertyDescriptor(e, o);
    }), t;
}, L8 = {}, z10 = {
    get: function(e, t) {
        if (t === v8) return e;
        var o = m4(e);
        if (!x7(o, t)) return function(c, l, s) {
            var u, i = ie7(l, s);
            return i ? "value" in i ? i.value : (u = i.get) === null || u === void 0 ? void 0 : u.call(c.k) : void 0;
        }(e, o, t);
        var r = o[t];
        return e.I || !D6(r) ? r : r === q9(e.t, t) ? (B10(e), e.o[t] = C6(e.A.h, r, e)) : r;
    },
    has: function(e, t) {
        return t in m4(e);
    },
    ownKeys: function(e) {
        return Reflect.ownKeys(m4(e));
    },
    set: function(e, t, o) {
        var r = ie7(m4(e), t);
        if (r?.set) return r.set.call(e.k, o), !0;
        if (!e.P) {
            var c = q9(m4(e), t), l = c?.[v8];
            if (l && l.t === o) return e.o[t] = o, e.D[t] = !1, !0;
            if (le7(o, c) && (o !== void 0 || x7(e.t, t))) return !0;
            B10(e), w6(e);
        }
        return e.o[t] === o && typeof o != "number" && (o !== void 0 || t in e.o) || (e.o[t] = o, e.D[t] = !0, !0);
    },
    deleteProperty: function(e, t) {
        return q9(e.t, t) !== void 0 || t in e.t ? (e.D[t] = !1, B10(e), w6(e)) : delete e.D[t], e.o && delete e.o[t], !0;
    },
    getOwnPropertyDescriptor: function(e, t) {
        var o = m4(e), r = Reflect.getOwnPropertyDescriptor(o, t);
        return r && {
            writable: !0,
            configurable: e.i !== 1 || t !== "length",
            enumerable: r.enumerable,
            value: o[t]
        };
    },
    defineProperty: function() {
        O12(11);
    },
    getPrototypeOf: function(e) {
        return Object.getPrototypeOf(e.t);
    },
    setPrototypeOf: function() {
        O12(12);
    }
}, K12 = {};
N4(z10, function(e, t) {
    K12[e] = function() {
        return arguments[0] = arguments[0][0], t.apply(this, arguments);
    };
}), K12.deleteProperty = function(e, t) {
    return z10.deleteProperty.call(this, e[0], t);
}, K12.set = function(e, t, o) {
    return z10.set.call(this, e[0], t, o, e[0]);
};
var we9 = function() {
    function e(o) {
        var r = this;
        this.g = fe8, this.F = !0, this.produce = function(c, l, s) {
            if (typeof c == "function" && typeof l != "function") {
                var u = l;
                l = c;
                var i = r;
                return function(p) {
                    var d = this;
                    p === void 0 && (p = u);
                    for(var y = arguments.length, b = Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)b[g - 1] = arguments[g];
                    return i.produce(p, function(P) {
                        var E;
                        return (E = l).call.apply(E, [
                            d,
                            P
                        ].concat(b));
                    });
                };
            }
            var n;
            if (typeof l != "function" && O12(6), s !== void 0 && typeof s != "function" && O12(7), D6(c)) {
                var a = oe8(r), f = C6(r, c, void 0), h = !0;
                try {
                    n = l(f), h = !1;
                } finally{
                    h ? U8(a) : H8(a);
                }
                return typeof Promise < "u" && n instanceof Promise ? n.then(function(p) {
                    return X13(a, s), Y9(p, a);
                }, function(p) {
                    throw U8(a), p;
                }) : (X13(a, s), Y9(n, a));
            }
            if (!c || typeof c != "object") return (n = l(c)) === ne9 ? void 0 : (n === void 0 && (n = c), r.F && Z10(n, !0), n);
            O12(21, c);
        }, this.produceWithPatches = function(c, l) {
            return typeof c == "function" ? function(i) {
                for(var n = arguments.length, a = Array(n > 1 ? n - 1 : 0), f = 1; f < n; f++)a[f - 1] = arguments[f];
                return r.produceWithPatches(i, function(h) {
                    return c.apply(void 0, [
                        h
                    ].concat(a));
                });
            } : [
                r.produce(c, l, function(i, n) {
                    s = i, u = n;
                }),
                s,
                u
            ];
            var s, u;
        }, typeof o?.useProxies == "boolean" && this.setUseProxies(o.useProxies), typeof o?.autoFreeze == "boolean" && this.setAutoFreeze(o.autoFreeze);
    }
    var t = e.prototype;
    return t.createDraft = function(o) {
        D6(o) || O12(8), S7(o) && (o = de9(o));
        var r = oe8(this), c = C6(this, o, void 0);
        return c[v8].C = !0, H8(r), c;
    }, t.finishDraft = function(o, r) {
        var c = o && o[v8], l = c.A;
        return X13(l, r), Y9(void 0, l);
    }, t.setAutoFreeze = function(o) {
        this.F = o;
    }, t.setUseProxies = function(o) {
        o && !fe8 && O12(20), this.g = o;
    }, t.applyPatches = function(o, r) {
        var c;
        for(c = r.length - 1; c >= 0; c--){
            var l = r[c];
            if (l.path.length === 0 && l.op === "replace") {
                o = l.value;
                break;
            }
        }
        var s = _3("Patches").$;
        return S7(o) ? s(o, r) : this.produce(o, function(u) {
            return s(u, r.slice(c + 1));
        });
    }, e;
}(), j11 = new we9, je5 = j11.produce, Se7 = j11.produceWithPatches.bind(j11), Ne6 = j11.setAutoFreeze.bind(j11), xe8 = j11.setUseProxies.bind(j11), Ie5 = j11.applyPatches.bind(j11), ke6 = j11.createDraft.bind(j11), ze4 = j11.finishDraft.bind(j11), Me8 = je5;
function f6(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r, e;
}
function o2(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
    }
    return r;
}
function p2(e) {
    for(var t = 1; t < arguments.length; t++){
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? o2(Object(r), !0).forEach(function(n) {
            f6(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : o2(Object(r)).forEach(function(n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
    }
    return e;
}
function i7(e) {
    return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. ";
}
var x8 = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable";
}(), N5 = function() {
    return Math.random().toString(36).substring(7).split("").join(".");
}, m5 = {
    INIT: "@@redux/INIT" + N5(),
    REPLACE: "@@redux/REPLACE" + N5(),
    PROBE_UNKNOWN_ACTION: function() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + N5();
    }
};
function I9(e) {
    if (typeof e != "object" || e === null) return !1;
    for(var t = e; Object.getPrototypeOf(t) !== null;)t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t;
}
function _4(e, t, r) {
    var o;
    if (typeof t == "function" && typeof r == "function" || typeof r == "function" && typeof arguments[3] == "function") throw new Error(i7(0));
    if (typeof t == "function" && typeof r == "undefined" && (r = t, t = void 0), typeof r != "undefined") {
        if (typeof r != "function") throw new Error(i7(1));
        return r(_4)(e, t);
    }
    if (typeof e != "function") throw new Error(i7(2));
    var s = e, d = t, h = [], a = h, u = !1;
    function l() {
        a === h && (a = h.slice());
    }
    function v() {
        if (u) throw new Error(i7(3));
        return d;
    }
    function E(n) {
        if (typeof n != "function") throw new Error(i7(4));
        if (u) throw new Error(i7(5));
        var p = !0;
        return l(), a.push(n), function() {
            if (!!p) {
                if (u) throw new Error(i7(6));
                p = !1, l();
                var c = a.indexOf(n);
                a.splice(c, 1), h = null;
            }
        };
    }
    function f(n) {
        if (!I9(n)) throw new Error(i7(7));
        if (typeof n.type == "undefined") throw new Error(i7(8));
        if (u) throw new Error(i7(9));
        try {
            u = !0, d = s(d, n);
        } finally{
            u = !1;
        }
        for(var p = h = a, y = 0; y < p.length; y++){
            var c = p[y];
            c();
        }
        return n;
    }
    function b(n) {
        if (typeof n != "function") throw new Error(i7(10));
        s = n, f({
            type: m5.REPLACE
        });
    }
    function g() {
        var n, p = E;
        return n = {
            subscribe: function(c) {
                if (typeof c != "object" || c === null) throw new Error(i7(11));
                function w() {
                    c.next && c.next(v());
                }
                w();
                var k = p(w);
                return {
                    unsubscribe: k
                };
            }
        }, n[x8] = function() {
            return this;
        }, n;
    }
    return f({
        type: m5.INIT
    }), o = {
        dispatch: f,
        subscribe: E,
        getState: v,
        replaceReducer: b
    }, o[x8] = g, o;
}
function S8(e) {
    Object.keys(e).forEach(function(t) {
        var r = e[t], o = r(void 0, {
            type: m5.INIT
        });
        if (typeof o == "undefined") throw new Error(i7(12));
        if (typeof r(void 0, {
            type: m5.PROBE_UNKNOWN_ACTION()
        }) == "undefined") throw new Error(i7(13));
    });
}
function A8(e) {
    for(var t = Object.keys(e), r = {}, o = 0; o < t.length; o++){
        var s = t[o];
        typeof e[s] == "function" && (r[s] = e[s]);
    }
    var d = Object.keys(r), a;
    try {
        S8(r);
    } catch (u) {
        a = u;
    }
    return function(l, v) {
        if (l === void 0 && (l = {}), a) throw a;
        if (!1) ;
        for(var f = !1, b = {}, g = 0; g < d.length; g++){
            var n = d[g], p = r[n], y = l[n], c = p(y, v);
            if (typeof c == "undefined") {
                v && v.type;
                throw new Error(i7(14));
            }
            b[n] = c, f = f || c !== y;
        }
        return f = f || d.length !== Object.keys(l).length, f ? b : l;
    };
}
function j12() {
    for(var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r];
    return t.length === 0 ? function(o) {
        return o;
    } : t.length === 1 ? t[0] : t.reduce(function(o, s) {
        return function() {
            return o(s.apply(void 0, arguments));
        };
    });
}
function R10() {
    for(var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r];
    return function(o) {
        return function() {
            var s = o.apply(void 0, arguments), d = function() {
                throw new Error(i7(15));
            }, h = {
                getState: s.getState,
                dispatch: function() {
                    return d.apply(void 0, arguments);
                }
            }, a = t.map(function(u) {
                return u(h);
            });
            return d = j12.apply(void 0, a)(s.dispatch), p2(p2({}, s), {}, {
                dispatch: d
            });
        };
    };
}
function n3(u) {
    return function(e) {
        var a = e.dispatch, i = e.getState;
        return function(f) {
            return function(t) {
                return typeof t == "function" ? t(a, i, u) : f(t);
            };
        };
    };
}
var r = n3();
r.withExtraArgument = n3;
var c2 = r;
function deferred() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject)=>{
        methods = {
            async resolve (value) {
                await value;
                state = "fulfilled";
                resolve(value);
            },
            reject (reason) {
                state = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state
    });
    return Object.assign(promise, methods);
}
function delay(ms, options = {}) {
    const { signal , persistent  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
        if (persistent === false) {
            try {
                Deno.unrefTimer(i);
            } catch (error) {
                if (!(error instanceof ReferenceError)) {
                    throw error;
                }
                console.error("`persistent` option is only available in Deno");
            }
        }
    });
}
class MuxAsyncIterator {
    #iteratorCount = 0;
    #yields = [];
    #throws = [];
    #signal = deferred();
    add(iterable) {
        ++this.#iteratorCount;
        this.#callIteratorNext(iterable[Symbol.asyncIterator]());
    }
    async #callIteratorNext(iterator) {
        try {
            const { value , done  } = await iterator.next();
            if (done) {
                --this.#iteratorCount;
            } else {
                this.#yields.push({
                    iterator,
                    value
                });
            }
        } catch (e2) {
            this.#throws.push(e2);
        }
        this.#signal.resolve();
    }
    async *iterate() {
        while(this.#iteratorCount > 0){
            await this.#signal;
            for(let i = 0; i < this.#yields.length; i++){
                const { iterator , value  } = this.#yields[i];
                yield value;
                this.#callIteratorNext(iterator);
            }
            if (this.#throws.length) {
                for (const e of this.#throws){
                    throw e;
                }
                this.#throws.length = 0;
            }
            this.#yields.length = 0;
            this.#signal = deferred();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
const { Deno: Deno1  } = globalThis;
typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function indexOfNeedle1(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1  } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const isLinux = osType === "linux";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const os = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod1 = {
    os: os,
    fs: fs,
    crypto: crypto,
    zlib: zlib,
    trace: trace
};
const UV_EEXIST = os.errno.EEXIST;
const UV_ENOENT = os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorFreebsd = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -85,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -84,
        [
            "EOVERFLOW",
            "value too large for defined data type"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -92,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -86,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ],
    [
        -44,
        [
            "ESOCKTNOSUPPORT",
            "socket type not supported"
        ]
    ]
];
const errorToCodeFreebsd = codeToErrorFreebsd.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : osType === "freebsd" ? codeToErrorFreebsd : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : osType === "freebsd" ? errorToCodeFreebsd : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code = uvTranslateSysError(sysErrno);
        return codeMap.get(code) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
const UV_UNKNOWN = codeMap.get("UNKNOWN");
const UV_EBADF = codeMap.get("EBADF");
const UV_EINVAL = codeMap.get("EINVAL");
const UV_ENOTSOCK = codeMap.get("ENOTSOCK");
const mod2 = {
    UV_EEXIST: UV_EEXIST,
    UV_ENOENT: UV_ENOENT,
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno,
    UV_EAI_MEMORY: UV_EAI_MEMORY,
    UV_UNKNOWN: UV_UNKNOWN,
    UV_EBADF: UV_EBADF,
    UV_EINVAL: UV_EINVAL,
    UV_ENOTSOCK: UV_ENOTSOCK
};
const codes1 = {};
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Warning: Not implemented: ${msg}` : "Warning: Not implemented";
    console.warn(message);
}
TextDecoder;
TextEncoder;
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes1.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object";
const _isFunctionLike1 = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer2(value) {
    return _isObjectLike1(value) && (_toString1.call(value) === "[object ArrayBuffer]" || _toString1.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Arguments]";
}
function isArrayBuffer2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction2(value) {
    return _isFunctionLike1(value) && _toString1.call(value) === "[object AsyncFunction]";
}
function isBooleanObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Boolean]";
}
function isBoxedPrimitive2(value) {
    return isBooleanObject2(value) || isStringObject2(value) || isNumberObject2(value) || isSymbolObject2(value) || isBigIntObject2(value);
}
function isDataView2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object DataView]";
}
function isDate2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Date]";
}
function isGeneratorFunction2(value) {
    return _isFunctionLike1(value) && _toString1.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Generator]";
}
function isMap2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Map]";
}
function isMapIterator2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Module]";
}
function isNativeError2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Error]";
}
function isNumberObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Number]";
}
function isBigIntObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object BigInt]";
}
function isPromise2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Promise]";
}
function isRegExp2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object RegExp]";
}
function isSet2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Set]";
}
function isSetIterator2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object String]";
}
function isSymbolObject2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Symbol]";
}
function isWeakMap2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object WeakMap]";
}
function isWeakSet2(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object WeakSet]";
}
const __default1 = {
    isAsyncFunction: isAsyncFunction2,
    isGeneratorFunction: isGeneratorFunction2,
    isAnyArrayBuffer: isAnyArrayBuffer2,
    isArrayBuffer: isArrayBuffer2,
    isArgumentsObject: isArgumentsObject2,
    isBoxedPrimitive: isBoxedPrimitive2,
    isDataView: isDataView2,
    isMap: isMap2,
    isMapIterator: isMapIterator2,
    isModuleNamespaceObject: isModuleNamespaceObject2,
    isNativeError: isNativeError2,
    isPromise: isPromise2,
    isSet: isSet2,
    isSetIterator: isSetIterator2,
    isWeakMap: isWeakMap2,
    isWeakSet: isWeakSet2,
    isRegExp: isRegExp2,
    isDate: isDate2,
    isStringObject: isStringObject2,
    isNumberObject: isNumberObject2,
    isBooleanObject: isBooleanObject2,
    isBigIntObject: isBigIntObject2
};
const mod3 = {
    isAnyArrayBuffer: isAnyArrayBuffer2,
    isArgumentsObject: isArgumentsObject2,
    isArrayBuffer: isArrayBuffer2,
    isAsyncFunction: isAsyncFunction2,
    isBooleanObject: isBooleanObject2,
    isBoxedPrimitive: isBoxedPrimitive2,
    isDataView: isDataView2,
    isDate: isDate2,
    isGeneratorFunction: isGeneratorFunction2,
    isGeneratorObject: isGeneratorObject2,
    isMap: isMap2,
    isMapIterator: isMapIterator2,
    isModuleNamespaceObject: isModuleNamespaceObject2,
    isNativeError: isNativeError2,
    isNumberObject: isNumberObject2,
    isBigIntObject: isBigIntObject2,
    isPromise: isPromise2,
    isRegExp: isRegExp2,
    isSet: isSet2,
    isSetIterator: isSetIterator2,
    isSharedArrayBuffer: isSharedArrayBuffer2,
    isStringObject: isStringObject2,
    isSymbolObject: isSymbolObject2,
    isWeakMap: isWeakMap2,
    isWeakSet: isWeakSet2,
    default: __default1
};
Symbol("kHandle");
Symbol("kKeyObject");
Symbol("kKeyType");
const _getTypedArrayToStringTag1 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
function isArrayBufferView1(value) {
    return ArrayBuffer.isView(value);
}
function isTypedArray(value) {
    return _getTypedArrayToStringTag1.call(value) !== undefined;
}
function isUint8Array1(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint8Array";
}
const { isDate: isDate3 , isArgumentsObject: isArgumentsObject3 , isBigIntObject: isBigIntObject3 , isBooleanObject: isBooleanObject3 , isNumberObject: isNumberObject3 , isStringObject: isStringObject3 , isSymbolObject: isSymbolObject3 , isNativeError: isNativeError3 , isRegExp: isRegExp3 , isAsyncFunction: isAsyncFunction3 , isGeneratorFunction: isGeneratorFunction3 , isGeneratorObject: isGeneratorObject3 , isPromise: isPromise3 , isMap: isMap3 , isSet: isSet3 , isMapIterator: isMapIterator3 , isSetIterator: isSetIterator3 , isWeakMap: isWeakMap3 , isWeakSet: isWeakSet3 , isArrayBuffer: isArrayBuffer3 , isDataView: isDataView3 , isSharedArrayBuffer: isSharedArrayBuffer3 , isModuleNamespaceObject: isModuleNamespaceObject3 , isAnyArrayBuffer: isAnyArrayBuffer3 , isBoxedPrimitive: isBoxedPrimitive3  } = mod3;
function hideStackFrames1(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding2(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases2(enc);
}
function slowCases2(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt321(value) {
    return value === (value | 0);
}
function isUint321(value) {
    return value === value >>> 0;
}
const validateBuffer1 = hideStackFrames1((buffer, name = "buffer")=>{
    if (!isArrayBufferView1(buffer)) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames1((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames1((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames1((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt321(value)) {
        if (typeof value !== "number") {
            throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames1((value, name, positive)=>{
    if (!isUint321(value)) {
        if (typeof value !== "number") {
            throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes1.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
function validateBoolean(value, name) {
    if (typeof value !== "boolean") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
}
hideStackFrames1((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes1.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
const validateAbortSignal = hideStackFrames1((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction1 = hideStackFrames1((value, name)=>{
    if (typeof value !== "function") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames1((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes1.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
function guessHandleType(_fd) {
    notImplemented("util.guessHandleType");
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj)
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod4 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol1 = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol1;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i)}${meta[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol1];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet3(value)) {
            const size = value.size;
            const prefix1 = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix1}{}`;
            }
            braces = [
                `${prefix1}{`,
                "}"
            ];
        } else if (isMap3(value)) {
            const size1 = value.size;
            const prefix2 = getPrefix(constructor, tag, "Map", `(${size1})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size1 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix2}{}`;
            }
            braces = [
                `${prefix2}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            if (constructor === null) {}
            const size2 = value.length;
            const prefix3 = getPrefix(constructor, tag, fallback, `(${size2})`);
            braces = [
                `${prefix3}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size2);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator3(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator3(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject3(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp3(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix4 = getPrefix(constructor, tag, "RegExp");
            if (prefix4 !== "RegExp ") {
                base = `${prefix4}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate3(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix5 = getPrefix(constructor, tag, "Date");
            if (prefix5 !== "Date ") {
                base = `${prefix5}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer3(value)) {
            const arrayType = isArrayBuffer3(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix6 = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix6 + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix6}{`;
            Array.prototype.unshift.call(keys, "byteLength");
        } else if (isDataView3(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise3(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet3(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap3(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject3(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive3(value)) {
            base = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName1 = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName1, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach.call(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push.call(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push.call(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push.call(output, value);
            }
        }
        Array.prototype.pop.call(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push.call(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer"
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push.call(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString.call(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction3(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction3(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name1 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name1);
            if (index !== -1 && stack.includes(err[name1])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos1 = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos1, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos1 = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos1 === 0 ? line : line.slice(pos1);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp1 = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp1, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp2 = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp2}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending1 = remaining > 1 ? "s" : "";
            const message1 = `<${remaining} empty item${ending1}>`;
            output.push(ctx.stylize(message1, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject3(value)) {
        type = "Number";
    } else if (isStringObject3(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject3(value)) {
        type = "Boolean";
    } else if (isBigIntObject3(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation1 = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation1}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation1}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i1 = 0; i1 < columns; i1++){
            let lineMaxLength = 0;
            for(let j = i1; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i1] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i2 = 0; i2 < output.length; i2++){
                if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i3 = 0; i3 < outputLength; i3 += columns){
            const max = Math.min(i3 + columns, outputLength);
            let str = "";
            let j1 = i3;
            for(; j1 < max - 1; j1++){
                const padding = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1];
                str += `${output[j1]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding1 = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1] - 2;
                str += output[j1].padStart(padding1, " ");
            } else {
                str += output[j1];
            }
            Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos1 = i * 2;
            const res = [
                formatValue(ctx, entries[pos1], recurseTimes),
                formatValue(ctx, entries[pos1 + 1], recurseTimes)
            ];
            output[i] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
const { errno: { ENOTDIR , ENOENT  }  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
];
class AbortError extends Error {
    code;
    constructor(message = "The operation was aborted", options){
        if (options !== undefined && typeof options !== "object") {
            throw new codes1.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace = hideStackFrames1(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames1(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames1(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames1(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames1(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames1(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last1 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last1}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert1(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CURSOR_POS extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert1(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes1.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes1.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes1.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes1.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes1.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes1.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes1.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames1(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on2;
EventEmitter.once = once;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.setMaxListeners = setMaxListeners;
EventEmitter.listenerCount = listenerCount;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction1(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
function setMaxListeners(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i = 0; i < eventTargets.length; i++){
            const target = eventTargets[i];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
}
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i = 0; i < len; ++i){
            const result1 = listeners[i].apply(this, args);
            if (result1 !== undefined && result1 !== null) {
                addCatch(this, result1, type, args);
            }
        }
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
const _listenerCount = function listenerCount(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
};
EventEmitter.prototype.listenerCount = _listenerCount;
function listenerCount(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return _listenerCount.call(emitter, type);
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i = 0; i < ret.length; ++i){
        const orig = ret[i].listener;
        if (typeof orig === "function") {
            ret[i] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once(emitter, name, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve(args);
        };
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on2(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
            }
            if (finished) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve, reject) {
                unconsumedPromises.push({
                    resolve,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert1(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key = keys[keys.length - 1];
    return hasOwn(o, key);
}
function parse5(args, { "--": doubleDash = false , alias ={} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect =[] , negatable =[] , unknown =(i)=>i  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias !== undefined) {
        for(const key1 in alias){
            const val = getForce(alias, key1);
            if (typeof val === "string") {
                aliases[key1] = [
                    val
                ];
            } else {
                aliases[key1] = val;
            }
            for (const alias1 of getForce(aliases, key1)){
                aliases[alias1] = [
                    key1
                ].concat(aliases[key1].filter((y)=>alias1 !== y));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key2 of stringArgs.filter(Boolean)){
            flags.strings[key2] = true;
            const alias2 = get(aliases, key2);
            if (alias2) {
                for (const al of alias2){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect !== undefined) {
        const collectArgs = typeof collect === "string" ? [
            collect
        ] : collect;
        for (const key3 of collectArgs.filter(Boolean)){
            flags.collect[key3] = true;
            const alias3 = get(aliases, key3);
            if (alias3) {
                for (const al1 of alias3){
                    flags.collect[al1] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key4 of negatableArgs.filter(Boolean)){
            flags.negatable[key4] = true;
            const alias4 = get(aliases, key4);
            if (alias4) {
                for (const al2 of alias4){
                    flags.negatable[al2] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, name, value, collect = true) {
        let o = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key = keys[keys.length - 1];
        const collectable = collect && !!get(flags.collect, name);
        if (!collectable) {
            o[key] = value;
        } else if (get(o, key) === undefined) {
            o[key] = [
                value
            ];
        } else if (Array.isArray(get(o, key))) {
            o[key].push(value);
        } else {
            o[key] = [
                get(o, key),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv, key, value, collect);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean");
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert1(m != null);
            const [, key5, value] = m;
            if (flags.bools[key5]) {
                const booleanValue = value !== "false";
                setArg(key5, booleanValue, arg);
            } else {
                setArg(key5, value, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
            const m1 = arg.match(/^--no-(.+)/);
            assert1(m1 != null);
            setArg(m1[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m2 = arg.match(/^--(.+)/);
            assert1(m2 != null);
            const [, key6] = m2;
            const next = args[i + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key6) && !flags.allBools && (get(aliases, key6) ? !aliasIsBoolean(key6) : true)) {
                setArg(key6, next, arg);
                i++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key6, next === "true", arg);
                i++;
            } else {
                setArg(key6, get(flags.strings, key6) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next1 = arg.slice(j + 2);
                if (next1 === "-") {
                    setArg(letters[j], next1, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next1)) {
                    setArg(letters[j], next1.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next1)) {
                    setArg(letters[j], next1, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key7] = arg.slice(-1);
            if (!broken && key7 !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key7) && (get(aliases, key7) ? !aliasIsBoolean(key7) : true)) {
                    setArg(key7, args[i + 1], arg);
                    i++;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key7, args[i + 1] === "true", arg);
                    i++;
                } else {
                    setArg(key7, get(flags.strings, key7) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args.slice(i + 1));
                break;
            }
        }
    }
    for (const [key8, value1] of Object.entries(defaults)){
        if (!hasKey(argv, key8.split("."))) {
            setKey(argv, key8, value1);
            if (aliases[key8]) {
                for (const x of aliases[key8]){
                    setKey(argv, x, value1);
                }
            }
        }
    }
    for (const key9 of Object.keys(flags.bools)){
        if (!hasKey(argv, key9.split("."))) {
            const value2 = get(flags.collect, key9) ? [] : false;
            setKey(argv, key9, value2, false);
        }
    }
    for (const key10 of Object.keys(flags.strings)){
        if (!hasKey(argv, key10.split(".")) && get(flags.collect, key10)) {
            setKey(argv, key10, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key11 of notFlags){
            argv["--"].push(key11);
        }
    } else {
        for (const key12 of notFlags){
            argv._.push(key12);
        }
    }
    return argv;
}
function getOptions() {
    const args = parse5(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize1(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join1(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize1(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse6(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod5 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize1,
    isAbsolute: isAbsolute,
    join: join1,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse6,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize2(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join2(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize2(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse7(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod6 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize2,
    isAbsolute: isAbsolute1,
    join: join2,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse7,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod5 : mod6;
const { join: join3 , normalize: normalize3  } = path;
const path1 = isWindows ? mod5 : mod6;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join4 , normalize: normalize4 , parse: parse8 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        },
        eventLoopHasMoreWork () {
            return false;
        },
        ops: {
            op_napi_open (_filename) {
                throw new Error("Node API is not supported in this environment");
            }
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
function processTicksAndRejections() {
    let tock;
    do {
        while(tock = queue.shift()){
            try {
                const callback = tock.callback;
                if (tock.args === undefined) {
                    callback();
                } else {
                    const args = tock.args;
                    switch(args.length){
                        case 1:
                            callback(args[0]);
                            break;
                        case 2:
                            callback(args[0], args[1]);
                            break;
                        case 3:
                            callback(args[0], args[1], args[2]);
                            break;
                        case 4:
                            callback(args[0], args[1], args[2], args[3]);
                            break;
                        default:
                            callback(...args);
                    }
                }
            } finally{}
        }
        core.runMicrotasks();
    }while (!queue.isEmpty())
    core.setHasTickScheduled(false);
}
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateFunction1(callback, "callback");
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick1(callback, ...args) {
    _nextTick(callback, ...args);
}
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
function denoEnvGet(name) {
    try {
        return Deno.env.get(name);
    } catch (e) {
        if (e instanceof TypeError) {
            return undefined;
        }
        throw e;
    }
}
const OBJECT_PROTO_PROP_NAMES = Object.getOwnPropertyNames(Object.prototype);
const env = new Proxy(Object(), {
    get: (target, prop)=>{
        if (typeof prop === "symbol") {
            return target[prop];
        }
        const envValue = denoEnvGet(prop);
        if (envValue) {
            return envValue;
        }
        if (OBJECT_PROTO_PROP_NAMES.includes(prop)) {
            return target[prop];
        }
        return envValue;
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name)=>{
        const value = denoEnvGet(String(name));
        if (value) {
            return {
                enumerable: true,
                configurable: true,
                value
            };
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return true;
    },
    has: (_target, prop)=>typeof denoEnvGet(String(prop)) === "string"
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v16.17.0";
const versions = {
    node: "16.17.0",
    uv: "1.43.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.18.1",
    modules: "93",
    nghttp2: "1.47.0",
    napi: "8",
    llhttp: "6.0.7",
    openssl: "1.1.1q+quic",
    cldr: "41.0",
    icu: "71.1",
    tz: "2022a",
    unicode: "14.0",
    ...Deno.version
};
var Encodings1;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings1 || (Encodings1 = {}));
const encodings1 = [];
encodings1[Encodings1.ASCII] = "ascii";
encodings1[Encodings1.BASE64] = "base64";
encodings1[Encodings1.BASE64URL] = "base64url";
encodings1[Encodings1.BUFFER] = "buffer";
encodings1[Encodings1.HEX] = "hex";
encodings1[Encodings1.LATIN1] = "latin1";
encodings1[Encodings1.UCS2] = "utf16le";
encodings1[Encodings1.UTF8] = "utf8";
const __default2 = {
    encodings: encodings1
};
const mod7 = {
    encodings: encodings1,
    default: __default2
};
function numberToBytes1(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex1(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer1(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings1[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex1(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle1(targetBuffer, buffer, byteOffset);
}
function indexOfNumber1(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes1(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer1(targetBuffer, numberToBytes1(number), byteOffset, Encodings1.UTF8, forwardDirection);
}
const __default3 = {
    indexOfBuffer: indexOfBuffer1,
    indexOfNumber: indexOfNumber1
};
const mod8 = {
    indexOfBuffer: indexOfBuffer1,
    indexOfNumber: indexOfNumber1,
    numberToBytes: numberToBytes1,
    default: __default3
};
const base64abc1 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode2(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc1[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode2(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url1(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase641(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url1(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url1(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode3(data) {
    return convertBase64ToBase64url1(encode2(data));
}
function decode3(b64url) {
    return decode2(convertBase64urlToBase641(b64url));
}
function asciiToBytes1(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes1(str) {
    str = base64clean1(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode2(str);
}
const INVALID_BASE64_RE1 = /[^+/0-9A-Za-z-_]/g;
function base64clean1(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE1, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes1(str) {
    str = base64clean1(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode3(str);
}
function hexToBytes1(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes1(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii1(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le1(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Array.isArray;
Object.assign;
Object.create;
Object.hasOwn;
RegExp.prototype.exec;
String.fromCharCode;
const { signals  } = os;
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty1 = Object.create(null);
kEnumerableProperty1.enumerable = true;
const kEmptyObject = Object.freeze(Object.create(null));
function once1(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
new Set();
const kCustomPromisifiedSymbol1 = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol1 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify1(original) {
    validateFunction1(original, "original");
    if (original[kCustomPromisifiedSymbol1]) {
        const fn = original[kCustomPromisifiedSymbol1];
        validateFunction1(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol1, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol1];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol1, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify1.custom = kCustomPromisifiedSymbol1;
const utf8Encoder1 = new TextEncoder();
const float32Array1 = new Float32Array(1);
const uInt8Float32Array1 = new Uint8Array(float32Array1.buffer);
const float64Array1 = new Float64Array(1);
const uInt8Float64Array1 = new Uint8Array(float64Array1.buffer);
float32Array1[0] = -1;
const bigEndian1 = uInt8Float32Array1[3] === 0;
const kMaxLength1 = 2147483647;
const MAX_UINT321 = 2 ** 32;
const customInspectSymbol2 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES1 = 50;
const constants = {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 536870888
};
Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer2.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer2.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer1(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
}
function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes1.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe1(arg);
    }
    return _from1(arg, encodingOrOffset, length);
}
Buffer2.poolSize = 8192;
function _from1(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString1(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer3(value)) {
            return fromArrayBuffer1(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from1(valueOf, encodingOrOffset, length);
        }
        const b = fromObject1(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString1(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes1.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer2.from = function from(value, encodingOrOffset, length) {
    return _from1(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer2, Uint8Array);
function assertSize1(size) {
    validateNumber1(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes1.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc1(size, fill, encoding) {
    assertSize1(size);
    const buffer = createBuffer1(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes1.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer2.alloc = function alloc(size, fill, encoding) {
    return _alloc1(size, fill, encoding);
};
function _allocUnsafe1(size) {
    assertSize1(size);
    return createBuffer1(size < 0 ? 0 : checked1(size) | 0);
}
Buffer2.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe1(size);
};
Buffer2.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe1(size);
};
function fromString1(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
        throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength1(string, encoding) | 0;
    let buf = createBuffer1(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike1(array) {
    const length = array.length < 0 ? 0 : checked1(array.length) | 0;
    const buf = createBuffer1(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject1(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer3(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer1(0);
        }
        return fromArrayLike1(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike1(obj.data);
    }
}
function checked1(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer1(length) {
    assertSize1(length);
    return Buffer2.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer1, Uint8Array);
Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
};
Buffer2.compare = function compare(a, b) {
    if (isInstance1(a, Uint8Array)) {
        a = Buffer2.from(a, a.offset, a.byteLength);
    }
    if (isInstance1(b, Uint8Array)) {
        b = Buffer2.from(b, b.offset, b.byteLength);
    }
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding2(encoding) !== undefined;
};
Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer2.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset1(length, "length");
    }
    const buffer = Buffer2.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array1(buf)) {
            throw new codes1.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual1(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength1(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView1(string) || isAnyArrayBuffer3(string)) {
            return string.byteLength;
        }
        throw new codes1.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf81(string);
    }
    const ops = getEncodingOps1(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf81(string);
    }
    return ops.byteLength(string);
}
Buffer2.byteLength = byteLength1;
Buffer2.prototype._isBuffer = true;
function swap1(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap1(this, i, i + 1);
    }
    return this;
};
Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap1(this, i, i + 3);
        swap1(this, i + 1, i + 2);
    }
    return this;
};
Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap1(this, i, i + 7);
        swap1(this, i + 1, i + 6);
        swap1(this, i + 2, i + 5);
        swap1(this, i + 3, i + 4);
    }
    return this;
};
Buffer2.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps1(encoding);
    if (ops === undefined) {
        throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
Buffer2.prototype.equals = function equals(b) {
    if (!isUint8Array1(b)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer2.compare(this, b) === 0;
};
Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES1;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol2) {
    Buffer2.prototype[customInspectSymbol2] = Buffer2.prototype.inspect;
}
Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance1(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset1(start, "targetStart", 0, kMaxLength1);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset1(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset1(start, "sourceStart", 0, kMaxLength1);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset1(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes1.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf1(buffer, val, byteOffset, encoding, dir) {
    validateBuffer1(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber1(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps1.utf8;
    } else {
        ops = getEncodingOps1(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array1(val)) {
        const encodingVal = ops === undefined ? encodingsMap1.utf8 : ops.encodingVal;
        return indexOfBuffer1(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes1.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf1(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf1(this, val, byteOffset, encoding, false);
};
Buffer2.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii1(this);
    } else {
        return bytesToAscii1(this.slice(offset, length));
    }
};
Buffer2.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer1(asciiToBytes1(string), this, offset, length);
};
Buffer2.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode2(this);
    } else {
        return encode2(this.slice(offset, length));
    }
};
Buffer2.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer1(base64ToBytes1(string), this, offset, length);
};
Buffer2.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode3(this);
    } else {
        return encode3(this.slice(offset, length));
    }
};
Buffer2.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer1(base64UrlToBytes1(string), this, offset, length);
};
Buffer2.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer1(hexToBytes1(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice1(this, string, offset, length);
};
Buffer2.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice1(this, string, offset, length);
};
Buffer2.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer1(asciiToBytes1(string), this, offset, length);
};
Buffer2.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le1(this);
    } else {
        return bytesToUtf16le1(this.slice(offset, length));
    }
};
Buffer2.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer1(utf16leToBytes1(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice1(this, string, offset, length);
};
Buffer2.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer1(utf8ToBytes1(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset1(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset1(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps1(encoding);
    if (ops === undefined) {
        throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer2.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer1(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer2.prototype);
    return buffer;
}
function _utf8Slice1(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray1(res);
}
const MAX_ARGUMENTS_LENGTH1 = 4096;
function decodeCodePointsArray1(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH1));
    }
    return res;
}
function _latin1Slice1(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice1(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable1[buf[i]];
    }
    return out;
}
Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
};
Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE1(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE1(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE1(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE1(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError1(offset, this.length - 1);
    }
    return val;
};
Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = readUInt16BE1;
Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = readUInt32BE1;
Buffer2.prototype.readBigUint64LE = Buffer2.prototype.readBigUInt64LE = defineBigIntMethod1(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer2.prototype.readBigUint64BE = Buffer2.prototype.readBigUInt64BE = defineBigIntMethod1(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE1(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE1(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE1(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE1(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError1(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer2.prototype.readBigInt64LE = defineBigIntMethod1(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer2.prototype.readBigInt64BE = defineBigIntMethod1(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer2.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian1 ? readFloatBackwards1(this, offset) : readFloatForwards1(this, offset);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian1 ? readFloatForwards1(this, offset) : readFloatBackwards1(this, offset);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian1 ? readDoubleBackwards1(this, offset) : readDoubleForwards1(this, offset);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian1 ? readDoubleForwards1(this, offset) : readDoubleBackwards1(this, offset);
};
Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE1(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE1(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE1(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE1(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE1(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, 0, 0xff);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE1(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE1(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE1(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE1(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE1(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, 0, 0xff);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int81(this, value, offset, 0, 0xff);
};
Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE1(this, value, offset, 0, 0xffff);
};
Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE1(this, value, offset, 0, 0xffff);
};
Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE1(this, value, offset, 0, 0xffffffff);
};
Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE1(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE1(buf, value, offset, min, max) {
    checkIntBI1(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE1(buf, value, offset, min, max) {
    checkIntBI1(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer2.prototype.writeBigUint64LE = Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod1(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE1(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer2.prototype.writeBigUint64BE = Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod1(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE1(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE1(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE1(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE1(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE1(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE1(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, -0x80, 0x7f);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE1(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE1(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE1(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE1(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE1(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, -0x80, 0x7f);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int81(this, value, offset, -0x80, 0x7f);
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE1(this, value, offset, -0x8000, 0x7fff);
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE1(this, value, offset, -0x8000, 0x7fff);
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE1(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE1(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer2.prototype.writeBigInt64LE = defineBigIntMethod1(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE1(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer2.prototype.writeBigInt64BE = defineBigIntMethod1(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE1(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian1 ? writeFloatBackwards1(this, value, offset) : writeFloatForwards1(this, value, offset);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian1 ? writeFloatForwards1(this, value, offset) : writeFloatBackwards1(this, value, offset);
};
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian1 ? writeDoubleBackwards1(this, value, offset) : writeDoubleForwards1(this, value, offset);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian1 ? writeDoubleForwards1(this, value, offset) : writeDoubleBackwards1(this, value, offset);
};
Buffer2.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array1(this)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array1(target)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger1(targetStart, 0);
        if (targetStart < 0) {
            throw new codes1.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger1(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT321) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT321}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger1(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT321) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT321}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes1.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds2(buf, offset, byteLength2) {
    validateNumber1(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError1(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI1(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes1.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds2(buf, offset, byteLength2);
}
function utf8ToBytes1(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer1(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance1(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable1 = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod1(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined1 : fn;
}
function BufferBigIntNotDefined1() {
    throw new Error("BigInt not supported");
}
const atob1 = globalThis.atob;
const Blob1 = globalThis.Blob;
const btoa1 = globalThis.btoa;
function readUInt48LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE1(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE1(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 8);
    }
    uInt8Float64Array1[7] = first;
    uInt8Float64Array1[6] = buffer[++offset];
    uInt8Float64Array1[5] = buffer[++offset];
    uInt8Float64Array1[4] = buffer[++offset];
    uInt8Float64Array1[3] = buffer[++offset];
    uInt8Float64Array1[2] = buffer[++offset];
    uInt8Float64Array1[1] = buffer[++offset];
    uInt8Float64Array1[0] = last;
    return float64Array1[0];
}
function readDoubleForwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 8);
    }
    uInt8Float64Array1[0] = first;
    uInt8Float64Array1[1] = buffer[++offset];
    uInt8Float64Array1[2] = buffer[++offset];
    uInt8Float64Array1[3] = buffer[++offset];
    uInt8Float64Array1[4] = buffer[++offset];
    uInt8Float64Array1[5] = buffer[++offset];
    uInt8Float64Array1[6] = buffer[++offset];
    uInt8Float64Array1[7] = last;
    return float64Array1[0];
}
function writeDoubleForwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 7);
    float64Array1[0] = val;
    buffer[offset++] = uInt8Float64Array1[0];
    buffer[offset++] = uInt8Float64Array1[1];
    buffer[offset++] = uInt8Float64Array1[2];
    buffer[offset++] = uInt8Float64Array1[3];
    buffer[offset++] = uInt8Float64Array1[4];
    buffer[offset++] = uInt8Float64Array1[5];
    buffer[offset++] = uInt8Float64Array1[6];
    buffer[offset++] = uInt8Float64Array1[7];
    return offset;
}
function writeDoubleBackwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 7);
    float64Array1[0] = val;
    buffer[offset++] = uInt8Float64Array1[7];
    buffer[offset++] = uInt8Float64Array1[6];
    buffer[offset++] = uInt8Float64Array1[5];
    buffer[offset++] = uInt8Float64Array1[4];
    buffer[offset++] = uInt8Float64Array1[3];
    buffer[offset++] = uInt8Float64Array1[2];
    buffer[offset++] = uInt8Float64Array1[1];
    buffer[offset++] = uInt8Float64Array1[0];
    return offset;
}
function readFloatBackwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 4);
    }
    uInt8Float32Array1[3] = first;
    uInt8Float32Array1[2] = buffer[++offset];
    uInt8Float32Array1[1] = buffer[++offset];
    uInt8Float32Array1[0] = last;
    return float32Array1[0];
}
function readFloatForwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 4);
    }
    uInt8Float32Array1[0] = first;
    uInt8Float32Array1[1] = buffer[++offset];
    uInt8Float32Array1[2] = buffer[++offset];
    uInt8Float32Array1[3] = last;
    return float32Array1[0];
}
function writeFloatForwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 3);
    float32Array1[0] = val;
    buffer[offset++] = uInt8Float32Array1[0];
    buffer[offset++] = uInt8Float32Array1[1];
    buffer[offset++] = uInt8Float32Array1[2];
    buffer[offset++] = uInt8Float32Array1[3];
    return offset;
}
function writeFloatBackwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 3);
    float32Array1[0] = val;
    buffer[offset++] = uInt8Float32Array1[3];
    buffer[offset++] = uInt8Float32Array1[2];
    buffer[offset++] = uInt8Float32Array1[1];
    buffer[offset++] = uInt8Float32Array1[0];
    return offset;
}
function readInt24LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf81(str) {
    return utf8Encoder1.encode(str).length;
}
function base64ByteLength1(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap1 = Object.create(null);
for(let i8 = 0; i8 < encodings1.length; ++i8){
    encodingsMap1[encodings1[i8]] = i8;
}
const encodingOps1 = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap1.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, asciiToBytes1(val), byteOffset, encodingsMap1.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength1(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap1.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, base64ToBytes1(val), byteOffset, encodingsMap1.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength1(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap1.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, base64UrlToBytes1(val), byteOffset, encodingsMap1.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap1.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, hexToBytes1(val), byteOffset, encodingsMap1.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap1.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, asciiToBytes1(val), byteOffset, encodingsMap1.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap1.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, utf16leToBytes1(val), byteOffset, encodingsMap1.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf81,
        encoding: "utf8",
        encodingVal: encodingsMap1.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, utf8Encoder1.encode(val), byteOffset, encodingsMap1.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap1.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, utf16leToBytes1(val), byteOffset, encodingsMap1.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps1(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps1.utf8;
            if (encoding === "ucs2") return encodingOps1.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps1.utf8;
            if (encoding === "ascii") return encodingOps1.ascii;
            if (encoding === "ucs-2") return encodingOps1.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps1.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps1.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps1.latin1;
            }
            if (encoding === "base64") return encodingOps1.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps1.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps1.base64url;
            }
            break;
    }
}
function _copyActual1(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError1(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber1(value, type);
        throw new codes1.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes1.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber1(value, name) {
    if (typeof value !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkInt1(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes1.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds2(buf, offset, byteLength);
}
function toInteger1(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int81(buf, value, offset, min, max) {
    value = +value;
    validateNumber1(offset, "offset");
    if (value > max || value < min) {
        throw new codes1.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError1(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset1(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const __default4 = {
    atob: atob1,
    btoa: btoa1,
    Blob: Blob1,
    Buffer: Buffer2,
    constants,
    kMaxLength: 2147483647,
    kStringMaxLength: 536870888,
    SlowBuffer: SlowBuffer1
};
"use strict";
const kEscape = "\x1b";
Symbol("kSubstringSearch");
function CSI(strings, ...args) {
    let ret = `${kEscape}[`;
    for(let n = 0; n < strings.length; n++){
        ret += strings[n];
        if (n < args.length) {
            ret += args[n];
        }
    }
    return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;
"use strict";
const { kClearLine , kClearScreenDown , kClearToLineBeginning , kClearToLineEnd  } = CSI;
function cursorTo(stream, x, y, callback) {
    if (callback !== undefined) {
        validateFunction1(callback, "callback");
    }
    if (typeof y === "function") {
        callback = y;
        y = undefined;
    }
    if (Number.isNaN(x)) throw new ERR_INVALID_ARG_VALUE("x", x);
    if (Number.isNaN(y)) throw new ERR_INVALID_ARG_VALUE("y", y);
    if (stream == null || typeof x !== "number" && typeof y !== "number") {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    if (typeof x !== "number") throw new ERR_INVALID_CURSOR_POS();
    const data = typeof y !== "number" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
    return stream.write(data, callback);
}
function moveCursor(stream, dx, dy, callback) {
    if (callback !== undefined) {
        validateFunction1(callback, "callback");
    }
    if (stream == null || !(dx || dy)) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    let data = "";
    if (dx < 0) {
        data += CSI`${-dx}D`;
    } else if (dx > 0) {
        data += CSI`${dx}C`;
    }
    if (dy < 0) {
        data += CSI`${-dy}A`;
    } else if (dy > 0) {
        data += CSI`${dy}B`;
    }
    return stream.write(data, callback);
}
function clearLine(stream, dir, callback) {
    if (callback !== undefined) {
        validateFunction1(callback, "callback");
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    const type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;
    return stream.write(type, callback);
}
function clearScreenDown(stream, callback) {
    if (callback !== undefined) {
        validateFunction1(callback, "callback");
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    return stream.write(kClearScreenDown, callback);
}
const stdio = {};
var NotImplemented;
(function(NotImplemented) {
    NotImplemented[NotImplemented["ascii"] = 0] = "ascii";
    NotImplemented[NotImplemented["latin1"] = 1] = "latin1";
    NotImplemented[NotImplemented["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding3(enc) {
    const encoding = normalizeEncoding1(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self1, buf, i) {
    let j = buf.length - 1;
    if (j < i) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self1.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self1, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self1.lastNeed = 0;
        return "\ufffd";
    }
    if (self1.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self1.lastNeed = 1;
            return "\ufffd";
        }
        if (self1.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self1.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
    const total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
}
function base64Text(buf, i) {
    const n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer2.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding3(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding3(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding3(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
const PStringDecoder = new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
const __default5 = {
    StringDecoder: PStringDecoder
};
const kDestroy = Symbol("kDestroy");
Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self1, err, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self1._readableState;
        const w = self1._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick1(emitErrorCloseNT, self1, err);
        } else {
            nextTick1(emitCloseNT, self1);
        }
    }
    try {
        const result = self1._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick1(onDestroy, null);
                }, function(err) {
                    nextTick1(onDestroy, err);
                });
            }
        }
    } catch (err1) {
        onDestroy(err1);
    }
}
function emitErrorCloseNT(self1, err) {
    emitErrorNT(self1, err);
    emitCloseNT(self1);
}
function emitCloseNT(self1) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self1.emit("close");
    }
}
function emitErrorNT(self1, err) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self1.emit("error", err);
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction1(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once1(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick1(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick1(abort);
        } else {
            const originalCallback = callback;
            callback = once1((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded1(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const __process$ = {
    nextTick: nextTick1,
    stdio
};
var pi1 = Object.create;
var Bt1 = Object.defineProperty;
var wi1 = Object.getOwnPropertyDescriptor;
var yi1 = Object.getOwnPropertyNames;
var gi1 = Object.getPrototypeOf, Si1 = Object.prototype.hasOwnProperty;
((e)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
        get: (t, n)=>(typeof require < "u" ? require : t)[n]
    }) : e)(function(e) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var g10 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var Ei1 = (e, t, n, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of yi1(t))!Si1.call(e, i) && i !== n && Bt1(e, i, {
        get: ()=>t[i],
        enumerable: !(r = wi1(t, i)) || r.enumerable
    });
    return e;
};
var Ri2 = (e, t, n)=>(n = e != null ? pi1(gi1(e)) : {}, Ei1(t || !e || !e.__esModule ? Bt1(n, "default", {
        value: e,
        enumerable: !0
    }) : n, e));
var m6 = g10((Yf, Gt)=>{
    "use strict";
    Gt.exports = {
        ArrayIsArray (e) {
            return Array.isArray(e);
        },
        ArrayPrototypeIncludes (e, t) {
            return e.includes(t);
        },
        ArrayPrototypeIndexOf (e, t) {
            return e.indexOf(t);
        },
        ArrayPrototypeJoin (e, t) {
            return e.join(t);
        },
        ArrayPrototypeMap (e, t) {
            return e.map(t);
        },
        ArrayPrototypePop (e, t) {
            return e.pop(t);
        },
        ArrayPrototypePush (e, t) {
            return e.push(t);
        },
        ArrayPrototypeSlice (e, t, n) {
            return e.slice(t, n);
        },
        Error,
        FunctionPrototypeCall (e, t, ...n) {
            return e.call(t, ...n);
        },
        FunctionPrototypeSymbolHasInstance (e, t) {
            return Function.prototype[Symbol.hasInstance].call(e, t);
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties (e, t) {
            return Object.defineProperties(e, t);
        },
        ObjectDefineProperty (e, t, n) {
            return Object.defineProperty(e, t, n);
        },
        ObjectGetOwnPropertyDescriptor (e, t) {
            return Object.getOwnPropertyDescriptor(e, t);
        },
        ObjectKeys (e) {
            return Object.keys(e);
        },
        ObjectSetPrototypeOf (e, t) {
            return Object.setPrototypeOf(e, t);
        },
        Promise,
        PromisePrototypeCatch (e, t) {
            return e.catch(t);
        },
        PromisePrototypeThen (e, t, n) {
            return e.then(t, n);
        },
        PromiseReject (e) {
            return Promise.reject(e);
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest (e, t) {
            return e.test(t);
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice (e, t, n) {
            return e.slice(t, n);
        },
        StringPrototypeToLowerCase (e) {
            return e.toLowerCase();
        },
        StringPrototypeToUpperCase (e) {
            return e.toUpperCase();
        },
        StringPrototypeTrim (e) {
            return e.trim();
        },
        Symbol,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        TypedArrayPrototypeSet (e, t, n) {
            return e.set(t, n);
        },
        Uint8Array
    };
});
var j13 = g10((Kf, Je)=>{
    "use strict";
    var Ai = __default4, mi = Object.getPrototypeOf(async function() {}).constructor, Ht = globalThis.Blob || Ai.Blob, Ti = typeof Ht < "u" ? function(t) {
        return t instanceof Ht;
    } : function(t) {
        return !1;
    }, Xe = class extends Error {
        constructor(t){
            if (!Array.isArray(t)) throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
            let n = "";
            for(let r = 0; r < t.length; r++)n += `    ${t[r].stack}
`;
            super(n), this.name = "AggregateError", this.errors = t;
        }
    };
    Je.exports = {
        AggregateError: Xe,
        kEmptyObject: Object.freeze({}),
        once (e) {
            let t = !1;
            return function(...n) {
                t || (t = !0, e.apply(this, n));
            };
        },
        createDeferredPromise: function() {
            let e, t;
            return {
                promise: new Promise((r, i)=>{
                    e = r, t = i;
                }),
                resolve: e,
                reject: t
            };
        },
        promisify (e) {
            return new Promise((t, n)=>{
                e((r, ...i)=>r ? n(r) : t(...i));
            });
        },
        debuglog () {
            return function() {};
        },
        format (e, ...t) {
            return e.replace(/%([sdifj])/g, function(...[n, r]) {
                let i = t.shift();
                return r === "f" ? i.toFixed(6) : r === "j" ? JSON.stringify(i) : r === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
            });
        },
        inspect (e) {
            switch(typeof e){
                case "string":
                    if (e.includes("'")) if (e.includes('"')) {
                        if (!e.includes("`") && !e.includes("${")) return `\`${e}\``;
                    } else return `"${e}"`;
                    return `'${e}'`;
                case "number":
                    return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
                case "bigint":
                    return `${String(e)}n`;
                case "boolean":
                case "undefined":
                    return String(e);
                case "object":
                    return "{}";
            }
        },
        types: {
            isAsyncFunction (e) {
                return e instanceof mi;
            },
            isArrayBufferView (e) {
                return ArrayBuffer.isView(e);
            }
        },
        isBlob: Ti
    };
    Je.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});
var O13 = g10((zf, Kt)=>{
    "use strict";
    var { format: Ii , inspect: Re , AggregateError: Mi  } = j13(), Ni = globalThis.AggregateError || Mi, Di = Symbol("kIsNodeError"), Oi = [
        "string",
        "function",
        "number",
        "object",
        "Function",
        "Object",
        "boolean",
        "bigint",
        "symbol"
    ], qi = /^([A-Z][a-z0-9]*)+$/, xi = "__node_internal_", Ae = {};
    function X(e, t) {
        if (!e) throw new Ae.ERR_INTERNAL_ASSERTION(t);
    }
    function Vt(e) {
        let t = "", n = e.length, r = e[0] === "-" ? 1 : 0;
        for(; n >= r + 4; n -= 3)t = `_${e.slice(n - 3, n)}${t}`;
        return `${e.slice(0, n)}${t}`;
    }
    function Li(e, t, n) {
        if (typeof t == "function") return X(t.length <= n.length, `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${t.length}).`), t(...n);
        let r = (t.match(/%[dfijoOs]/g) || []).length;
        return X(r === n.length, `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${r}).`), n.length === 0 ? t : Ii(t, ...n);
    }
    function N(e, t, n) {
        n || (n = Error);
        class r extends n {
            constructor(...o){
                super(Li(e, t, o));
            }
            toString() {
                return `${this.name} [${e}]: ${this.message}`;
            }
        }
        Object.defineProperties(r.prototype, {
            name: {
                value: n.name,
                writable: !0,
                enumerable: !1,
                configurable: !0
            },
            toString: {
                value () {
                    return `${this.name} [${e}]: ${this.message}`;
                },
                writable: !0,
                enumerable: !1,
                configurable: !0
            }
        }), r.prototype.code = e, r.prototype[Di] = !0, Ae[e] = r;
    }
    function Yt(e) {
        let t = xi + e.name;
        return Object.defineProperty(e, "name", {
            value: t
        }), e;
    }
    function Pi(e, t) {
        if (e && t && e !== t) {
            if (Array.isArray(t.errors)) return t.errors.push(e), t;
            let n = new Ni([
                t,
                e
            ], t.message);
            return n.code = t.code, n;
        }
        return e || t;
    }
    var Qe = class extends Error {
        constructor(t = "The operation was aborted", n = void 0){
            if (n !== void 0 && typeof n != "object") throw new Ae.ERR_INVALID_ARG_TYPE("options", "Object", n);
            super(t, n), this.code = "ABORT_ERR", this.name = "AbortError";
        }
    };
    N("ERR_ASSERTION", "%s", Error);
    N("ERR_INVALID_ARG_TYPE", (e, t, n)=>{
        X(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [
            t
        ]);
        let r = "The ";
        e.endsWith(" argument") ? r += `${e} ` : r += `"${e}" ${e.includes(".") ? "property" : "argument"} `, r += "must be ";
        let i = [], o = [], l = [];
        for (let f of t)X(typeof f == "string", "All expected entries have to be of type string"), Oi.includes(f) ? i.push(f.toLowerCase()) : qi.test(f) ? o.push(f) : (X(f !== "object", 'The value "object" should be written as "Object"'), l.push(f));
        if (o.length > 0) {
            let f1 = i.indexOf("object");
            f1 !== -1 && (i.splice(i, f1, 1), o.push("Object"));
        }
        if (i.length > 0) {
            switch(i.length){
                case 1:
                    r += `of type ${i[0]}`;
                    break;
                case 2:
                    r += `one of type ${i[0]} or ${i[1]}`;
                    break;
                default:
                    {
                        let f2 = i.pop();
                        r += `one of type ${i.join(", ")}, or ${f2}`;
                    }
            }
            (o.length > 0 || l.length > 0) && (r += " or ");
        }
        if (o.length > 0) {
            switch(o.length){
                case 1:
                    r += `an instance of ${o[0]}`;
                    break;
                case 2:
                    r += `an instance of ${o[0]} or ${o[1]}`;
                    break;
                default:
                    {
                        let f3 = o.pop();
                        r += `an instance of ${o.join(", ")}, or ${f3}`;
                    }
            }
            l.length > 0 && (r += " or ");
        }
        switch(l.length){
            case 0:
                break;
            case 1:
                l[0].toLowerCase() !== l[0] && (r += "an "), r += `${l[0]}`;
                break;
            case 2:
                r += `one of ${l[0]} or ${l[1]}`;
                break;
            default:
                {
                    let f4 = l.pop();
                    r += `one of ${l.join(", ")}, or ${f4}`;
                }
        }
        if (n == null) r += `. Received ${n}`;
        else if (typeof n == "function" && n.name) r += `. Received function ${n.name}`;
        else if (typeof n == "object") {
            var u;
            (u = n.constructor) !== null && u !== void 0 && u.name ? r += `. Received an instance of ${n.constructor.name}` : r += `. Received ${Re(n, {
                depth: -1
            })}`;
        } else {
            let f5 = Re(n, {
                colors: !1
            });
            f5.length > 25 && (f5 = `${f5.slice(0, 25)}...`), r += `. Received type ${typeof n} (${f5})`;
        }
        return r;
    }, TypeError);
    N("ERR_INVALID_ARG_VALUE", (e, t, n = "is invalid")=>{
        let r = Re(t);
        return r.length > 128 && (r = r.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${n}. Received ${r}`;
    }, TypeError);
    N("ERR_INVALID_RETURN_VALUE", (e, t, n)=>{
        var r;
        let i = n != null && (r = n.constructor) !== null && r !== void 0 && r.name ? `instance of ${n.constructor.name}` : `type ${typeof n}`;
        return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    N("ERR_MISSING_ARGS", (...e)=>{
        X(e.length > 0, "At least one arg needs to be specified");
        let t, n = e.length;
        switch(e = (Array.isArray(e) ? e : [
            e
        ]).map((r)=>`"${r}"`).join(" or "), n){
            case 1:
                t += `The ${e[0]} argument`;
                break;
            case 2:
                t += `The ${e[0]} and ${e[1]} arguments`;
                break;
            default:
                {
                    let r = e.pop();
                    t += `The ${e.join(", ")}, and ${r} arguments`;
                }
                break;
        }
        return `${t} must be specified`;
    }, TypeError);
    N("ERR_OUT_OF_RANGE", (e, t, n)=>{
        X(t, 'Missing "range" argument');
        let r;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? r = Vt(String(n)) : typeof n == "bigint" ? (r = String(n), (n > 2n ** 32n || n < -(2n ** 32n)) && (r = Vt(r)), r += "n") : r = Re(n), `The value of "${e}" is out of range. It must be ${t}. Received ${r}`;
    }, RangeError);
    N("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    N("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    N("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    N("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    N("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    N("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    N("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    N("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    N("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    N("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    N("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    Kt.exports = {
        AbortError: Qe,
        aggregateTwoErrors: Yt(Pi),
        hideStackFrames: Yt,
        codes: Ae
    };
});
var _e9 = g10((Xf, nn)=>{
    "use strict";
    var { ArrayIsArray: Jt , ArrayPrototypeIncludes: Qt , ArrayPrototypeJoin: Zt , ArrayPrototypeMap: ki , NumberIsInteger: et , NumberIsNaN: Wi , NumberMAX_SAFE_INTEGER: Ci , NumberMIN_SAFE_INTEGER: ji , NumberParseInt: $i , ObjectPrototypeHasOwnProperty: vi , RegExpPrototypeExec: Fi , String: Ui , StringPrototypeToUpperCase: Bi , StringPrototypeTrim: Gi  } = m6(), { hideStackFrames: k , codes: { ERR_SOCKET_BAD_PORT: Hi , ERR_INVALID_ARG_TYPE: q , ERR_INVALID_ARG_VALUE: me , ERR_OUT_OF_RANGE: J , ERR_UNKNOWN_SIGNAL: zt  }  } = O13(), { normalizeEncoding: Vi  } = j13(), { isAsyncFunction: Yi , isArrayBufferView: Ki  } = j13().types, Xt = {};
    function zi(e) {
        return e === (e | 0);
    }
    function Xi(e) {
        return e === e >>> 0;
    }
    var Ji = /^[0-7]+$/, Qi = "must be a 32-bit unsigned integer or an octal string";
    function Zi(e, t, n) {
        if (typeof e > "u" && (e = n), typeof e == "string") {
            if (Fi(Ji, e) === null) throw new me(t, e, Qi);
            e = $i(e, 8);
        }
        return en(e, t), e;
    }
    var eo = k((e, t, n = ji, r = Ci)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        if (e < n || e > r) throw new J(t, `>= ${n} && <= ${r}`, e);
    }), to = k((e, t, n = -2147483648, r = 2147483647)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        if (e < n || e > r) throw new J(t, `>= ${n} && <= ${r}`, e);
    }), en = k((e, t, n = !1)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        let r = n ? 1 : 0, i = 4294967295;
        if (e < r || e > i) throw new J(t, `>= ${r} && <= ${i}`, e);
    });
    function tn(e, t) {
        if (typeof e != "string") throw new q(t, "string", e);
    }
    function no(e, t, n = void 0, r) {
        if (typeof e != "number") throw new q(t, "number", e);
        if (n != null && e < n || r != null && e > r || (n != null || r != null) && Wi(e)) throw new J(t, `${n != null ? `>= ${n}` : ""}${n != null && r != null ? " && " : ""}${r != null ? `<= ${r}` : ""}`, e);
    }
    var ro = k((e, t, n)=>{
        if (!Qt(n, e)) {
            let r = Zt(ki(n, (o)=>typeof o == "string" ? `'${o}'` : Ui(o)), ", "), i = "must be one of: " + r;
            throw new me(t, e, i);
        }
    });
    function io(e, t) {
        if (typeof e != "boolean") throw new q(t, "boolean", e);
    }
    function Ze(e, t, n) {
        return e == null || !vi(e, t) ? n : e[t];
    }
    var oo = k((e, t, n = null)=>{
        let r = Ze(n, "allowArray", !1), i = Ze(n, "allowFunction", !1);
        if (!Ze(n, "nullable", !1) && e === null || !r && Jt(e) || typeof e != "object" && (!i || typeof e != "function")) throw new q(t, "Object", e);
    }), lo = k((e, t, n = 0)=>{
        if (!Jt(e)) throw new q(t, "Array", e);
        if (e.length < n) {
            let r = `must be longer than ${n}`;
            throw new me(t, e, r);
        }
    });
    function ao(e, t = "signal") {
        if (tn(e, t), Xt[e] === void 0) throw Xt[Bi(e)] !== void 0 ? new zt(e + " (signals must use all capital letters)") : new zt(e);
    }
    var fo = k((e, t = "buffer")=>{
        if (!Ki(e)) throw new q(t, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], e);
    });
    function uo(e, t) {
        let n = Vi(t), r = e.length;
        if (n === "hex" && r % 2 !== 0) throw new me("encoding", t, `is invalid for data of length ${r}`);
    }
    function so(e, t = "Port", n = !0) {
        if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Gi(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !n) throw new Hi(t, e, n);
        return e | 0;
    }
    var co = k((e, t)=>{
        if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e))) throw new q(t, "AbortSignal", e);
    }), ho = k((e, t)=>{
        if (typeof e != "function") throw new q(t, "Function", e);
    }), bo = k((e, t)=>{
        if (typeof e != "function" || Yi(e)) throw new q(t, "Function", e);
    }), _o = k((e, t)=>{
        if (e !== void 0) throw new q(t, "undefined", e);
    });
    function po(e, t, n) {
        if (!Qt(n, e)) throw new q(t, `('${Zt(n, "|")}')`, e);
    }
    nn.exports = {
        isInt32: zi,
        isUint32: Xi,
        parseFileMode: Zi,
        validateArray: lo,
        validateBoolean: io,
        validateBuffer: fo,
        validateEncoding: uo,
        validateFunction: ho,
        validateInt32: to,
        validateInteger: eo,
        validateNumber: no,
        validateObject: oo,
        validateOneOf: ro,
        validatePlainFunction: bo,
        validatePort: so,
        validateSignalName: ao,
        validateString: tn,
        validateUint32: en,
        validateUndefined: _o,
        validateUnion: po,
        validateAbortSignal: co
    };
});
var V7 = g10((Jf, _n)=>{
    "use strict";
    var { Symbol: Te , SymbolAsyncIterator: rn , SymbolIterator: on  } = m6(), ln = Te("kDestroyed"), an = Te("kIsErrored"), tt = Te("kIsReadable"), fn = Te("kIsDisturbed");
    function Ie(e, t = !1) {
        var n;
        return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((n = e._readableState) === null || n === void 0 ? void 0 : n.readable) !== !1) && (!e._writableState || e._readableState));
    }
    function Me(e) {
        var t;
        return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
    }
    function wo(e) {
        return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Q(e) {
        return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function yo(e, t) {
        return e == null ? !1 : t === !0 ? typeof e[rn] == "function" : t === !1 ? typeof e[on] == "function" : typeof e[rn] == "function" || typeof e[on] == "function";
    }
    function Ne(e) {
        if (!Q(e)) return null;
        let t = e._writableState, n = e._readableState, r = t || n;
        return !!(e.destroyed || e[ln] || r != null && r.destroyed);
    }
    function un(e) {
        if (!Me(e)) return null;
        if (e.writableEnded === !0) return !0;
        let t = e._writableState;
        return t != null && t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function go(e, t) {
        if (!Me(e)) return null;
        if (e.writableFinished === !0) return !0;
        let n = e._writableState;
        return n != null && n.errored ? !1 : typeof n?.finished != "boolean" ? null : !!(n.finished || t === !1 && n.ended === !0 && n.length === 0);
    }
    function So(e) {
        if (!Ie(e)) return null;
        if (e.readableEnded === !0) return !0;
        let t = e._readableState;
        return !t || t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function sn(e, t) {
        if (!Ie(e)) return null;
        let n = e._readableState;
        return n != null && n.errored ? !1 : typeof n?.endEmitted != "boolean" ? null : !!(n.endEmitted || t === !1 && n.ended === !0 && n.length === 0);
    }
    function dn(e) {
        return e && e[tt] != null ? e[tt] : typeof e?.readable != "boolean" ? null : Ne(e) ? !1 : Ie(e) && e.readable && !sn(e);
    }
    function cn(e) {
        return typeof e?.writable != "boolean" ? null : Ne(e) ? !1 : Me(e) && e.writable && !un(e);
    }
    function Eo(e, t) {
        return Q(e) ? Ne(e) ? !0 : !(t?.readable !== !1 && dn(e) || t?.writable !== !1 && cn(e)) : null;
    }
    function Ro(e) {
        var t, n;
        return Q(e) ? e.writableErrored ? e.writableErrored : (t = (n = e._writableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
    }
    function Ao(e) {
        var t, n;
        return Q(e) ? e.readableErrored ? e.readableErrored : (t = (n = e._readableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
    }
    function mo(e) {
        if (!Q(e)) return null;
        if (typeof e.closed == "boolean") return e.closed;
        let t = e._writableState, n = e._readableState;
        return typeof t?.closed == "boolean" || typeof n?.closed == "boolean" ? t?.closed || n?.closed : typeof e._closed == "boolean" && hn(e) ? e._closed : null;
    }
    function hn(e) {
        return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function bn(e) {
        return typeof e._sent100 == "boolean" && hn(e);
    }
    function To(e) {
        var t;
        return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
    }
    function Io(e) {
        if (!Q(e)) return null;
        let t = e._writableState, n = e._readableState, r = t || n;
        return !r && bn(e) || !!(r && r.autoDestroy && r.emitClose && r.closed === !1);
    }
    function Mo(e) {
        var t;
        return !!(e && ((t = e[fn]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
    }
    function No(e) {
        var t, n, r, i, o, l, u, f, a, c;
        return !!(e && ((t = (n = (r = (i = (o = (l = e[an]) !== null && l !== void 0 ? l : e.readableErrored) !== null && o !== void 0 ? o : e.writableErrored) !== null && i !== void 0 ? i : (u = e._readableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._writableState) === null || f === void 0 ? void 0 : f.errorEmitted) !== null && n !== void 0 ? n : (a = e._readableState) === null || a === void 0 ? void 0 : a.errored) !== null && t !== void 0 ? t : (c = e._writableState) === null || c === void 0 ? void 0 : c.errored));
    }
    _n.exports = {
        kDestroyed: ln,
        isDisturbed: Mo,
        kIsDisturbed: fn,
        isErrored: No,
        kIsErrored: an,
        isReadable: dn,
        kIsReadable: tt,
        isClosed: mo,
        isDestroyed: Ne,
        isDuplexNodeStream: wo,
        isFinished: Eo,
        isIterable: yo,
        isReadableNodeStream: Ie,
        isReadableEnded: So,
        isReadableFinished: sn,
        isReadableErrored: Ao,
        isNodeStream: Q,
        isWritable: cn,
        isWritableNodeStream: Me,
        isWritableEnded: un,
        isWritableFinished: go,
        isWritableErrored: Ro,
        isServerRequest: To,
        isServerResponse: bn,
        willEmitClose: Io
    };
});
var Y10 = g10((Qf, rt)=>{
    var oe = __process$, { AbortError: Do , codes: Oo  } = O13(), { ERR_INVALID_ARG_TYPE: qo , ERR_STREAM_PREMATURE_CLOSE: pn  } = Oo, { kEmptyObject: wn , once: yn  } = j13(), { validateAbortSignal: xo , validateFunction: Lo , validateObject: Po  } = _e9(), { Promise: ko  } = m6(), { isClosed: Wo , isReadable: gn , isReadableNodeStream: nt , isReadableFinished: Sn , isReadableErrored: Co , isWritable: En , isWritableNodeStream: Rn , isWritableFinished: An , isWritableErrored: jo , isNodeStream: $o , willEmitClose: vo  } = V7();
    function Fo(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    var Uo = ()=>{};
    function mn(e, t, n) {
        var r, i;
        arguments.length === 2 ? (n = t, t = wn) : t == null ? t = wn : Po(t, "options"), Lo(n, "callback"), xo(t.signal, "options.signal"), n = yn(n);
        let o = (r = t.readable) !== null && r !== void 0 ? r : nt(e), l = (i = t.writable) !== null && i !== void 0 ? i : Rn(e);
        if (!$o(e)) throw new qo("stream", "Stream", e);
        let u = e._writableState, f = e._readableState, a = ()=>{
            e.writable || b();
        }, c = vo(e) && nt(e) === o && Rn(e) === l, s = An(e, !1), b = ()=>{
            s = !0, e.destroyed && (c = !1), !(c && (!e.readable || o)) && (!o || d) && n.call(e);
        }, d = Sn(e, !1), h = ()=>{
            d = !0, e.destroyed && (c = !1), !(c && (!e.writable || l)) && (!l || s) && n.call(e);
        }, D = (M)=>{
            n.call(e, M);
        }, L = Wo(e), _ = ()=>{
            L = !0;
            let M = jo(e) || Co(e);
            if (M && typeof M != "boolean") return n.call(e, M);
            if (o && !d && nt(e, !0) && !Sn(e, !1)) return n.call(e, new pn);
            if (l && !s && !An(e, !1)) return n.call(e, new pn);
            n.call(e);
        }, p = ()=>{
            e.req.on("finish", b);
        };
        Fo(e) ? (e.on("complete", b), c || e.on("abort", _), e.req ? p() : e.on("request", p)) : l && !u && (e.on("end", a), e.on("close", a)), !c && typeof e.aborted == "boolean" && e.on("aborted", _), e.on("end", h), e.on("finish", b), t.error !== !1 && e.on("error", D), e.on("close", _), L ? oe.nextTick(_) : u != null && u.errorEmitted || f != null && f.errorEmitted ? c || oe.nextTick(_) : (!o && (!c || gn(e)) && (s || En(e) === !1) || !l && (!c || En(e)) && (d || gn(e) === !1) || f && e.req && e.aborted) && oe.nextTick(_);
        let I = ()=>{
            n = Uo, e.removeListener("aborted", _), e.removeListener("complete", b), e.removeListener("abort", _), e.removeListener("request", p), e.req && e.req.removeListener("finish", b), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", b), e.removeListener("end", h), e.removeListener("error", D), e.removeListener("close", _);
        };
        if (t.signal && !L) {
            let M = ()=>{
                let F = n;
                I(), F.call(e, new Do(void 0, {
                    cause: t.signal.reason
                }));
            };
            if (t.signal.aborted) oe.nextTick(M);
            else {
                let F = n;
                n = yn((...re)=>{
                    t.signal.removeEventListener("abort", M), F.apply(e, re);
                }), t.signal.addEventListener("abort", M);
            }
        }
        return I;
    }
    function Bo(e, t) {
        return new ko((n, r)=>{
            mn(e, t, (i)=>{
                i ? r(i) : n();
            });
        });
    }
    rt.exports = mn;
    rt.exports.finished = Bo;
});
var xn2 = g10((Zf, lt)=>{
    "use strict";
    var Nn = globalThis.AbortController, { codes: { ERR_INVALID_ARG_TYPE: pe , ERR_MISSING_ARGS: Go , ERR_OUT_OF_RANGE: Ho  } , AbortError: $  } = O13(), { validateAbortSignal: le , validateInteger: Vo , validateObject: ae  } = _e9(), Yo = m6().Symbol("kWeak"), { finished: Ko  } = Y10(), { ArrayPrototypePush: zo , MathFloor: Xo , Number: Jo , NumberIsNaN: Qo , Promise: Tn , PromiseReject: In , PromisePrototypeThen: Zo , Symbol: Dn  } = m6(), De = Dn("kEmpty"), Mn = Dn("kEof");
    function Oe(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal");
        let n = 1;
        return t?.concurrency != null && (n = Xo(t.concurrency)), Vo(n, "concurrency", 1), (async function*() {
            var i, o;
            let l = new Nn, u = this, f = [], a = l.signal, c = {
                signal: a
            }, s = ()=>l.abort();
            t != null && (i = t.signal) !== null && i !== void 0 && i.aborted && s(), t == null || (o = t.signal) === null || o === void 0 || o.addEventListener("abort", s);
            let b, d, h = !1;
            function D() {
                h = !0;
            }
            async function L() {
                try {
                    for await (let I of u){
                        var _;
                        if (h) return;
                        if (a.aborted) throw new $;
                        try {
                            I = e(I, c);
                        } catch (M) {
                            I = In(M);
                        }
                        I !== De && (typeof ((_ = I) === null || _ === void 0 ? void 0 : _.catch) == "function" && I.catch(D), f.push(I), b && (b(), b = null), !h && f.length && f.length >= n && await new Tn((M)=>{
                            d = M;
                        }));
                    }
                    f.push(Mn);
                } catch (I1) {
                    let M1 = In(I1);
                    Zo(M1, void 0, D), f.push(M1);
                } finally{
                    var p;
                    h = !0, b && (b(), b = null), t == null || (p = t.signal) === null || p === void 0 || p.removeEventListener("abort", s);
                }
            }
            L();
            try {
                for(;;){
                    for(; f.length > 0;){
                        let _ = await f[0];
                        if (_ === Mn) return;
                        if (a.aborted) throw new $;
                        _ !== De && (yield _), f.shift(), d && (d(), d = null);
                    }
                    await new Tn((_)=>{
                        b = _;
                    });
                }
            } finally{
                l.abort(), h = !0, d && (d(), d = null);
            }
        }).call(this);
    }
    function el(e = void 0) {
        return e != null && ae(e, "options"), e?.signal != null && le(e.signal, "options.signal"), (async function*() {
            let n = 0;
            for await (let i of this){
                var r;
                if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted) throw new $({
                    cause: e.signal.reason
                });
                yield [
                    n++,
                    i
                ];
            }
        }).call(this);
    }
    async function On(e, t = void 0) {
        for await (let n of ot.call(this, e, t))return !0;
        return !1;
    }
    async function tl(e, t = void 0) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        return !await On.call(this, async (...n)=>!await e(...n), t);
    }
    async function nl(e, t) {
        for await (let n of ot.call(this, e, t))return n;
    }
    async function rl(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        async function n(r, i) {
            return await e(r, i), De;
        }
        for await (let r of Oe.call(this, n, t));
    }
    function ot(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        async function n(r, i) {
            return await e(r, i) ? r : De;
        }
        return Oe.call(this, n, t);
    }
    var it = class extends Go {
        constructor(){
            super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
        }
    };
    async function il(e, t, n) {
        var r;
        if (typeof e != "function") throw new pe("reducer", [
            "Function",
            "AsyncFunction"
        ], e);
        n != null && ae(n, "options"), n?.signal != null && le(n.signal, "options.signal");
        let i = arguments.length > 1;
        if (n != null && (r = n.signal) !== null && r !== void 0 && r.aborted) {
            let a = new $(void 0, {
                cause: n.signal.reason
            });
            throw this.once("error", ()=>{}), await Ko(this.destroy(a)), a;
        }
        let o = new Nn, l = o.signal;
        if (n != null && n.signal) {
            let a1 = {
                once: !0,
                [Yo]: this
            };
            n.signal.addEventListener("abort", ()=>o.abort(), a1);
        }
        let u = !1;
        try {
            for await (let a2 of this){
                var f;
                if (u = !0, n != null && (f = n.signal) !== null && f !== void 0 && f.aborted) throw new $;
                i ? t = await e(t, a2, {
                    signal: l
                }) : (t = a2, i = !0);
            }
            if (!u && !i) throw new it;
        } finally{
            o.abort();
        }
        return t;
    }
    async function ol(e) {
        e != null && ae(e, "options"), e?.signal != null && le(e.signal, "options.signal");
        let t = [];
        for await (let r of this){
            var n;
            if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted) throw new $(void 0, {
                cause: e.signal.reason
            });
            zo(t, r);
        }
        return t;
    }
    function ll(e, t) {
        let n = Oe.call(this, e, t);
        return (async function*() {
            for await (let i of n)yield* i;
        }).call(this);
    }
    function qn(e) {
        if (e = Jo(e), Qo(e)) return 0;
        if (e < 0) throw new Ho("number", ">= 0", e);
        return e;
    }
    function al(e, t = void 0) {
        return t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal"), e = qn(e), (async function*() {
            var r;
            if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted) throw new $;
            for await (let o of this){
                var i;
                if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted) throw new $;
                e-- <= 0 && (yield o);
            }
        }).call(this);
    }
    function fl(e, t = void 0) {
        return t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal"), e = qn(e), (async function*() {
            var r;
            if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted) throw new $;
            for await (let o of this){
                var i;
                if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted) throw new $;
                if (e-- > 0) yield o;
                else return;
            }
        }).call(this);
    }
    lt.exports.streamReturningOperators = {
        asIndexedPairs: el,
        drop: al,
        filter: ot,
        flatMap: ll,
        map: Oe,
        take: fl
    };
    lt.exports.promiseReturningOperators = {
        every: tl,
        forEach: rl,
        reduce: il,
        toArray: ol,
        some: On,
        find: nl
    };
});
var Z11 = g10((eu, vn)=>{
    "use strict";
    var K = __process$, { aggregateTwoErrors: ul , codes: { ERR_MULTIPLE_CALLBACK: sl  } , AbortError: dl  } = O13(), { Symbol: kn  } = m6(), { kDestroyed: cl , isDestroyed: hl , isFinished: bl , isServerRequest: _l  } = V7(), Wn = kn("kDestroy"), at = kn("kConstruct");
    function Cn(e, t, n) {
        e && (e.stack, t && !t.errored && (t.errored = e), n && !n.errored && (n.errored = e));
    }
    function pl(e, t) {
        let n = this._readableState, r = this._writableState, i = r || n;
        return r && r.destroyed || n && n.destroyed ? (typeof t == "function" && t(), this) : (Cn(e, r, n), r && (r.destroyed = !0), n && (n.destroyed = !0), i.constructed ? Ln(this, e, t) : this.once(Wn, function(o) {
            Ln(this, ul(o, e), t);
        }), this);
    }
    function Ln(e, t, n) {
        let r = !1;
        function i(o) {
            if (r) return;
            r = !0;
            let l = e._readableState, u = e._writableState;
            Cn(o, u, l), u && (u.closed = !0), l && (l.closed = !0), typeof n == "function" && n(o), o ? K.nextTick(wl, e, o) : K.nextTick(jn, e);
        }
        try {
            e._destroy(t || null, i);
        } catch (o) {
            i(o);
        }
    }
    function wl(e, t) {
        ft(e, t), jn(e);
    }
    function jn(e) {
        let t = e._readableState, n = e._writableState;
        n && (n.closeEmitted = !0), t && (t.closeEmitted = !0), (n && n.emitClose || t && t.emitClose) && e.emit("close");
    }
    function ft(e, t) {
        let n = e._readableState, r = e._writableState;
        r && r.errorEmitted || n && n.errorEmitted || (r && (r.errorEmitted = !0), n && (n.errorEmitted = !0), e.emit("error", t));
    }
    function yl() {
        let e = this._readableState, t = this._writableState;
        e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
    }
    function ut(e, t, n) {
        let r = e._readableState, i = e._writableState;
        if (i && i.destroyed || r && r.destroyed) return this;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), r && !r.errored && (r.errored = t), n ? K.nextTick(ft, e, t) : ft(e, t));
    }
    function gl(e, t) {
        if (typeof e._construct != "function") return;
        let n = e._readableState, r = e._writableState;
        n && (n.constructed = !1), r && (r.constructed = !1), e.once(at, t), !(e.listenerCount(at) > 1) && K.nextTick(Sl, e);
    }
    function Sl(e) {
        let t = !1;
        function n(r) {
            if (t) {
                ut(e, r ?? new sl);
                return;
            }
            t = !0;
            let i = e._readableState, o = e._writableState, l = o || i;
            i && (i.constructed = !0), o && (o.constructed = !0), l.destroyed ? e.emit(Wn, r) : r ? ut(e, r, !0) : K.nextTick(El, e);
        }
        try {
            e._construct(n);
        } catch (r) {
            n(r);
        }
    }
    function El(e) {
        e.emit(at);
    }
    function Pn(e) {
        return e && e.setHeader && typeof e.abort == "function";
    }
    function $n(e) {
        e.emit("close");
    }
    function Rl(e, t) {
        e.emit("error", t), K.nextTick($n, e);
    }
    function Al(e, t) {
        !e || hl(e) || (!t && !bl(e) && (t = new dl), _l(e) ? (e.socket = null, e.destroy(t)) : Pn(e) ? e.abort() : Pn(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? K.nextTick(Rl, e, t) : K.nextTick($n, e), e.destroyed || (e[cl] = !0));
    }
    vn.exports = {
        construct: gl,
        destroyer: Al,
        destroy: pl,
        undestroy: yl,
        errorOrDestroy: ut
    };
});
var Le5 = g10((tu, Un)=>{
    "use strict";
    var { ArrayIsArray: ml , ObjectSetPrototypeOf: Fn  } = m6(), { EventEmitter: qe  } = EventEmitter;
    function xe(e) {
        qe.call(this, e);
    }
    Fn(xe.prototype, qe.prototype);
    Fn(xe, qe);
    xe.prototype.pipe = function(e, t) {
        let n = this;
        function r(c) {
            e.writable && e.write(c) === !1 && n.pause && n.pause();
        }
        n.on("data", r);
        function i() {
            n.readable && n.resume && n.resume();
        }
        e.on("drain", i), !e._isStdio && (!t || t.end !== !1) && (n.on("end", l), n.on("close", u));
        let o = !1;
        function l() {
            o || (o = !0, e.end());
        }
        function u() {
            o || (o = !0, typeof e.destroy == "function" && e.destroy());
        }
        function f(c) {
            a(), qe.listenerCount(this, "error") === 0 && this.emit("error", c);
        }
        st(n, "error", f), st(e, "error", f);
        function a() {
            n.removeListener("data", r), e.removeListener("drain", i), n.removeListener("end", l), n.removeListener("close", u), n.removeListener("error", f), e.removeListener("error", f), n.removeListener("end", a), n.removeListener("close", a), e.removeListener("close", a);
        }
        return n.on("end", a), n.on("close", a), e.on("close", a), e.emit("pipe", n), e;
    };
    function st(e, t, n) {
        if (typeof e.prependListener == "function") return e.prependListener(t, n);
        !e._events || !e._events[t] ? e.on(t, n) : ml(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [
            n,
            e._events[t]
        ];
    }
    Un.exports = {
        Stream: xe,
        prependListener: st
    };
});
var ke7 = g10((nu, Pe)=>{
    "use strict";
    var { AbortError: Tl , codes: Il  } = O13(), Ml = Y10(), { ERR_INVALID_ARG_TYPE: Bn  } = Il, Nl = (e, t)=>{
        if (typeof e != "object" || !("aborted" in e)) throw new Bn(t, "AbortSignal", e);
    };
    function Dl(e) {
        return !!(e && typeof e.pipe == "function");
    }
    Pe.exports.addAbortSignal = function(t, n) {
        if (Nl(t, "signal"), !Dl(n)) throw new Bn("stream", "stream.Stream", n);
        return Pe.exports.addAbortSignalNoValidate(t, n);
    };
    Pe.exports.addAbortSignalNoValidate = function(e, t) {
        if (typeof e != "object" || !("aborted" in e)) return t;
        let n = ()=>{
            t.destroy(new Tl(void 0, {
                cause: e.reason
            }));
        };
        return e.aborted ? n() : (e.addEventListener("abort", n), Ml(t, ()=>e.removeEventListener("abort", n))), t;
    };
});
var Vn2 = g10((iu, Hn)=>{
    "use strict";
    var { StringPrototypeSlice: Gn , SymbolIterator: Ol , TypedArrayPrototypeSet: We , Uint8Array: ql  } = m6(), { Buffer: dt  } = __default4, { inspect: xl  } = j13();
    Hn.exports = class {
        constructor(){
            this.head = null, this.tail = null, this.length = 0;
        }
        push(t) {
            let n = {
                data: t,
                next: null
            };
            this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
        }
        unshift(t) {
            let n = {
                data: t,
                next: this.head
            };
            this.length === 0 && (this.tail = n), this.head = n, ++this.length;
        }
        shift() {
            if (this.length === 0) return;
            let t = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
        }
        clear() {
            this.head = this.tail = null, this.length = 0;
        }
        join(t) {
            if (this.length === 0) return "";
            let n = this.head, r = "" + n.data;
            for(; (n = n.next) !== null;)r += t + n.data;
            return r;
        }
        concat(t) {
            if (this.length === 0) return dt.alloc(0);
            let n = dt.allocUnsafe(t >>> 0), r = this.head, i = 0;
            for(; r;)We(n, r.data, i), i += r.data.length, r = r.next;
            return n;
        }
        consume(t, n) {
            let r = this.head.data;
            if (t < r.length) {
                let i = r.slice(0, t);
                return this.head.data = r.slice(t), i;
            }
            return t === r.length ? this.shift() : n ? this._getString(t) : this._getBuffer(t);
        }
        first() {
            return this.head.data;
        }
        *[Ol]() {
            for(let t = this.head; t; t = t.next)yield t.data;
        }
        _getString(t) {
            let n = "", r = this.head, i = 0;
            do {
                let o = r.data;
                if (t > o.length) n += o, t -= o.length;
                else {
                    t === o.length ? (n += o, ++i, r.next ? this.head = r.next : this.head = this.tail = null) : (n += Gn(o, 0, t), this.head = r, r.data = Gn(o, t));
                    break;
                }
                ++i;
            }while ((r = r.next) !== null)
            return this.length -= i, n;
        }
        _getBuffer(t) {
            let n = dt.allocUnsafe(t), r = t, i = this.head, o = 0;
            do {
                let l = i.data;
                if (t > l.length) We(n, l, r - t), t -= l.length;
                else {
                    t === l.length ? (We(n, l, r - t), ++o, i.next ? this.head = i.next : this.head = this.tail = null) : (We(n, new ql(l.buffer, l.byteOffset, t), r - t), this.head = i, i.data = l.slice(t));
                    break;
                }
                ++o;
            }while ((i = i.next) !== null)
            return this.length -= o, n;
        }
        [Symbol.for("nodejs.util.inspect.custom")](t, n) {
            return xl(this, {
                ...n,
                depth: 0,
                customInspect: !1
            });
        }
    };
});
var Ce11 = g10((ou, Kn)=>{
    "use strict";
    var { MathFloor: Ll , NumberIsInteger: Pl  } = m6(), { ERR_INVALID_ARG_VALUE: kl  } = O13().codes;
    function Wl(e, t, n) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null;
    }
    function Yn(e) {
        return e ? 16 : 16 * 1024;
    }
    function Cl(e, t, n, r) {
        let i = Wl(t, r, n);
        if (i != null) {
            if (!Pl(i) || i < 0) {
                let o = r ? `options.${n}` : "options.highWaterMark";
                throw new kl(o, i);
            }
            return Ll(i);
        }
        return Yn(e.objectMode);
    }
    Kn.exports = {
        getHighWaterMark: Cl,
        getDefaultHighWaterMark: Yn
    };
});
var ct1 = g10((lu, Qn)=>{
    "use strict";
    var zn = __process$, { PromisePrototypeThen: jl , SymbolAsyncIterator: Xn , SymbolIterator: Jn  } = m6(), { Buffer: $l  } = __default4, { ERR_INVALID_ARG_TYPE: vl , ERR_STREAM_NULL_VALUES: Fl  } = O13().codes;
    function Ul(e, t, n) {
        let r;
        if (typeof t == "string" || t instanceof $l) return new e({
            objectMode: !0,
            ...n,
            read () {
                this.push(t), this.push(null);
            }
        });
        let i;
        if (t && t[Xn]) i = !0, r = t[Xn]();
        else if (t && t[Jn]) i = !1, r = t[Jn]();
        else throw new vl("iterable", [
            "Iterable"
        ], t);
        let o = new e({
            objectMode: !0,
            highWaterMark: 1,
            ...n
        }), l = !1;
        o._read = function() {
            l || (l = !0, f());
        }, o._destroy = function(a, c) {
            jl(u(a), ()=>zn.nextTick(c, a), (s)=>zn.nextTick(c, s || a));
        };
        async function u(a) {
            let c = a != null, s = typeof r.throw == "function";
            if (c && s) {
                let { value: b , done: d  } = await r.throw(a);
                if (await b, d) return;
            }
            if (typeof r.return == "function") {
                let { value: b1  } = await r.return();
                await b1;
            }
        }
        async function f() {
            for(;;){
                try {
                    let { value: a , done: c  } = i ? await r.next() : r.next();
                    if (c) o.push(null);
                    else {
                        let s = a && typeof a.then == "function" ? await a : a;
                        if (s === null) throw l = !1, new Fl;
                        if (o.push(s)) continue;
                        l = !1;
                    }
                } catch (a1) {
                    o.destroy(a1);
                }
                break;
            }
        }
        return o;
    }
    Qn.exports = Ul;
});
var we10 = g10((au, dr)=>{
    var W = __process$, { ArrayPrototypeIndexOf: Bl , NumberIsInteger: Gl , NumberIsNaN: Hl , NumberParseInt: Vl , ObjectDefineProperties: tr , ObjectKeys: Yl , ObjectSetPrototypeOf: nr , Promise: Kl , SafeSet: zl , SymbolAsyncIterator: Xl , Symbol: Jl  } = m6();
    dr.exports = w;
    w.ReadableState = yt;
    var { EventEmitter: Ql  } = EventEmitter, { Stream: z , prependListener: Zl  } = Le5(), { Buffer: ht  } = __default4, { addAbortSignal: ea  } = ke7(), ta = Y10(), y = j13().debuglog("stream", (e)=>{
        y = e;
    }), na = Vn2(), ue = Z11(), { getHighWaterMark: ra , getDefaultHighWaterMark: ia  } = Ce11(), { aggregateTwoErrors: Zn , codes: { ERR_INVALID_ARG_TYPE: oa , ERR_METHOD_NOT_IMPLEMENTED: la , ERR_OUT_OF_RANGE: aa , ERR_STREAM_PUSH_AFTER_EOF: fa , ERR_STREAM_UNSHIFT_AFTER_END_EVENT: ua  }  } = O13(), { validateObject: sa  } = _e9(), ee = Jl("kPaused"), { StringDecoder: rr  } = __default5, da = ct1();
    nr(w.prototype, z.prototype);
    nr(w, z);
    var bt = ()=>{}, { errorOrDestroy: fe  } = ue;
    function yt(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v9()), this.objectMode = !!(e && e.objectMode), n && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? ra(this, e, "readableHighWaterMark", n) : ia(!1), this.buffer = new na, this.length = 0, this.pipes = [], this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.constructed = !0, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this[ee] = null, this.errorEmitted = !1, this.emitClose = !e || e.emitClose !== !1, this.autoDestroy = !e || e.autoDestroy !== !1, this.destroyed = !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = !1, this.readingMore = !1, this.dataEmitted = !1, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new rr(e.encoding), this.encoding = e.encoding);
    }
    function w(e) {
        if (!(this instanceof w)) return new w(e);
        let t = this instanceof v9();
        this._readableState = new yt(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && ea(e.signal, this)), z.call(this, e), ue.construct(this, ()=>{
            this._readableState.needReadable && je(this, this._readableState);
        });
    }
    w.prototype.destroy = ue.destroy;
    w.prototype._undestroy = ue.undestroy;
    w.prototype._destroy = function(e, t) {
        t(e);
    };
    w.prototype[Ql.captureRejectionSymbol] = function(e) {
        this.destroy(e);
    };
    w.prototype.push = function(e, t) {
        return ir(this, e, t, !1);
    };
    w.prototype.unshift = function(e, t) {
        return ir(this, e, t, !0);
    };
    function ir(e, t, n, r) {
        y("readableAddChunk", t);
        let i = e._readableState, o;
        if (i.objectMode || (typeof t == "string" ? (n = n || i.defaultEncoding, i.encoding !== n && (r && i.encoding ? t = ht.from(t, n).toString(i.encoding) : (t = ht.from(t, n), n = ""))) : t instanceof ht ? n = "" : z._isUint8Array(t) ? (t = z._uint8ArrayToBuffer(t), n = "") : t != null && (o = new oa("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t))), o) fe(e, o);
        else if (t === null) i.reading = !1, ba(e, i);
        else if (i.objectMode || t && t.length > 0) if (r) if (i.endEmitted) fe(e, new ua);
        else {
            if (i.destroyed || i.errored) return !1;
            _t(e, i, t, !0);
        }
        else if (i.ended) fe(e, new fa);
        else {
            if (i.destroyed || i.errored) return !1;
            i.reading = !1, i.decoder && !n ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? _t(e, i, t, !1) : je(e, i)) : _t(e, i, t, !1);
        }
        else r || (i.reading = !1, je(e, i));
        return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function _t(e, t, n, r) {
        t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = !0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && $e(e)), je(e, t);
    }
    w.prototype.isPaused = function() {
        let e = this._readableState;
        return e[ee] === !0 || e.flowing === !1;
    };
    w.prototype.setEncoding = function(e) {
        let t = new rr(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        let n = this._readableState.buffer, r = "";
        for (let i of n)r += t.write(i);
        return n.clear(), r !== "" && n.push(r), this._readableState.length = r.length, this;
    };
    var ca = 1073741824;
    function ha(e) {
        if (e > ca) throw new aa("size", "<= 1GiB", e);
        return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function er(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : Hl(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    w.prototype.read = function(e) {
        y("read", e), e === void 0 ? e = NaN : Gl(e) || (e = Vl(e, 10));
        let t = this._readableState, n = e;
        if (e > t.highWaterMark && (t.highWaterMark = ha(e)), e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return y("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? pt(this) : $e(this), null;
        if (e = er(e, t), e === 0 && t.ended) return t.length === 0 && pt(this), null;
        let r = t.needReadable;
        if (y("need readable", r), (t.length === 0 || t.length - e < t.highWaterMark) && (r = !0, y("length less than watermark", r)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed) r = !1, y("reading, ended or constructing", r);
        else if (r) {
            y("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0);
            try {
                this._read(t.highWaterMark);
            } catch (o) {
                fe(this, o);
            }
            t.sync = !1, t.reading || (e = er(n, t));
        }
        let i;
        return e > 0 ? i = ur(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = !0), n !== e && t.ended && pt(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = !0, this.emit("data", i)), i;
    };
    function ba(e, t) {
        if (y("onEofChunk"), !t.ended) {
            if (t.decoder) {
                let n = t.decoder.end();
                n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
            }
            t.ended = !0, t.sync ? $e(e) : (t.needReadable = !1, t.emittedReadable = !0, or(e));
        }
    }
    function $e(e) {
        let t = e._readableState;
        y("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (y("emitReadable", t.flowing), t.emittedReadable = !0, W.nextTick(or, e));
    }
    function or(e) {
        let t = e._readableState;
        y("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, ar(e);
    }
    function je(e, t) {
        !t.readingMore && t.constructed && (t.readingMore = !0, W.nextTick(_a, e, t));
    }
    function _a(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            let n = t.length;
            if (y("maybeReadMore read 0"), e.read(0), n === t.length) break;
        }
        t.readingMore = !1;
    }
    w.prototype._read = function(e) {
        throw new la("_read()");
    };
    w.prototype.pipe = function(e, t) {
        let n = this, r = this._readableState;
        r.pipes.length === 1 && (r.multiAwaitDrain || (r.multiAwaitDrain = !0, r.awaitDrainWriters = new zl(r.awaitDrainWriters ? [
            r.awaitDrainWriters
        ] : []))), r.pipes.push(e), y("pipe count=%d opts=%j", r.pipes.length, t);
        let o = (!t || t.end !== !1) && e !== W.stdout && e !== W.stderr ? u : L;
        r.endEmitted ? W.nextTick(o) : n.once("end", o), e.on("unpipe", l);
        function l(_, p) {
            y("onunpipe"), _ === n && p && p.hasUnpiped === !1 && (p.hasUnpiped = !0, c());
        }
        function u() {
            y("onend"), e.end();
        }
        let f, a = !1;
        function c() {
            y("cleanup"), e.removeListener("close", h), e.removeListener("finish", D), f && e.removeListener("drain", f), e.removeListener("error", d), e.removeListener("unpipe", l), n.removeListener("end", u), n.removeListener("end", L), n.removeListener("data", b), a = !0, f && r.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f();
        }
        function s() {
            a || (r.pipes.length === 1 && r.pipes[0] === e ? (y("false write response, pause", 0), r.awaitDrainWriters = e, r.multiAwaitDrain = !1) : r.pipes.length > 1 && r.pipes.includes(e) && (y("false write response, pause", r.awaitDrainWriters.size), r.awaitDrainWriters.add(e)), n.pause()), f || (f = pa(n, e), e.on("drain", f));
        }
        n.on("data", b);
        function b(_) {
            y("ondata");
            let p = e.write(_);
            y("dest.write", p), p === !1 && s();
        }
        function d(_) {
            if (y("onerror", _), L(), e.removeListener("error", d), e.listenerCount("error") === 0) {
                let p = e._writableState || e._readableState;
                p && !p.errorEmitted ? fe(e, _) : e.emit("error", _);
            }
        }
        Zl(e, "error", d);
        function h() {
            e.removeListener("finish", D), L();
        }
        e.once("close", h);
        function D() {
            y("onfinish"), e.removeListener("close", h), L();
        }
        e.once("finish", D);
        function L() {
            y("unpipe"), n.unpipe(e);
        }
        return e.emit("pipe", n), e.writableNeedDrain === !0 ? r.flowing && s() : r.flowing || (y("pipe resume"), n.resume()), e;
    };
    function pa(e, t) {
        return function() {
            let r = e._readableState;
            r.awaitDrainWriters === t ? (y("pipeOnDrain", 1), r.awaitDrainWriters = null) : r.multiAwaitDrain && (y("pipeOnDrain", r.awaitDrainWriters.size), r.awaitDrainWriters.delete(t)), (!r.awaitDrainWriters || r.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
        };
    }
    w.prototype.unpipe = function(e) {
        let t = this._readableState, n = {
            hasUnpiped: !1
        };
        if (t.pipes.length === 0) return this;
        if (!e) {
            let i = t.pipes;
            t.pipes = [], this.pause();
            for(let o = 0; o < i.length; o++)i[o].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        let r = Bl(t.pipes, e);
        return r === -1 ? this : (t.pipes.splice(r, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, n), this);
    };
    w.prototype.on = function(e, t) {
        let n = z.prototype.on.call(this, e, t), r = this._readableState;
        return e === "data" ? (r.readableListening = this.listenerCount("readable") > 0, r.flowing !== !1 && this.resume()) : e === "readable" && !r.endEmitted && !r.readableListening && (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, y("on readable", r.length, r.reading), r.length ? $e(this) : r.reading || W.nextTick(wa, this)), n;
    };
    w.prototype.addListener = w.prototype.on;
    w.prototype.removeListener = function(e, t) {
        let n = z.prototype.removeListener.call(this, e, t);
        return e === "readable" && W.nextTick(lr, this), n;
    };
    w.prototype.off = w.prototype.removeListener;
    w.prototype.removeAllListeners = function(e) {
        let t = z.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && W.nextTick(lr, this), t;
    };
    function lr(e) {
        let t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[ee] === !1 ? t.flowing = !0 : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function wa(e) {
        y("readable nexttick read 0"), e.read(0);
    }
    w.prototype.resume = function() {
        let e = this._readableState;
        return e.flowing || (y("resume"), e.flowing = !e.readableListening, ya(this, e)), e[ee] = !1, this;
    };
    function ya(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, W.nextTick(ga, e, t));
    }
    function ga(e, t) {
        y("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), ar(e), t.flowing && !t.reading && e.read(0);
    }
    w.prototype.pause = function() {
        return y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (y("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[ee] = !0, this;
    };
    function ar(e) {
        let t = e._readableState;
        for(y("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    w.prototype.wrap = function(e) {
        let t = !1;
        e.on("data", (r)=>{
            !this.push(r) && e.pause && (t = !0, e.pause());
        }), e.on("end", ()=>{
            this.push(null);
        }), e.on("error", (r)=>{
            fe(this, r);
        }), e.on("close", ()=>{
            this.destroy();
        }), e.on("destroy", ()=>{
            this.destroy();
        }), this._read = ()=>{
            t && e.resume && (t = !1, e.resume());
        };
        let n = Yl(e);
        for(let r = 1; r < n.length; r++){
            let i = n[r];
            this[i] === void 0 && typeof e[i] == "function" && (this[i] = e[i].bind(e));
        }
        return this;
    };
    w.prototype[Xl] = function() {
        return fr(this);
    };
    w.prototype.iterator = function(e) {
        return e !== void 0 && sa(e, "options"), fr(this, e);
    };
    function fr(e, t) {
        typeof e.read != "function" && (e = w.wrap(e, {
            objectMode: !0
        }));
        let n = Sa(e, t);
        return n.stream = e, n;
    }
    async function* Sa(e, t) {
        let n = bt;
        function r(l) {
            this === e ? (n(), n = bt) : n = l;
        }
        e.on("readable", r);
        let i, o = ta(e, {
            writable: !1
        }, (l)=>{
            i = l ? Zn(i, l) : null, n(), n = bt;
        });
        try {
            for(;;){
                let l = e.destroyed ? null : e.read();
                if (l !== null) yield l;
                else {
                    if (i) throw i;
                    if (i === null) return;
                    await new Kl(r);
                }
            }
        } catch (l1) {
            throw i = Zn(i, l1), i;
        } finally{
            (i || t?.destroyOnReturn !== !1) && (i === void 0 || e._readableState.autoDestroy) ? ue.destroyer(e, null) : (e.off("readable", r), o());
        }
    }
    tr(w.prototype, {
        readable: {
            __proto__: null,
            get () {
                let e = this._readableState;
                return !!e && e.readable !== !1 && !e.destroyed && !e.errorEmitted && !e.endEmitted;
            },
            set (e) {
                this._readableState && (this._readableState.readable = !!e);
            }
        },
        readableDidRead: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.dataEmitted;
            }
        },
        readableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
            }
        },
        readableHighWaterMark: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.highWaterMark;
            }
        },
        readableBuffer: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState && this._readableState.buffer;
            }
        },
        readableFlowing: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.flowing;
            },
            set: function(e) {
                this._readableState && (this._readableState.flowing = e);
            }
        },
        readableLength: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState.length;
            }
        },
        readableObjectMode: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.objectMode : !1;
            }
        },
        readableEncoding: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.encoding : null;
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.errored : null;
            }
        },
        closed: {
            __proto__: null,
            get () {
                return this._readableState ? this._readableState.closed : !1;
            }
        },
        destroyed: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.destroyed : !1;
            },
            set (e) {
                !this._readableState || (this._readableState.destroyed = e);
            }
        },
        readableEnded: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.endEmitted : !1;
            }
        }
    });
    tr(yt.prototype, {
        pipesCount: {
            __proto__: null,
            get () {
                return this.pipes.length;
            }
        },
        paused: {
            __proto__: null,
            get () {
                return this[ee] !== !1;
            },
            set (e) {
                this[ee] = !!e;
            }
        }
    });
    w._fromList = ur;
    function ur(e, t) {
        if (t.length === 0) return null;
        let n;
        return t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? n = t.buffer.join("") : t.buffer.length === 1 ? n = t.buffer.first() : n = t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n;
    }
    function pt(e) {
        let t = e._readableState;
        y("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, W.nextTick(Ea, t, e));
    }
    function Ea(e, t) {
        if (y("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
            if (e.endEmitted = !0, t.emit("end"), t.writable && t.allowHalfOpen === !1) W.nextTick(Ra, t);
            else if (e.autoDestroy) {
                let n = t._writableState;
                (!n || n.autoDestroy && (n.finished || n.writable === !1)) && t.destroy();
            }
        }
    }
    function Ra(e) {
        e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    w.from = function(e, t) {
        return da(w, e, t);
    };
    var wt;
    function sr() {
        return wt === void 0 && (wt = {}), wt;
    }
    w.fromWeb = function(e, t) {
        return sr().newStreamReadableFromReadableStream(e, t);
    };
    w.toWeb = function(e, t) {
        return sr().newReadableStreamFromStreamReadable(e, t);
    };
    w.wrap = function(e, t) {
        var n, r;
        return new w({
            objectMode: (n = (r = e.readableObjectMode) !== null && r !== void 0 ? r : e.objectMode) !== null && n !== void 0 ? n : !0,
            ...t,
            destroy (i, o) {
                ue.destroyer(e, i), o(i);
            }
        }).wrap(e);
    };
});
var Tt1 = g10((fu, Ar)=>{
    var te = __process$, { ArrayPrototypeSlice: br , Error: Aa , FunctionPrototypeSymbolHasInstance: _r , ObjectDefineProperty: pr , ObjectDefineProperties: ma , ObjectSetPrototypeOf: wr , StringPrototypeToLowerCase: Ta , Symbol: Ia , SymbolHasInstance: Ma  } = m6();
    Ar.exports = S;
    S.WritableState = Se;
    var { EventEmitter: Na  } = EventEmitter, ye = Le5().Stream, { Buffer: ve  } = __default4, Be = Z11(), { addAbortSignal: Da  } = ke7(), { getHighWaterMark: Oa , getDefaultHighWaterMark: qa  } = Ce11(), { ERR_INVALID_ARG_TYPE: xa , ERR_METHOD_NOT_IMPLEMENTED: La , ERR_MULTIPLE_CALLBACK: yr , ERR_STREAM_CANNOT_PIPE: Pa , ERR_STREAM_DESTROYED: ge , ERR_STREAM_ALREADY_FINISHED: ka , ERR_STREAM_NULL_VALUES: Wa , ERR_STREAM_WRITE_AFTER_END: Ca , ERR_UNKNOWN_ENCODING: gr  } = O13().codes, { errorOrDestroy: se  } = Be;
    wr(S.prototype, ye.prototype);
    wr(S, ye);
    function Et() {}
    var de = Ia("kOnFinished");
    function Se(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v9()), this.objectMode = !!(e && e.objectMode), n && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Oa(this, e, "writableHighWaterMark", n) : qa(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        let r = !!(e && e.decodeStrings === !1);
        this.decodeStrings = !r, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = $a.bind(void 0, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ue(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !e || e.emitClose !== !1, this.autoDestroy = !e || e.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[de] = [];
    }
    function Ue(e) {
        e.buffered = [], e.bufferedIndex = 0, e.allBuffers = !0, e.allNoop = !0;
    }
    Se.prototype.getBuffer = function() {
        return br(this.buffered, this.bufferedIndex);
    };
    pr(Se.prototype, "bufferedRequestCount", {
        __proto__: null,
        get () {
            return this.buffered.length - this.bufferedIndex;
        }
    });
    function S(e) {
        let t = this instanceof v9();
        if (!t && !_r(S, this)) return new S(e);
        this._writableState = new Se(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && Da(e.signal, this)), ye.call(this, e), Be.construct(this, ()=>{
            let n = this._writableState;
            n.writing || At(this, n), mt(this, n);
        });
    }
    pr(S, Ma, {
        __proto__: null,
        value: function(e) {
            return _r(this, e) ? !0 : this !== S ? !1 : e && e._writableState instanceof Se;
        }
    });
    S.prototype.pipe = function() {
        se(this, new Pa);
    };
    function Sr(e, t, n, r) {
        let i = e._writableState;
        if (typeof n == "function") r = n, n = i.defaultEncoding;
        else {
            if (!n) n = i.defaultEncoding;
            else if (n !== "buffer" && !ve.isEncoding(n)) throw new gr(n);
            typeof r != "function" && (r = Et);
        }
        if (t === null) throw new Wa;
        if (!i.objectMode) if (typeof t == "string") i.decodeStrings !== !1 && (t = ve.from(t, n), n = "buffer");
        else if (t instanceof ve) n = "buffer";
        else if (ye._isUint8Array(t)) t = ye._uint8ArrayToBuffer(t), n = "buffer";
        else throw new xa("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t);
        let o;
        return i.ending ? o = new Ca : i.destroyed && (o = new ge("write")), o ? (te.nextTick(r, o), se(e, o, !0), o) : (i.pendingcb++, ja(e, i, t, n, r));
    }
    S.prototype.write = function(e, t, n) {
        return Sr(this, e, t, n) === !0;
    };
    S.prototype.cork = function() {
        this._writableState.corked++;
    };
    S.prototype.uncork = function() {
        let e = this._writableState;
        e.corked && (e.corked--, e.writing || At(this, e));
    };
    S.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = Ta(t)), !ve.isEncoding(t)) throw new gr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    function ja(e, t, n, r, i) {
        let o = t.objectMode ? 1 : n.length;
        t.length += o;
        let l = t.length < t.highWaterMark;
        return l || (t.needDrain = !0), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({
            chunk: n,
            encoding: r,
            callback: i
        }), t.allBuffers && r !== "buffer" && (t.allBuffers = !1), t.allNoop && i !== Et && (t.allNoop = !1)) : (t.writelen = o, t.writecb = i, t.writing = !0, t.sync = !0, e._write(n, r, t.onwrite), t.sync = !1), l && !t.errored && !t.destroyed;
    }
    function cr(e, t, n, r, i, o, l) {
        t.writelen = r, t.writecb = l, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new ge("write")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1;
    }
    function hr(e, t, n, r) {
        --t.pendingcb, r(n), Rt(t), se(e, n);
    }
    function $a(e, t) {
        let n = e._writableState, r = n.sync, i = n.writecb;
        if (typeof i != "function") {
            se(e, new yr);
            return;
        }
        n.writing = !1, n.writecb = null, n.length -= n.writelen, n.writelen = 0, t ? (t.stack, n.errored || (n.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), r ? te.nextTick(hr, e, n, t, i) : hr(e, n, t, i)) : (n.buffered.length > n.bufferedIndex && At(e, n), r ? n.afterWriteTickInfo !== null && n.afterWriteTickInfo.cb === i ? n.afterWriteTickInfo.count++ : (n.afterWriteTickInfo = {
            count: 1,
            cb: i,
            stream: e,
            state: n
        }, te.nextTick(va, n.afterWriteTickInfo)) : Er(e, n, 1, i));
    }
    function va({ stream: e , state: t , count: n , cb: r  }) {
        return t.afterWriteTickInfo = null, Er(e, t, n, r);
    }
    function Er(e, t, n, r) {
        for(!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain")); n-- > 0;)t.pendingcb--, r();
        t.destroyed && Rt(t), mt(e, t);
    }
    function Rt(e) {
        if (e.writing) return;
        for(let i = e.bufferedIndex; i < e.buffered.length; ++i){
            var t;
            let { chunk: o , callback: l  } = e.buffered[i], u = e.objectMode ? 1 : o.length;
            e.length -= u, l((t = e.errored) !== null && t !== void 0 ? t : new ge("write"));
        }
        let n = e[de].splice(0);
        for(let i1 = 0; i1 < n.length; i1++){
            var r;
            n[i1]((r = e.errored) !== null && r !== void 0 ? r : new ge("end"));
        }
        Ue(e);
    }
    function At(e, t) {
        if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed) return;
        let { buffered: n , bufferedIndex: r , objectMode: i  } = t, o = n.length - r;
        if (!o) return;
        let l = r;
        if (t.bufferProcessing = !0, o > 1 && e._writev) {
            t.pendingcb -= o - 1;
            let u = t.allNoop ? Et : (a)=>{
                for(let c = l; c < n.length; ++c)n[c].callback(a);
            }, f = t.allNoop && l === 0 ? n : br(n, l);
            f.allBuffers = t.allBuffers, cr(e, t, !0, t.length, f, "", u), Ue(t);
        } else {
            do {
                let { chunk: u1 , encoding: f1 , callback: a  } = n[l];
                n[l++] = null;
                let c = i ? 1 : u1.length;
                cr(e, t, !1, c, u1, f1, a);
            }while (l < n.length && !t.writing)
            l === n.length ? Ue(t) : l > 256 ? (n.splice(0, l), t.bufferedIndex = 0) : t.bufferedIndex = l;
        }
        t.bufferProcessing = !1;
    }
    S.prototype._write = function(e, t, n) {
        if (this._writev) this._writev([
            {
                chunk: e,
                encoding: t
            }
        ], n);
        else throw new La("_write()");
    };
    S.prototype._writev = null;
    S.prototype.end = function(e, t, n) {
        let r = this._writableState;
        typeof e == "function" ? (n = e, e = null, t = null) : typeof t == "function" && (n = t, t = null);
        let i;
        if (e != null) {
            let o = Sr(this, e, t);
            o instanceof Aa && (i = o);
        }
        return r.corked && (r.corked = 1, this.uncork()), i || (!r.errored && !r.ending ? (r.ending = !0, mt(this, r, !0), r.ended = !0) : r.finished ? i = new ka("end") : r.destroyed && (i = new ge("end"))), typeof n == "function" && (i || r.finished ? te.nextTick(n, i) : r[de].push(n)), this;
    };
    function Fe(e) {
        return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Fa(e, t) {
        let n = !1;
        function r(i) {
            if (n) {
                se(e, i ?? yr());
                return;
            }
            if (n = !0, t.pendingcb--, i) {
                let o = t[de].splice(0);
                for(let l = 0; l < o.length; l++)o[l](i);
                se(e, i, t.sync);
            } else Fe(t) && (t.prefinished = !0, e.emit("prefinish"), t.pendingcb++, te.nextTick(St, e, t));
        }
        t.sync = !0, t.pendingcb++;
        try {
            e._final(r);
        } catch (i) {
            r(i);
        }
        t.sync = !1;
    }
    function Ua(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = !0, Fa(e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function mt(e, t, n) {
        Fe(t) && (Ua(e, t), t.pendingcb === 0 && (n ? (t.pendingcb++, te.nextTick((r, i)=>{
            Fe(i) ? St(r, i) : i.pendingcb--;
        }, e, t)) : Fe(t) && (t.pendingcb++, St(e, t))));
    }
    function St(e, t) {
        t.pendingcb--, t.finished = !0;
        let n = t[de].splice(0);
        for(let r = 0; r < n.length; r++)n[r]();
        if (e.emit("finish"), t.autoDestroy) {
            let r1 = e._readableState;
            (!r1 || r1.autoDestroy && (r1.endEmitted || r1.readable === !1)) && e.destroy();
        }
    }
    ma(S.prototype, {
        closed: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.closed : !1;
            }
        },
        destroyed: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.destroyed : !1;
            },
            set (e) {
                this._writableState && (this._writableState.destroyed = e);
            }
        },
        writable: {
            __proto__: null,
            get () {
                let e = this._writableState;
                return !!e && e.writable !== !1 && !e.destroyed && !e.errored && !e.ending && !e.ended;
            },
            set (e) {
                this._writableState && (this._writableState.writable = !!e);
            }
        },
        writableFinished: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.finished : !1;
            }
        },
        writableObjectMode: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.objectMode : !1;
            }
        },
        writableBuffer: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.getBuffer();
            }
        },
        writableEnded: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.ending : !1;
            }
        },
        writableNeedDrain: {
            __proto__: null,
            get () {
                let e = this._writableState;
                return e ? !e.destroyed && !e.ending && e.needDrain : !1;
            }
        },
        writableHighWaterMark: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.highWaterMark;
            }
        },
        writableCorked: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.corked : 0;
            }
        },
        writableLength: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.length;
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._writableState ? this._writableState.errored : null;
            }
        },
        writableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
            }
        }
    });
    var Ba = Be.destroy;
    S.prototype.destroy = function(e, t) {
        let n = this._writableState;
        return !n.destroyed && (n.bufferedIndex < n.buffered.length || n[de].length) && te.nextTick(Rt, n), Ba.call(this, e, t), this;
    };
    S.prototype._undestroy = Be.undestroy;
    S.prototype._destroy = function(e, t) {
        t(e);
    };
    S.prototype[Na.captureRejectionSymbol] = function(e) {
        this.destroy(e);
    };
    var gt;
    function Rr() {
        return gt === void 0 && (gt = {}), gt;
    }
    S.fromWeb = function(e, t) {
        return Rr().newStreamWritableFromWritableStream(e, t);
    };
    S.toWeb = function(e) {
        return Rr().newWritableStreamFromStreamWritable(e);
    };
});
var kr = g10((uu, Pr)=>{
    var It = __process$, Ga = __default4, { isReadable: Ha , isWritable: Va , isIterable: mr , isNodeStream: Ya , isReadableNodeStream: Tr , isWritableNodeStream: Ir , isDuplexNodeStream: Ka  } = V7(), Mr = Y10(), { AbortError: Lr , codes: { ERR_INVALID_ARG_TYPE: za , ERR_INVALID_RETURN_VALUE: Nr  }  } = O13(), { destroyer: ce  } = Z11(), Xa = v9(), Ja = we10(), { createDeferredPromise: Dr  } = j13(), Or = ct1(), qr = globalThis.Blob || Ga.Blob, Qa = typeof qr < "u" ? function(t) {
        return t instanceof qr;
    } : function(t) {
        return !1;
    }, Za = globalThis.AbortController, { FunctionPrototypeCall: xr  } = m6(), ne = class extends Xa {
        constructor(t){
            super(t), t?.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), t?.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
        }
    };
    Pr.exports = function e(t, n) {
        if (Ka(t)) return t;
        if (Tr(t)) return Ge({
            readable: t
        });
        if (Ir(t)) return Ge({
            writable: t
        });
        if (Ya(t)) return Ge({
            writable: !1,
            readable: !1
        });
        if (typeof t == "function") {
            let { value: i , write: o , final: l , destroy: u  } = ef(t);
            if (mr(i)) return Or(ne, i, {
                objectMode: !0,
                write: o,
                final: l,
                destroy: u
            });
            let f = i?.then;
            if (typeof f == "function") {
                let a, c = xr(f, i, (s)=>{
                    if (s != null) throw new Nr("nully", "body", s);
                }, (s)=>{
                    ce(a, s);
                });
                return a = new ne({
                    objectMode: !0,
                    readable: !1,
                    write: o,
                    final (s) {
                        l(async ()=>{
                            try {
                                await c, It.nextTick(s, null);
                            } catch (b) {
                                It.nextTick(s, b);
                            }
                        });
                    },
                    destroy: u
                });
            }
            throw new Nr("Iterable, AsyncIterable or AsyncFunction", n, i);
        }
        if (Qa(t)) return e(t.arrayBuffer());
        if (mr(t)) return Or(ne, t, {
            objectMode: !0,
            writable: !1
        });
        if (typeof t?.writable == "object" || typeof t?.readable == "object") {
            let i1 = t != null && t.readable ? Tr(t?.readable) ? t?.readable : e(t.readable) : void 0, o1 = t != null && t.writable ? Ir(t?.writable) ? t?.writable : e(t.writable) : void 0;
            return Ge({
                readable: i1,
                writable: o1
            });
        }
        let r = t?.then;
        if (typeof r == "function") {
            let i2;
            return xr(r, t, (o)=>{
                o != null && i2.push(o), i2.push(null);
            }, (o)=>{
                ce(i2, o);
            }), i2 = new ne({
                objectMode: !0,
                writable: !1,
                read () {}
            });
        }
        throw new za(n, [
            "Blob",
            "ReadableStream",
            "WritableStream",
            "Stream",
            "Iterable",
            "AsyncIterable",
            "Function",
            "{ readable, writable } pair",
            "Promise"
        ], t);
    };
    function ef(e) {
        let { promise: t , resolve: n  } = Dr(), r = new Za, i = r.signal;
        return {
            value: e(async function*() {
                for(;;){
                    let l = t;
                    t = null;
                    let { chunk: u , done: f , cb: a  } = await l;
                    if (It.nextTick(a), f) return;
                    if (i.aborted) throw new Lr(void 0, {
                        cause: i.reason
                    });
                    ({ promise: t , resolve: n  } = Dr()), yield u;
                }
            }(), {
                signal: i
            }),
            write (l, u, f) {
                let a = n;
                n = null, a({
                    chunk: l,
                    done: !1,
                    cb: f
                });
            },
            final (l) {
                let u = n;
                n = null, u({
                    done: !0,
                    cb: l
                });
            },
            destroy (l, u) {
                r.abort(), u(l);
            }
        };
    }
    function Ge(e) {
        let t = e.readable && typeof e.readable.read != "function" ? Ja.wrap(e.readable) : e.readable, n = e.writable, r = !!Ha(t), i = !!Va(n), o, l, u, f, a;
        function c(s) {
            let b = f;
            f = null, b ? b(s) : s ? a.destroy(s) : !r && !i && a.destroy();
        }
        return a = new ne({
            readableObjectMode: !!(t != null && t.readableObjectMode),
            writableObjectMode: !!(n != null && n.writableObjectMode),
            readable: r,
            writable: i
        }), i && (Mr(n, (s)=>{
            i = !1, s && ce(t, s), c(s);
        }), a._write = function(s, b, d) {
            n.write(s, b) ? d() : o = d;
        }, a._final = function(s) {
            n.end(), l = s;
        }, n.on("drain", function() {
            if (o) {
                let s = o;
                o = null, s();
            }
        }), n.on("finish", function() {
            if (l) {
                let s = l;
                l = null, s();
            }
        })), r && (Mr(t, (s)=>{
            r = !1, s && ce(t, s), c(s);
        }), t.on("readable", function() {
            if (u) {
                let s = u;
                u = null, s();
            }
        }), t.on("end", function() {
            a.push(null);
        }), a._read = function() {
            for(;;){
                let s = t.read();
                if (s === null) {
                    u = a._read;
                    return;
                }
                if (!a.push(s)) return;
            }
        }), a._destroy = function(s, b) {
            !s && f !== null && (s = new Lr), u = null, o = null, l = null, f === null ? b(s) : (f = b, ce(n, s), ce(t, s));
        }, a;
    }
});
var v9 = g10((su, jr)=>{
    "use strict";
    var { ObjectDefineProperties: tf , ObjectGetOwnPropertyDescriptor: B , ObjectKeys: nf , ObjectSetPrototypeOf: Wr  } = m6();
    jr.exports = C;
    var Dt = we10(), x = Tt1();
    Wr(C.prototype, Dt.prototype);
    Wr(C, Dt);
    {
        let e = nf(x.prototype);
        for(let t = 0; t < e.length; t++){
            let n = e[t];
            C.prototype[n] || (C.prototype[n] = x.prototype[n]);
        }
    }
    function C(e) {
        if (!(this instanceof C)) return new C(e);
        Dt.call(this, e), x.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== !1, e.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), e.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
    }
    tf(C.prototype, {
        writable: {
            __proto__: null,
            ...B(x.prototype, "writable")
        },
        writableHighWaterMark: {
            __proto__: null,
            ...B(x.prototype, "writableHighWaterMark")
        },
        writableObjectMode: {
            __proto__: null,
            ...B(x.prototype, "writableObjectMode")
        },
        writableBuffer: {
            __proto__: null,
            ...B(x.prototype, "writableBuffer")
        },
        writableLength: {
            __proto__: null,
            ...B(x.prototype, "writableLength")
        },
        writableFinished: {
            __proto__: null,
            ...B(x.prototype, "writableFinished")
        },
        writableCorked: {
            __proto__: null,
            ...B(x.prototype, "writableCorked")
        },
        writableEnded: {
            __proto__: null,
            ...B(x.prototype, "writableEnded")
        },
        writableNeedDrain: {
            __proto__: null,
            ...B(x.prototype, "writableNeedDrain")
        },
        destroyed: {
            __proto__: null,
            get () {
                return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set (e) {
                this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
            }
        }
    });
    var Mt;
    function Cr() {
        return Mt === void 0 && (Mt = {}), Mt;
    }
    C.fromWeb = function(e, t) {
        return Cr().newStreamDuplexFromReadableWritablePair(e, t);
    };
    C.toWeb = function(e) {
        return Cr().newReadableWritablePairFromDuplex(e);
    };
    var Nt;
    C.from = function(e) {
        return Nt || (Nt = kr()), Nt(e, "body");
    };
});
var xt1 = g10((du, vr)=>{
    "use strict";
    var { ObjectSetPrototypeOf: $r , Symbol: rf  } = m6();
    vr.exports = G;
    var { ERR_METHOD_NOT_IMPLEMENTED: of  } = O13().codes, qt = v9(), { getHighWaterMark: lf  } = Ce11();
    $r(G.prototype, qt.prototype);
    $r(G, qt);
    var Ee = rf("kCallback");
    function G(e) {
        if (!(this instanceof G)) return new G(e);
        let t = e ? lf(this, e, "readableHighWaterMark", !0) : null;
        t === 0 && (e = {
            ...e,
            highWaterMark: null,
            readableHighWaterMark: t,
            writableHighWaterMark: e.writableHighWaterMark || 0
        }), qt.call(this, e), this._readableState.sync = !1, this[Ee] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", af);
    }
    function Ot(e) {
        typeof this._flush == "function" && !this.destroyed ? this._flush((t, n)=>{
            if (t) {
                e ? e(t) : this.destroy(t);
                return;
            }
            n != null && this.push(n), this.push(null), e && e();
        }) : (this.push(null), e && e());
    }
    function af() {
        this._final !== Ot && Ot.call(this);
    }
    G.prototype._final = Ot;
    G.prototype._transform = function(e, t, n) {
        throw new of("_transform()");
    };
    G.prototype._write = function(e, t, n) {
        let r = this._readableState, i = this._writableState, o = r.length;
        this._transform(e, t, (l, u)=>{
            if (l) {
                n(l);
                return;
            }
            u != null && this.push(u), i.ended || o === r.length || r.length < r.highWaterMark ? n() : this[Ee] = n;
        });
    };
    G.prototype._read = function() {
        if (this[Ee]) {
            let e = this[Ee];
            this[Ee] = null, e();
        }
    };
});
var Pt1 = g10((cu, Ur)=>{
    "use strict";
    var { ObjectSetPrototypeOf: Fr  } = m6();
    Ur.exports = he;
    var Lt = xt1();
    Fr(he.prototype, Lt.prototype);
    Fr(he, Lt);
    function he(e) {
        if (!(this instanceof he)) return new he(e);
        Lt.call(this, e);
    }
    he.prototype._transform = function(e, t, n) {
        n(null, e);
    };
});
var Ye5 = g10((hu, zr)=>{
    var He = __process$, { ArrayIsArray: ff , Promise: uf , SymbolAsyncIterator: sf  } = m6(), Ve = Y10(), { once: df  } = j13(), cf = Z11(), Br = v9(), { aggregateTwoErrors: hf , codes: { ERR_INVALID_ARG_TYPE: Yr , ERR_INVALID_RETURN_VALUE: kt , ERR_MISSING_ARGS: bf , ERR_STREAM_DESTROYED: _f , ERR_STREAM_PREMATURE_CLOSE: pf  } , AbortError: wf  } = O13(), { validateFunction: yf , validateAbortSignal: gf  } = _e9(), { isIterable: be , isReadable: Wt , isReadableNodeStream: $t , isNodeStream: Gr  } = V7(), Sf = globalThis.AbortController, Ct, jt;
    function Hr(e, t, n) {
        let r = !1;
        e.on("close", ()=>{
            r = !0;
        });
        let i = Ve(e, {
            readable: t,
            writable: n
        }, (o)=>{
            r = !o;
        });
        return {
            destroy: (o)=>{
                r || (r = !0, cf.destroyer(e, o || new _f("pipe")));
            },
            cleanup: i
        };
    }
    function Ef(e) {
        return yf(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function Rf(e) {
        if (be(e)) return e;
        if ($t(e)) return Af(e);
        throw new Yr("val", [
            "Readable",
            "Iterable",
            "AsyncIterable"
        ], e);
    }
    async function* Af(e) {
        jt || (jt = we10()), yield* jt.prototype[sf].call(e);
    }
    async function Vr(e, t, n, { end: r  }) {
        let i, o = null, l = (a)=>{
            if (a && (i = a), o) {
                let c = o;
                o = null, c();
            }
        }, u = ()=>new uf((a, c)=>{
                i ? c(i) : o = ()=>{
                    i ? c(i) : a();
                };
            });
        t.on("drain", l);
        let f = Ve(t, {
            readable: !1
        }, l);
        try {
            t.writableNeedDrain && await u();
            for await (let a of e)t.write(a) || await u();
            r && t.end(), await u(), n();
        } catch (a1) {
            n(i !== a1 ? hf(i, a1) : a1);
        } finally{
            f(), t.off("drain", l);
        }
    }
    function mf(...e) {
        return Kr(e, df(Ef(e)));
    }
    function Kr(e, t, n) {
        if (e.length === 1 && ff(e[0]) && (e = e[0]), e.length < 2) throw new bf("streams");
        let r = new Sf, i = r.signal, o = n?.signal, l = [];
        gf(o, "options.signal");
        function u() {
            d(new wf);
        }
        o?.addEventListener("abort", u);
        let f, a, c = [], s = 0;
        function b(_) {
            d(_, --s === 0);
        }
        function d(_, p) {
            if (_ && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = _), !(!f && !p)) {
                for(; c.length;)c.shift()(f);
                o?.removeEventListener("abort", u), r.abort(), p && (f || l.forEach((I)=>I()), He.nextTick(t, f, a));
            }
        }
        let h;
        for(let _ = 0; _ < e.length; _++){
            let p = e[_], I = _ < e.length - 1, M = _ > 0, F = I || n?.end !== !1, re = _ === e.length - 1;
            if (Gr(p)) {
                let P = function(U) {
                    U && U.name !== "AbortError" && U.code !== "ERR_STREAM_PREMATURE_CLOSE" && b(U);
                };
                if (F) {
                    let { destroy: U , cleanup: ze  } = Hr(p, I, M);
                    c.push(U), Wt(p) && re && l.push(ze);
                }
                p.on("error", P), Wt(p) && re && l.push(()=>{
                    p.removeListener("error", P);
                });
            }
            if (_ === 0) if (typeof p == "function") {
                if (h = p({
                    signal: i
                }), !be(h)) throw new kt("Iterable, AsyncIterable or Stream", "source", h);
            } else be(p) || $t(p) ? h = p : h = Br.from(p);
            else if (typeof p == "function") if (h = Rf(h), h = p(h, {
                signal: i
            }), I) {
                if (!be(h, !0)) throw new kt("AsyncIterable", `transform[${_ - 1}]`, h);
            } else {
                var D;
                Ct || (Ct = Pt1());
                let P1 = new Ct({
                    objectMode: !0
                }), U1 = (D = h) === null || D === void 0 ? void 0 : D.then;
                if (typeof U1 == "function") s++, U1.call(h, (ie)=>{
                    a = ie, ie != null && P1.write(ie), F && P1.end(), He.nextTick(b);
                }, (ie)=>{
                    P1.destroy(ie), He.nextTick(b, ie);
                });
                else if (be(h, !0)) s++, Vr(h, P1, b, {
                    end: F
                });
                else throw new kt("AsyncIterable or Promise", "destination", h);
                h = P1;
                let { destroy: ze1 , cleanup: _i  } = Hr(h, !1, !0);
                c.push(ze1), re && l.push(_i);
            }
            else if (Gr(p)) {
                if ($t(h)) {
                    s += 2;
                    let P2 = Tf(h, p, b, {
                        end: F
                    });
                    Wt(p) && re && l.push(P2);
                } else if (be(h)) s++, Vr(h, p, b, {
                    end: F
                });
                else throw new Yr("val", [
                    "Readable",
                    "Iterable",
                    "AsyncIterable"
                ], h);
                h = p;
            } else h = Br.from(p);
        }
        return (i != null && i.aborted || o != null && o.aborted) && He.nextTick(u), h;
    }
    function Tf(e, t, n, { end: r  }) {
        let i = !1;
        return t.on("close", ()=>{
            i || n(new pf);
        }), e.pipe(t, {
            end: r
        }), r ? e.once("end", ()=>{
            i = !0, t.end();
        }) : n(), Ve(e, {
            readable: !0,
            writable: !1
        }, (o)=>{
            let l = e._readableState;
            o && o.code === "ERR_STREAM_PREMATURE_CLOSE" && l && l.ended && !l.errored && !l.errorEmitted ? e.once("end", n).once("error", n) : n(o);
        }), Ve(t, {
            readable: !1,
            writable: !0
        }, n);
    }
    zr.exports = {
        pipelineImpl: Kr,
        pipeline: mf
    };
});
var ei1 = g10((bu, Zr)=>{
    "use strict";
    var { pipeline: If  } = Ye5(), Ke = v9(), { destroyer: Mf  } = Z11(), { isNodeStream: Nf , isReadable: Xr , isWritable: Jr  } = V7(), { AbortError: Df , codes: { ERR_INVALID_ARG_VALUE: Qr , ERR_MISSING_ARGS: Of  }  } = O13();
    Zr.exports = function(...t) {
        if (t.length === 0) throw new Of("streams");
        if (t.length === 1) return Ke.from(t[0]);
        let n = [
            ...t
        ];
        if (typeof t[0] == "function" && (t[0] = Ke.from(t[0])), typeof t[t.length - 1] == "function") {
            let d = t.length - 1;
            t[d] = Ke.from(t[d]);
        }
        for(let d1 = 0; d1 < t.length; ++d1)if (!!Nf(t[d1])) {
            if (d1 < t.length - 1 && !Xr(t[d1])) throw new Qr(`streams[${d1}]`, n[d1], "must be readable");
            if (d1 > 0 && !Jr(t[d1])) throw new Qr(`streams[${d1}]`, n[d1], "must be writable");
        }
        let r, i, o, l, u;
        function f(d) {
            let h = l;
            l = null, h ? h(d) : d ? u.destroy(d) : !b && !s && u.destroy();
        }
        let a = t[0], c = If(t, f), s = !!Jr(a), b = !!Xr(c);
        return u = new Ke({
            writableObjectMode: !!(a != null && a.writableObjectMode),
            readableObjectMode: !!(c != null && c.writableObjectMode),
            writable: s,
            readable: b
        }), s && (u._write = function(d, h, D) {
            a.write(d, h) ? D() : r = D;
        }, u._final = function(d) {
            a.end(), i = d;
        }, a.on("drain", function() {
            if (r) {
                let d = r;
                r = null, d();
            }
        }), c.on("finish", function() {
            if (i) {
                let d = i;
                i = null, d();
            }
        })), b && (c.on("readable", function() {
            if (o) {
                let d = o;
                o = null, d();
            }
        }), c.on("end", function() {
            u.push(null);
        }), u._read = function() {
            for(;;){
                let d = c.read();
                if (d === null) {
                    o = u._read;
                    return;
                }
                if (!u.push(d)) return;
            }
        }), u._destroy = function(d, h) {
            !d && l !== null && (d = new Df), o = null, r = null, i = null, l === null ? h(d) : (l = h, Mf(c, d));
        }, u;
    };
});
var vt1 = g10((_u, ti)=>{
    "use strict";
    var { ArrayPrototypePop: qf , Promise: xf  } = m6(), { isIterable: Lf , isNodeStream: Pf  } = V7(), { pipelineImpl: kf  } = Ye5(), { finished: Wf  } = Y10();
    function Cf(...e) {
        return new xf((t, n)=>{
            let r, i, o = e[e.length - 1];
            if (o && typeof o == "object" && !Pf(o) && !Lf(o)) {
                let l = qf(e);
                r = l.signal, i = l.end;
            }
            kf(e, (l, u)=>{
                l ? n(l) : t(u);
            }, {
                signal: r,
                end: i
            });
        });
    }
    ti.exports = {
        finished: Wf,
        pipeline: Cf
    };
});
var di1 = g10((pu, si)=>{
    var { Buffer: jf  } = __default4, { ObjectDefineProperty: H , ObjectKeys: ii , ReflectApply: oi  } = m6(), { promisify: { custom: li  }  } = j13(), { streamReturningOperators: ni , promiseReturningOperators: ri  } = xn2(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ai  }  } = O13(), $f = ei1(), { pipeline: fi  } = Ye5(), { destroyer: vf  } = Z11(), ui = Y10(), Ft = vt1(), Ut = V7(), R = si.exports = Le5().Stream;
    R.isDisturbed = Ut.isDisturbed;
    R.isErrored = Ut.isErrored;
    R.isReadable = Ut.isReadable;
    R.Readable = we10();
    for (let e of ii(ni)){
        let n = function(...r) {
            if (new.target) throw ai();
            return R.Readable.from(oi(t, this, r));
        };
        n;
        let t = ni[e];
        H(n, "name", {
            __proto__: null,
            value: t.name
        }), H(n, "length", {
            __proto__: null,
            value: t.length
        }), H(R.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: !1,
            configurable: !0,
            writable: !0
        });
    }
    for (let e1 of ii(ri)){
        let n1 = function(...i) {
            if (new.target) throw ai();
            return oi(t1, this, i);
        };
        n1;
        let t1 = ri[e1];
        H(n1, "name", {
            __proto__: null,
            value: t1.name
        }), H(n1, "length", {
            __proto__: null,
            value: t1.length
        }), H(R.Readable.prototype, e1, {
            __proto__: null,
            value: n1,
            enumerable: !1,
            configurable: !0,
            writable: !0
        });
    }
    R.Writable = Tt1();
    R.Duplex = v9();
    R.Transform = xt1();
    R.PassThrough = Pt1();
    R.pipeline = fi;
    var { addAbortSignal: Ff  } = ke7();
    R.addAbortSignal = Ff;
    R.finished = ui;
    R.destroy = vf;
    R.compose = $f;
    H(R, "promises", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get () {
            return Ft;
        }
    });
    H(fi, li, {
        __proto__: null,
        enumerable: !0,
        get () {
            return Ft.pipeline;
        }
    });
    H(ui, li, {
        __proto__: null,
        enumerable: !0,
        get () {
            return Ft.finished;
        }
    });
    R.Stream = R;
    R._isUint8Array = function(t) {
        return t instanceof Uint8Array;
    };
    R._uint8ArrayToBuffer = function(t) {
        return jf.from(t.buffer, t.byteOffset, t.byteLength);
    };
});
var ci1 = g10((wu, A)=>{
    "use strict";
    var T = di1(), Bf = vt1(), Gf = T.Readable.destroy;
    A.exports = T.Readable;
    A.exports._uint8ArrayToBuffer = T._uint8ArrayToBuffer;
    A.exports._isUint8Array = T._isUint8Array;
    A.exports.isDisturbed = T.isDisturbed;
    A.exports.isErrored = T.isErrored;
    A.exports.isReadable = T.isReadable;
    A.exports.Readable = T.Readable;
    A.exports.Writable = T.Writable;
    A.exports.Duplex = T.Duplex;
    A.exports.Transform = T.Transform;
    A.exports.PassThrough = T.PassThrough;
    A.exports.addAbortSignal = T.addAbortSignal;
    A.exports.finished = T.finished;
    A.exports.destroy = T.destroy;
    A.exports.destroy = Gf;
    A.exports.pipeline = T.pipeline;
    A.exports.compose = T.compose;
    Object.defineProperty(T, "promises", {
        configurable: !0,
        enumerable: !0,
        get () {
            return Bf;
        }
    });
    A.exports.Stream = T.Stream;
    A.exports.default = A.exports;
});
var bi1 = Ri2(ci1()), { _uint8ArrayToBuffer: yu , _isUint8Array: gu , isDisturbed: Su , isErrored: Eu , isReadable: Ru , Readable: Au , Writable: mu , Duplex: Tu , Transform: Iu , PassThrough: Mu , addAbortSignal: Nu , finished: Du , destroy: Ou , pipeline: qu , compose: xu , Stream: Lu  } = bi1, { default: hi1 , ...Hf1 } = bi1;
const process1 = __process$;
const { Buffer: Buffer3  } = __default4;
const Readable = Au;
const Writable = mu;
const Duplex = Tu;
function isReadableStream(object) {
    return object instanceof ReadableStream;
}
function isWritableStream(object) {
    return object instanceof WritableStream;
}
Readable.fromWeb = function(readableStream, options = kEmptyObject) {
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("readableStream", "ReadableStream", readableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , encoding , objectMode =false , signal  } = options;
    if (encoding !== undefined && !Buffer3.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    validateBoolean(objectMode, "options.objectMode");
    const reader = readableStream.getReader();
    let closed = false;
    const readable = new Readable({
        objectMode,
        highWaterMark,
        encoding,
        signal,
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    readable.push(null);
                } else {
                    readable.push(chunk.value);
                }
            }, (error)=>destroy.call(readable, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    process1.nextTick(()=>{
                        throw error1;
                    });
                }
            }
            if (!closed) {
                reader.cancel(error).then(done, done);
                return;
            }
            done();
        }
    });
    reader.closed.then(()=>{
        closed = true;
        if (!isReadableEnded1(readable)) {
            readable.push(null);
        }
    }, (error)=>{
        closed = true;
        destroy.call(readable, error);
    });
    return readable;
};
Writable.fromWeb = function(writableStream, options = kEmptyObject) {
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("writableStream", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , decodeStrings =true , objectMode =false , signal  } = options;
    validateBoolean(objectMode, "options.objectMode");
    validateBoolean(decodeStrings, "options.decodeStrings");
    const writer = writableStream.getWriter();
    let closed = false;
    const writable = new Writable({
        highWaterMark,
        objectMode,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error1) {
                    process1.nextTick(()=>destroy.call(writable, error1));
                }
            }
            writer.ready.then(()=>Promise.all(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer3.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    destroy(this, duplex, error1);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    process1.nextTick(()=>{
                        throw error1;
                    });
                }
            }
            if (!closed) {
                if (error != null) {
                    writer.abort(error).then(done, done);
                } else {
                    writer.close().then(done, done);
                }
                return;
            }
            done();
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    process1.nextTick(()=>destroy.call(writable, error1));
                }
            }
            if (!closed) {
                writer.close().then(done, done);
            }
        }
    });
    writer.closed.then(()=>{
        closed = true;
        if (!isWritableEnded(writable)) {
            destroy.call(writable, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        closed = true;
        destroy.call(writable, error);
    });
    return writable;
};
Duplex.fromWeb = function(pair, options = kEmptyObject) {
    validateObject(pair, "pair");
    const { readable: readableStream , writable: writableStream  } = pair;
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding , decodeStrings =true , highWaterMark , signal  } = options;
    validateBoolean(objectMode, "options.objectMode");
    if (encoding !== undefined && !Buffer3.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex1 = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error1) {
                    process1.nextTick(()=>destroy(duplex1, error1));
                }
            }
            writer.ready.then(()=>Promise.all(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer3.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    destroy(duplex1, error1);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    process1.nextTick(()=>destroy(duplex1, error1));
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex1.push(null);
                } else {
                    duplex1.push(chunk.value);
                }
            }, (error)=>destroy(duplex1, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    process1.nextTick(()=>{
                        throw error1;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.all([
                    closeWriter(),
                    closeReader()
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded(duplex1)) {
            destroy(duplex1, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded1(duplex1)) {
            duplex1.push(null);
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    return duplex1;
};
delete Readable.Duplex;
delete Readable.PassThrough;
delete Readable.Readable;
delete Readable.Stream;
delete Readable.Transform;
delete Readable.Writable;
delete Readable._isUint8Array;
delete Readable._uint8ArrayToBuffer;
delete Readable.addAbortSignal;
delete Readable.compose;
delete Readable.destroy;
delete Readable.finished;
delete Readable.isDisturbed;
delete Readable.isErrored;
delete Readable.isReadable;
delete Readable.pipeline;
function newReadableStreamFromStreamReadable(streamReadable, options = kEmptyObject) {
    if (typeof streamReadable?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("streamReadable", "stream.Readable", streamReadable);
    }
    if (isDestroyed(streamReadable) || !isReadable1(streamReadable)) {
        const readable = new ReadableStream();
        readable.cancel();
        return readable;
    }
    const objectMode = streamReadable.readableObjectMode;
    const highWaterMark = streamReadable.readableHighWaterMark;
    const evaluateStrategyOrFallback = (strategy)=>{
        if (strategy) {
            return strategy;
        }
        if (objectMode) {
            return new CountQueuingStrategy({
                highWaterMark
            });
        }
        return {
            highWaterMark
        };
    };
    const strategy = evaluateStrategyOrFallback(options?.strategy);
    let controller;
    function onData(chunk) {
        if (Buffer3.isBuffer(chunk) && !objectMode) {
            chunk = new Uint8Array(chunk);
        }
        controller.enqueue(chunk);
        if (controller.desiredSize <= 0) {
            streamReadable.pause();
        }
    }
    streamReadable.pause();
    const cleanup = eos(streamReadable, (error)=>{
        if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            const err = new AbortError(undefined, {
                cause: error
            });
            error = err;
        }
        cleanup();
        streamReadable.on("error", ()=>{});
        if (error) {
            return controller.error(error);
        }
        controller.close();
    });
    streamReadable.on("data", onData);
    return new ReadableStream({
        start (c) {
            controller = c;
        },
        pull () {
            streamReadable.resume();
        },
        cancel (reason) {
            destroy(streamReadable, reason);
        }
    }, strategy);
}
function newWritableStreamFromStreamWritable(streamWritable) {
    if (typeof streamWritable?._writableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("streamWritable", "stream.Writable", streamWritable);
    }
    if (isDestroyed(streamWritable) || !isWritable1(streamWritable)) {
        const writable = new WritableStream();
        writable.close();
        return writable;
    }
    const highWaterMark = streamWritable.writableHighWaterMark;
    const strategy = streamWritable.writableObjectMode ? new CountQueuingStrategy({
        highWaterMark
    }) : {
        highWaterMark
    };
    let controller;
    let backpressurePromise;
    let closed;
    function onDrain() {
        if (backpressurePromise !== undefined) {
            backpressurePromise.resolve();
        }
    }
    const cleanup = eos(streamWritable, (error)=>{
        if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            const err = new AbortError(undefined, {
                cause: error
            });
            error = err;
        }
        cleanup();
        streamWritable.on("error", ()=>{});
        if (error != null) {
            if (backpressurePromise !== undefined) {
                backpressurePromise.reject(error);
            }
            if (closed !== undefined) {
                closed.reject(error);
                closed = undefined;
            }
            controller.error(error);
            controller = undefined;
            return;
        }
        if (closed !== undefined) {
            closed.resolve();
            closed = undefined;
            return;
        }
        controller.error(new AbortError());
        controller = undefined;
    });
    streamWritable.on("drain", onDrain);
    return new WritableStream({
        start (c) {
            controller = c;
        },
        async write (chunk) {
            if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {
                backpressurePromise = createDeferredPromise();
                return backpressurePromise.promise.finally(()=>{
                    backpressurePromise = undefined;
                });
            }
        },
        abort (reason) {
            destroy(streamWritable, reason);
        },
        close () {
            if (closed === undefined && !isWritableEnded(streamWritable)) {
                closed = createDeferredPromise();
                streamWritable.end();
                return closed.promise;
            }
            controller = undefined;
            return Promise.resolve();
        }
    }, strategy);
}
function newReadableWritablePairFromDuplex(duplex1) {
    if (typeof duplex1?._writableState !== "object" || typeof duplex1?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("duplex", "stream.Duplex", duplex1);
    }
    if (isDestroyed(duplex1)) {
        const writable = new WritableStream();
        const readable = new ReadableStream();
        writable.close();
        readable.cancel();
        return {
            readable,
            writable
        };
    }
    const writable1 = isWritable1(duplex1) ? newWritableStreamFromStreamWritable(duplex1) : new WritableStream();
    if (!isWritable1(duplex1)) {
        writable1.close();
    }
    const readable1 = isReadable1(duplex1) ? newReadableStreamFromStreamReadable(duplex1) : new ReadableStream();
    if (!isReadable1(duplex1)) {
        readable1.cancel();
    }
    return {
        writable: writable1,
        readable: readable1
    };
}
Readable.toWeb = newReadableStreamFromStreamReadable;
Writable.toWeb = newWritableStreamFromStreamWritable;
Duplex.toWeb = newReadableWritablePairFromDuplex;
function createWritableStdioStream(writer, name) {
    const stream = new mu({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer2.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close"));
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close());
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.()) : undefined
        }
    });
    if (Deno.isatty?.(writer?.rid)) {
        stream.cursorTo = function(x, y, callback) {
            return cursorTo(this, x, y, callback);
        };
        stream.moveCursor = function(dx, dy, callback) {
            return moveCursor(this, dx, dy, callback);
        };
        stream.clearLine = function(dir, callback) {
            return clearLine(this, dir, callback);
        };
        stream.clearScreenDown = function(callback) {
            return clearScreenDown(this, callback);
        };
    }
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Au({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p = Buffer2.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p).then((length)=>{
            this.push(length === null ? null : p.slice(0, length));
        }, (error)=>{
            this.destroy(error);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    Deno.stdin?.setRaw?.(enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants1;
(function(constants) {
    constants[constants["kInit"] = 0] = "kInit";
    constants[constants["kBefore"] = 1] = "kBefore";
    constants[constants["kAfter"] = 2] = "kAfter";
    constants[constants["kDestroy"] = 3] = "kDestroy";
    constants[constants["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants[constants["kTotals"] = 5] = "kTotals";
    constants[constants["kCheck"] = 6] = "kCheck";
    constants[constants["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants[constants["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants[constants["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants[constants["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants[constants["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants[constants["kStackLength"] = 12] = "kStackLength";
})(constants1 || (constants1 = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants1).length);
function newAsyncId() {
    return ++asyncIdFields[constants1.kAsyncIdCounter];
}
var UidFields;
(function(UidFields) {
    UidFields[UidFields["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields[UidFields["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields[UidFields["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields[UidFields["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields[UidFields["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType) {
    providerType[providerType["NONE"] = 0] = "NONE";
    providerType[providerType["DIRHANDLE"] = 1] = "DIRHANDLE";
    providerType[providerType["DNSCHANNEL"] = 2] = "DNSCHANNEL";
    providerType[providerType["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
    providerType[providerType["FILEHANDLE"] = 4] = "FILEHANDLE";
    providerType[providerType["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
    providerType[providerType["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
    providerType[providerType["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
    providerType[providerType["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
    providerType[providerType["FSREQPROMISE"] = 9] = "FSREQPROMISE";
    providerType[providerType["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
    providerType[providerType["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
    providerType[providerType["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
    providerType[providerType["HTTP2SESSION"] = 13] = "HTTP2SESSION";
    providerType[providerType["HTTP2STREAM"] = 14] = "HTTP2STREAM";
    providerType[providerType["HTTP2PING"] = 15] = "HTTP2PING";
    providerType[providerType["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
    providerType[providerType["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
    providerType[providerType["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
    providerType[providerType["JSSTREAM"] = 19] = "JSSTREAM";
    providerType[providerType["JSUDPWRAP"] = 20] = "JSUDPWRAP";
    providerType[providerType["MESSAGEPORT"] = 21] = "MESSAGEPORT";
    providerType[providerType["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
    providerType[providerType["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
    providerType[providerType["PIPEWRAP"] = 24] = "PIPEWRAP";
    providerType[providerType["PROCESSWRAP"] = 25] = "PROCESSWRAP";
    providerType[providerType["PROMISE"] = 26] = "PROMISE";
    providerType[providerType["QUERYWRAP"] = 27] = "QUERYWRAP";
    providerType[providerType["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
    providerType[providerType["SIGNALWRAP"] = 29] = "SIGNALWRAP";
    providerType[providerType["STATWATCHER"] = 30] = "STATWATCHER";
    providerType[providerType["STREAMPIPE"] = 31] = "STREAMPIPE";
    providerType[providerType["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
    providerType[providerType["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
    providerType[providerType["TCPWRAP"] = 34] = "TCPWRAP";
    providerType[providerType["TTYWRAP"] = 35] = "TTYWRAP";
    providerType[providerType["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
    providerType[providerType["UDPWRAP"] = 37] = "UDPWRAP";
    providerType[providerType["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
    providerType[providerType["WORKER"] = 39] = "WORKER";
    providerType[providerType["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
    providerType[providerType["WRITEWRAP"] = 41] = "WRITEWRAP";
    providerType[providerType["ZLIB"] = 42] = "ZLIB";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod9 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants1,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod10 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
function ares_strerror(code) {
    const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled"
    ];
    if (code >= 0 && code < errorText.length) {
        return errorText[code];
    } else {
        return "unknown";
    }
}
class GetAddrInfoReqWrap extends AsyncWrap {
    family;
    hostname;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname, family, _hints, verbatim) {
    let addresses = [];
    const recordTypes = [];
    if (family === 0 || family === 4) {
        recordTypes.push("A");
    }
    if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
    }
    (async ()=>{
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record));
            })));
        const error = addresses.length ? 0 : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (isWindows && hostname === "localhost") {
            addresses = addresses.filter((address)=>isIPv4(address));
        }
        req.oncomplete(error, addresses);
    })();
    return 0;
}
class QueryReqWrap extends AsyncWrap {
    bindingName;
    hostname;
    ttl;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.QUERYWRAP);
    }
}
function fqdnToHostname(fqdn) {
    return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
    const formatted = address.replace(/\b(?:0+:){2,}/, ":");
    const finalAddress = formatted.split(":").map((octet)=>{
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
    }).join(":");
    return finalAddress;
}
class ChannelWrap extends AsyncWrap {
    #servers = [];
    #timeout;
    #tries;
    constructor(timeout, tries){
        super(providerType.DNSCHANNEL);
        this.#timeout = timeout;
        this.#tries = tries;
    }
    async #query(query, recordType) {
        let code;
        let ret;
        if (this.#servers.length) {
            for (const [ipAddr, port] of this.#servers){
                const resolveOptions = {
                    nameServer: {
                        ipAddr,
                        port
                    }
                };
                ({ code , ret  } = await this.#resolve(query, recordType, resolveOptions));
                if (code === 0 || code === codeMap.get("EAI_NODATA")) {
                    break;
                }
            }
        } else {
            ({ code , ret  } = await this.#resolve(query, recordType));
        }
        return {
            code: code,
            ret: ret
        };
    }
    async #resolve(query1, recordType1, resolveOptions1) {
        let ret1 = [];
        let code1 = 0;
        try {
            ret1 = await Deno.resolveDns(query1, recordType1, resolveOptions1);
        } catch (e3) {
            if (e3 instanceof Deno.errors.NotFound) {
                code1 = codeMap.get("EAI_NODATA");
            } else {
                code1 = codeMap.get("UNKNOWN");
            }
        }
        return {
            code: code1,
            ret: ret1
        };
    }
    queryAny(req, name) {
        (async ()=>{
            const records = [];
            await Promise.allSettled([
                this.#query(name, "A").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "A",
                            address: record
                        }));
                }),
                this.#query(name, "AAAA").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "AAAA",
                            address: compressIPv6(record)
                        }));
                }),
                this.#query(name, "CAA").then(({ ret  })=>{
                    ret.forEach(({ critical , tag , value  })=>records.push({
                            type: "CAA",
                            [tag]: value,
                            critical: +critical && 128
                        }));
                }),
                this.#query(name, "CNAME").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "CNAME",
                            value: record
                        }));
                }),
                this.#query(name, "MX").then(({ ret  })=>{
                    ret.forEach(({ preference , exchange  })=>records.push({
                            type: "MX",
                            priority: preference,
                            exchange: fqdnToHostname(exchange)
                        }));
                }),
                this.#query(name, "NAPTR").then(({ ret  })=>{
                    ret.forEach(({ order , preference , flags , services , regexp , replacement  })=>records.push({
                            type: "NAPTR",
                            order,
                            preference,
                            flags,
                            service: services,
                            regexp,
                            replacement
                        }));
                }),
                this.#query(name, "NS").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "NS",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "PTR").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "PTR",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "SOA").then(({ ret  })=>{
                    ret.forEach(({ mname , rname , serial , refresh , retry , expire , minimum  })=>records.push({
                            type: "SOA",
                            nsname: fqdnToHostname(mname),
                            hostmaster: fqdnToHostname(rname),
                            serial,
                            refresh,
                            retry,
                            expire,
                            minttl: minimum
                        }));
                }),
                this.#query(name, "SRV").then(({ ret  })=>{
                    ret.forEach(({ priority , weight , port , target  })=>records.push({
                            type: "SRV",
                            priority,
                            weight,
                            port,
                            name: target
                        }));
                }),
                this.#query(name, "TXT").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "TXT",
                            entries: record
                        }));
                })
            ]);
            const err = records.length ? 0 : codeMap.get("EAI_NODATA");
            req.oncomplete(err, records);
        })();
        return 0;
    }
    queryA(req, name) {
        this.#query(name, "A").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryAaaa(req, name) {
        this.#query(name, "AAAA").then(({ code , ret  })=>{
            const records = ret.map((record)=>compressIPv6(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCaa(req, name) {
        this.#query(name, "CAA").then(({ code , ret  })=>{
            const records = ret.map(({ critical , tag , value  })=>({
                    [tag]: value,
                    critical: +critical && 128
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCname(req, name) {
        this.#query(name, "CNAME").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryMx(req, name) {
        this.#query(name, "MX").then(({ code , ret  })=>{
            const records = ret.map(({ preference , exchange  })=>({
                    priority: preference,
                    exchange: fqdnToHostname(exchange)
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNaptr(req, name) {
        this.#query(name, "NAPTR").then(({ code , ret  })=>{
            const records = ret.map(({ order , preference , flags , services , regexp , replacement  })=>({
                    flags,
                    service: services,
                    regexp,
                    replacement,
                    order,
                    preference
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNs(req, name) {
        this.#query(name, "NS").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryPtr(req, name) {
        this.#query(name, "PTR").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    querySoa(req, name) {
        this.#query(name, "SOA").then(({ code , ret  })=>{
            let record = {};
            if (ret.length) {
                const { mname , rname , serial , refresh , retry , expire , minimum  } = ret[0];
                record = {
                    nsname: fqdnToHostname(mname),
                    hostmaster: fqdnToHostname(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum
                };
            }
            req.oncomplete(code, record);
        });
        return 0;
    }
    querySrv(req, name) {
        this.#query(name, "SRV").then(({ code , ret  })=>{
            const records = ret.map(({ priority , weight , port , target  })=>({
                    priority,
                    weight,
                    port,
                    name: target
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryTxt(req, name) {
        this.#query(name, "TXT").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    getHostByAddr(_req, _name) {
        notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
    }
    getServers() {
        return this.#servers;
    }
    setServers(servers) {
        if (typeof servers === "string") {
            const tuples = [];
            for(let i = 0; i < servers.length; i += 2){
                tuples.push([
                    servers[i],
                    parseInt(servers[i + 1])
                ]);
            }
            this.#servers = tuples;
        } else {
            this.#servers = servers.map(([_ipVersion, ip, port])=>[
                    ip,
                    port
                ]);
        }
        return 0;
    }
    setLocalAddress(_addr0, _addr1) {
        notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
    }
    cancel() {
        notImplemented("cares.ChannelWrap.prototype.cancel");
    }
}
const DNS_ESETSRVPENDING = -1000;
const EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code) {
    return code === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code);
}
const mod11 = {
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo,
    QueryReqWrap: QueryReqWrap,
    ChannelWrap: ChannelWrap,
    strerror: strerror
};
const mod12 = {};
function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    if (!(a instanceof DataView)) {
        a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
    }
    if (!(b instanceof DataView)) {
        b = new DataView(ArrayBuffer.isView(b) ? b.buffer : b);
    }
    assert(a instanceof DataView);
    assert(b instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i = -1;
    while(++i < length){
        out |= a.getUint8(i) ^ b.getUint8(i);
    }
    return out === 0;
}
const timingSafeEqual1 = (a, b)=>{
    if (a instanceof Buffer2) a = new DataView(a.buffer);
    if (a instanceof Buffer2) b = new DataView(a.buffer);
    return timingSafeEqual(a, b);
};
function getFipsCrypto() {
    notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
    notImplemented("crypto.setFipsCrypto");
}
const mod13 = {
    timingSafeEqual: timingSafeEqual1,
    getFipsCrypto: getFipsCrypto,
    setFipsCrypto: setFipsCrypto
};
const mod14 = {};
const mod15 = {};
const mod16 = {};
const mod17 = {};
const mod18 = {};
const mod19 = {};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
const mod29 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    close(cb = ()=>{}) {
        this._onClose();
        queueMicrotask(cb);
    }
    ref() {
        unreachable();
    }
    unref() {
        unreachable();
    }
    _onClose() {}
}
var StreamBaseStateFields;
(function(StreamBaseStateFields) {
    StreamBaseStateFields[StreamBaseStateFields["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields[StreamBaseStateFields["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields[StreamBaseStateFields["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields[StreamBaseStateFields["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields[StreamBaseStateFields["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            this.#read();
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        const status = this._onClose();
        try {
            req.oncomplete(status);
        } catch  {}
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
    }
    writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
    }
    writev(req, chunks, allBuffers) {
        const count = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count);
        if (!allBuffers) {
            for(let i = 0; i < count; i++){
                const chunk = chunks[i * 2];
                if (Buffer2.isBuffer(chunk)) {
                    buffers[i] = chunk;
                }
                const encoding = chunks[i * 2 + 1];
                buffers[i] = Buffer2.from(chunk, encoding);
            }
        } else {
            for(let i1 = 0; i1 < count; i1++){
                buffers[i1] = chunks[i1];
            }
        }
        return this.writeBuffer(req, Buffer2.concat(buffers));
    }
    writeAsciiString(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
    }
    writeLatin1String(req, data) {
        const buffer = Buffer2.from(data, "latin1");
        return this.writeBuffer(req, buffer);
    }
    _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        return status;
    }
    #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e4) {
            if (e4 instanceof Deno.errors.Interrupted || e4 instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else if (e4 instanceof Deno.errors.ConnectionReset || e4 instanceof Deno.errors.ConnectionAborted) {
                nread = codeMap.get("ECONNRESET");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            this.#read();
        }
    }
    async #write(req, data) {
        const { byteLength: byteLength2  } = data;
        try {
            await writeAll(this[kStreamBaseField], data);
        } catch (e11) {
            let status;
            if (e11 instanceof Deno.errors.BadResource || e11 instanceof Deno.errors.BrokenPipe) {
                status = codeMap.get("EBADF");
            } else {
                status = codeMap.get("UNKNOWN");
            }
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength2;
        this.bytesWritten += byteLength2;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod30 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req.oncomplete(status, this, req, readable, writable);
        } catch  {}
        return;
    }
}
function ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
var socketType;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
    socketType[socketType["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    #pendingInstances = 4;
    #address;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        let ipc;
        switch(type){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        this.ipc = ipc;
        if (conn && provider === providerType.PIPEWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.path;
        }
    }
    open(_fd) {
        notImplemented("Pipe.prototype.open");
    }
    bind(name) {
        this.#address = name;
        return 0;
    }
    connect(req, address) {
        if (isWindows) {
            notImplemented("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
            path: address,
            transport: "unix"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req.address = localAddr.path;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req, 0);
            } catch  {}
        }, (e)=>{
            let code;
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                code = codeMap.get("EACCES");
            } else {
                code = codeMap.get("ECONNREFUSED");
            }
            try {
                this.afterConnect(req, code);
            } catch  {}
        });
        return 0;
    }
    listen(backlog) {
        if (isWindows) {
            notImplemented("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
        const listenOptions = {
            path: this.#address,
            transport: "unix"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            this.#listener.ref();
        }
    }
    unref() {
        if (this.#listener) {
            this.#listener.unref();
        }
    }
    setPendingInstances(instances) {
        this.#pendingInstances = instances;
    }
    fchmod(mode) {
        if (mode != constants2.UV_READABLE && mode != constants2.UV_WRITABLE && mode != (constants2.UV_WRITABLE | constants2.UV_READABLE)) {
            return codeMap.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants2.UV_READABLE) {
            desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
        }
        if (mode & constants2.UV_WRITABLE) {
            desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
        }
        try {
            Deno.chmodSync(this.#address, desired_mode);
        } catch  {
            return codeMap.get("UNKNOWN");
        }
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e5) {
            if (e5 instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new Pipe(socketType.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.PIPESERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants2;
(function(constants) {
    constants[constants["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType.SERVER] = "SERVER";
    constants[constants["IPC"] = socketType.IPC] = "IPC";
    constants[constants["UV_READABLE"] = 1] = "UV_READABLE";
    constants[constants["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants2 || (constants2 = {}));
const mod31 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants2
};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const mod37 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod38 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod39 = {};
var socketType1;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants3;
(function(constants) {
    constants[constants["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType1.SERVER] = "SERVER";
    constants[constants["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants3 || (constants3 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        switch(type){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname);
        }
    }
    open(_fd) {
        notImplemented("TCP.prototype.open");
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req, address, port) {
        return this.#connect(req, address, port);
    }
    connect6(req, address, port) {
        return this.#connect(req, address, port);
    }
    listen(backlog) {
        this.#backlog = ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            this.#listener.ref();
        }
    }
    unref() {
        if (this.#listener) {
            this.#listener.unref();
        }
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address);
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented("TCP.prototype.setSimultaneousAccepts");
    }
    #bind(address, port1, _flags) {
        this.#address = address;
        this.#port = port1;
        return 0;
    }
    #connect(req1, address1, port11) {
        this.#remoteAddress = address1;
        this.#remotePort = port11;
        this.#remoteFamily = isIP(address1);
        const connectOptions = {
            hostname: address1,
            port: port11,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req1.localAddress = localAddr.hostname;
            this.#port = req1.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req1, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req1, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection1;
        try {
            connection1 = await this.#listener.accept();
        } catch (e6) {
            if (e6 instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle1 = new TCP(socketType1.SOCKET, connection1);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle1);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod40 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants3,
    TCP: TCP
};
const mod41 = {};
const mod42 = {};
const mod43 = {};
const mod44 = {};
const AF_INET6 = 10;
const UDP_DGRAM_MAXSIZE = 64 * 1024;
class SendWrap extends AsyncWrap {
    list;
    address;
    port;
    callback;
    oncomplete;
    constructor(){
        super(providerType.UDPSENDWRAP);
    }
}
class UDP extends HandleWrap {
    [ownerSymbol] = null;
    #address;
    #family;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #listener;
    #receiving = false;
    #recvBufferSize = UDP_DGRAM_MAXSIZE;
    #sendBufferSize = UDP_DGRAM_MAXSIZE;
    onmessage;
    lookup;
    constructor(){
        super(providerType.UDPWRAP);
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addMembership");
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
    }
    bind(ip, port, flags) {
        return this.#doBind(ip, port, flags, 2);
    }
    bind6(ip, port, flags) {
        return this.#doBind(ip, port, flags, 10);
    }
    bufferSize(size, buffer, ctx) {
        let err;
        if (size > UDP_DGRAM_MAXSIZE) {
            err = "EINVAL";
        } else if (!this.#address) {
            err = isWindows ? "ENOTSOCK" : "EBADF";
        }
        if (err) {
            ctx.errno = codeMap.get(err);
            ctx.code = err;
            ctx.message = errorMap.get(ctx.errno)[1];
            ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
            return;
        }
        if (size !== 0) {
            size = isLinux ? size * 2 : size;
            if (buffer) {
                return this.#recvBufferSize = size;
            }
            return this.#sendBufferSize = size;
        }
        return buffer ? this.#recvBufferSize : this.#sendBufferSize;
    }
    connect(ip, port) {
        return this.#doConnect(ip, port, 2);
    }
    connect6(ip, port) {
        return this.#doConnect(ip, port, 10);
    }
    disconnect() {
        this.#remoteAddress = undefined;
        this.#remotePort = undefined;
        this.#remoteFamily = undefined;
        return 0;
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropMembership");
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
    }
    getpeername(peername) {
        if (this.#remoteAddress === undefined) {
            return codeMap.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    getsockname(sockname) {
        if (this.#address === undefined) {
            return codeMap.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
    }
    open(_fd) {
        notImplemented("udp.UDP.prototype.open");
    }
    recvStart() {
        if (!this.#receiving) {
            this.#receiving = true;
            this.#receive();
        }
        return 0;
    }
    recvStop() {
        this.#receiving = false;
        return 0;
    }
    ref() {
        notImplemented("udp.UDP.prototype.ref");
    }
    send(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 2);
    }
    send6(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 10);
    }
    setBroadcast(_bool) {
        notImplemented("udp.UDP.prototype.setBroadcast");
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented("udp.UDP.prototype.setMulticastInterface");
    }
    setMulticastLoopback(_bool) {
        notImplemented("udp.UDP.prototype.setMulticastLoopback");
    }
    setMulticastTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setMulticastTTL");
    }
    setTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setTTL");
    }
    unref() {
        notImplemented("udp.UDP.prototype.unref");
    }
    #doBind(ip, port2, _flags1, family) {
        const listenOptions = {
            port: port2,
            hostname: ip,
            transport: "udp"
        };
        let listener;
        try {
            listener = Deno.listenDatagram(listenOptions);
        } catch (e7) {
            if (e7 instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e7 instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address2 = listener.addr;
        this.#address = address2.hostname;
        this.#port = address2.port;
        this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
        this.#listener = listener;
        return 0;
    }
    #doConnect(ip1, port12, family1) {
        this.#remoteAddress = ip1;
        this.#remotePort = port12;
        this.#remoteFamily = family1 === AF_INET6 ? "IPv6" : "IPv4";
        return 0;
    }
    #doSend(req2, bufs, _count, args, _family) {
        let hasCallback;
        if (args.length === 3) {
            this.#remotePort = args[0];
            this.#remoteAddress = args[1];
            hasCallback = args[2];
        } else {
            hasCallback = args[0];
        }
        const addr = {
            hostname: this.#remoteAddress,
            port: this.#remotePort,
            transport: "udp"
        };
        const payload = new Uint8Array(Buffer2.concat(bufs.map((buf)=>{
            if (typeof buf === "string") {
                return Buffer2.from(buf);
            }
            return Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength);
        })));
        (async ()=>{
            let sent;
            let err = null;
            try {
                sent = await this.#listener.send(payload, addr);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    err = codeMap.get("EBADF");
                } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
                    err = codeMap.get("EMSGSIZE");
                } else {
                    err = codeMap.get("UNKNOWN");
                }
                sent = 0;
            }
            if (hasCallback) {
                try {
                    req2.oncomplete(err, sent);
                } catch  {}
            }
        })();
        return 0;
    }
    async #receive() {
        if (!this.#receiving) {
            return;
        }
        const p3 = new Uint8Array(this.#recvBufferSize);
        let buf1;
        let remoteAddr;
        let nread1;
        try {
            [buf1, remoteAddr] = await this.#listener.receive(p3);
            nread1 = buf1.length;
        } catch (e12) {
            if (e12 instanceof Deno.errors.Interrupted || e12 instanceof Deno.errors.BadResource) {
                nread1 = 0;
            } else {
                nread1 = codeMap.get("UNKNOWN");
            }
            buf1 = new Uint8Array(0);
            remoteAddr = null;
        }
        nread1 ??= 0;
        const rinfo = remoteAddr ? {
            address: remoteAddr.hostname,
            port: remoteAddr.port,
            family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
        } : undefined;
        try {
            this.onmessage(nread1, this, Buffer2.from(buf1), rinfo);
        } catch  {}
        this.#receive();
    }
    _onClose() {
        this.#receiving = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#family = undefined;
        try {
            this.#listener.close();
        } catch  {}
        this.#listener = undefined;
        return 0;
    }
}
const mod45 = {
    SendWrap: SendWrap,
    UDP: UDP
};
const mod46 = {};
const mod47 = {};
const mod48 = {};
const mod49 = {};
const modules = {
    "async_wrap": mod9,
    buffer: mod8,
    "cares_wrap": mod11,
    config: mod10,
    constants: mod1,
    contextify: mod12,
    credentials: mod14,
    crypto: mod13,
    errors: mod15,
    fs: mod16,
    "fs_dir": mod17,
    "fs_event_wrap": mod18,
    "heap_utils": mod19,
    "http_parser": mod20,
    icu: mod21,
    inspector: mod22,
    "js_stream": mod23,
    messaging: mod24,
    "module_wrap": mod25,
    "native_module": mod26,
    natives: mod27,
    options: mod28,
    os: mod29,
    performance: mod32,
    "pipe_wrap": mod31,
    "process_methods": mod33,
    report: mod34,
    serdes: mod35,
    "signal_wrap": mod36,
    "spawn_sync": mod37,
    "stream_wrap": mod30,
    "string_decoder": mod7,
    symbols: mod38,
    "task_queue": mod39,
    "tcp_wrap": mod40,
    timers: mod41,
    "tls_wrap": mod42,
    "trace_events": mod43,
    "tty_wrap": mod44,
    types: mod3,
    "udp_wrap": mod45,
    url: mod46,
    util: mod4,
    uv: mod2,
    v8: mod47,
    worker: mod48,
    zlib: mod49
};
function getBinding(name) {
    const mod = modules[name];
    if (!mod) {
        throw new Error(`No such module: ${name}`);
    }
    return mod;
}
const kInternal = Symbol("internal properties");
const replaceUnderscoresRegex = /_/g;
const leadingDashesRegex = /^--?/;
const trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled"
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex, "");
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex, "-");
                if (leadingDashesRegex.test(key)) {
                    key = key.replace(trailingValuesRegex, "");
                    return this[kInternal].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ]));
        }
        get size() {
            return this[kInternal].array.length;
        }
        values() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const notImplementedEvents = [
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "worker"
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>{
        if (Deno.mainModule.startsWith("file:")) {
            return fromFileUrl2(Deno.mainModule);
        } else {
            return join4(Deno.cwd(), "$deno$node.js");
        }
    }
});
const exit = (code)=>{
    if (code || code === 0) {
        if (typeof code === "string") {
            const parsedCode = parseInt(code);
            process2.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process2.exitCode = code;
        }
    }
    if (!process2._exiting) {
        process2._exiting = true;
        process2.emit("exit", process2.exitCode || 0);
    }
    Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process2, name, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type, code, ctor, detail) {
    assert1(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type || "Warning");
    if (code !== undefined) {
        warningErr.code = code;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process2.emit("warning", warning);
}
function emitWarning(warning, type, code, ctor) {
    let detail;
    if (type !== null && typeof type === "object" && !Array.isArray(type)) {
        ctor = type.ctor;
        code = type.code;
        if (typeof type.detail === "string") {
            detail = type.detail;
        }
        type = type.type || "Warning";
    } else if (typeof type === "function") {
        ctor = type;
        code = undefined;
        type = "Warning";
    }
    if (type !== undefined) {
        validateString(type, "type");
    }
    if (typeof code === "function") {
        ctor = code;
        code = undefined;
    } else if (code !== undefined) {
        validateString(code, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type, code, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process2.noDeprecation) {
            return;
        }
        if (process2.throwDeprecation) {
            return process2.nextTick(()=>{
                throw warning;
            });
        }
    }
    process2.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function kill(pid, sig = "SIGTERM") {
    if (pid != (pid | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid);
    }
    if (typeof sig === "string") {
        try {
            Deno.kill(pid, sig);
        } catch (e) {
            if (e instanceof TypeError) {
                throw new ERR_UNKNOWN_SIGNAL(sig);
            }
            throw e;
        }
    } else {
        throw new ERR_UNKNOWN_SIGNAL(sig.toString());
    }
    return true;
}
function uncaughtExceptionHandler(err, origin) {
    process2.emit("uncaughtExceptionMonitor", err, origin);
    process2.emit("uncaughtException", err, origin);
}
let execPath = null;
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unhandledrejection", (event)=>{
            if (process2.listenerCount("unhandledRejection") === 0) {
                if (process2.listenerCount("uncaughtException") === 0) {
                    throw event.reason;
                }
                event.preventDefault();
                uncaughtExceptionHandler(event.reason, "unhandledRejection");
                return;
            }
            event.preventDefault();
            process2.emit("unhandledRejection", event.reason, event.promise);
        });
        globalThis.addEventListener("error", (event)=>{
            if (process2.listenerCount("uncaughtException") > 0) {
                event.preventDefault();
            }
            uncaughtExceptionHandler(event.error, "uncaughtException");
        });
        globalThis.addEventListener("beforeunload", (e)=>{
            super.emit("beforeExit", process2.exitCode || 0);
            processTicksAndRejections();
            if (core.eventLoopHasMoreWork()) {
                e.preventDefault();
            }
        });
        globalThis.addEventListener("unload", ()=>{
            if (!process2._exiting) {
                process2._exiting = true;
                super.emit("exit", process2.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick1;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else if (event === "SIGTERM" && Deno.build.os === "windows") {} else {
                Deno.addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else if (event === "SIGTERM" && Deno.build.os === "windows") {} else {
                Deno.removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.addSignalListener(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime;
    kill = kill;
    memoryUsage = memoryUsage;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name) {
        return getBinding(name);
    }
    umask() {
        return 0o22;
    }
    getgid() {
        return Deno.gid();
    }
    getuid() {
        return Deno.uid();
    }
    _eval = undefined;
    get execPath() {
        if (execPath) {
            return execPath;
        }
        execPath = Deno.execPath();
        return execPath;
    }
    set execPath(path) {
        execPath = path;
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
}
if (Deno.build.os === "windows") {
    delete Process.prototype.getgid;
    delete Process.prototype.getuid;
}
const process2 = new Process();
Object.defineProperty(process2, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process2.removeListener;
process2.removeAllListeners;
function createSubReducer(fn) {
    return (state, action)=>Me8(state, (s)=>fn(s, action));
}
const initial = {
    blocks: [],
    textified: -1
};
const selector = (state)=>state.log;
const selectBlocks = w5(selector, (state)=>state.blocks);
const selectTextified = w5(selector, (state)=>state.textified);
const refreshTextified = h11("LOG/BLOCK/TEXTIFY/REFRESH")();
const pushBlock = h11("LOG/BLOCK/PUSH")();
const popBlock = h11("LOG/BLOCK/POP")();
const clearBlocks = h11("LOG/BLOCK/CLEAR")();
const reducer = T4(initial, {
    "LOG/BLOCK/TEXTIFY/REFRESH": createSubReducer((state)=>{
        state.textified = state.blocks.length - 1;
    }),
    "LOG/BLOCK/PUSH": createSubReducer((state, action)=>{
        state.blocks.push(action.payload);
    }),
    "LOG/BLOCK/POP": createSubReducer((state, action)=>{
        for(let i = 0; i < action.payload; ++i){
            state.blocks.pop();
        }
    }),
    "LOG/BLOCK/CLEAR": createSubReducer((state)=>{
        state.blocks = [];
        state.textified = -1;
    })
});
const initial1 = {
    slots: {},
    isRehydrating: false,
    isCreating: {},
    isDeleting: {}
};
const selector1 = (state)=>state.slot;
w5(selector1, (state)=>state.active);
const selectSlots = w5(selector1, (state)=>state.slots);
w5(selector1, (state)=>state.isRehydrating);
h11("SLOT/ACTIVE/SET")();
const setSlot = h11("SLOT/SET")();
const delSlot = h11("SLOT/DEL")();
const clearSlot = h11("SLOT/CLEAR")();
const setIsRehydrating = h11("SLOT/IS_REHYDRATING/SET")();
const setIsDeleting = h11("SLOT/IS_DELETING/SET")();
const reducer1 = T4(initial1, {
    "SLOT/ACTIVE/SET": createSubReducer((state, action)=>{
        state.active = action.payload;
    }),
    "SLOT/DEL": createSubReducer((state, action)=>{
        delete state.slots[action.payload];
    }),
    "SLOT/SET": createSubReducer((state, action)=>{
        const slot = action.payload;
        state.slots[slot.name] = slot;
    }),
    "SLOT/CLEAR": createSubReducer((state)=>{
        state.slots = {};
    }),
    "SLOT/IS_REHYDRATING/SET": createSubReducer((state, action)=>{
        state.isRehydrating = action.payload;
    }),
    "SLOT/IS_DELETING/SET": createSubReducer((state, action)=>{
        const [name, value] = action.payload;
        state.isDeleting[name] = value;
    })
});
let inputCallback;
const initial2 = {
    nonce: 0,
    inputs: []
};
let vm;
const selector2 = (state)=>state.vm;
const selectError = w5(selector2, (state)=>state.error);
const selectNonce = w5(selector2, (state)=>state.nonce);
const selectInput = w5(selector2, (state)=>state.inputs[0]);
const setError = h11("VM/ERROR/SET")();
const delError = h11("VM/ERROR/DEL")();
const incNonce = h11("VM/NONCE/INC")();
const pushInput = h11("VM/INPUT/PUSH")();
const shiftInput = h11("VM/INPUT/SHIFT")();
const clearInput = h11("VM/INPUT/CLEAR")();
const reducer2 = T4(initial2, {
    "VM/ERROR/SET": createSubReducer((state, action)=>{
        state.error = action.payload;
    }),
    "VM/ERROR/DEL": createSubReducer((state)=>{
        state.error = undefined;
    }),
    "VM/NONCE/INC": createSubReducer((state)=>{
        state.nonce += 1;
    }),
    "VM/INPUT/PUSH": createSubReducer((state, action)=>{
        state.inputs.push(action.payload);
        if (inputCallback != null) {
            inputCallback();
            inputCallback = undefined;
        }
    }),
    "VM/INPUT/SHIFT": createSubReducer((state)=>{
        state.inputs.shift();
    }),
    "VM/INPUT/CLEAR": createSubReducer((state)=>{
        state.inputs = [];
    })
});
const reducer3 = A8({
    log: reducer,
    slot: reducer1,
    vm: reducer2
});
let composeEnhancers;
if (process2.env.NODE_ENV === "development" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ != null) {
    composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;
} else {
    composeEnhancers = j12;
}
const store = _4(reducer3, composeEnhancers(R10(c2)));
function useDispatch() {
    return Nr();
}
function useSelector(selector) {
    return Ur(selector);
}
function rehydrateSlots() {
    return async (dispatch)=>{
        dispatch(setIsRehydrating(true));
        dispatch(clearSlot());
        for (const key of (await rn.keys())){
            if (!key.startsWith("metadata/")) {
                continue;
            }
            const metadata = await rn.getItem(key);
            dispatch(setSlot(metadata.slot));
        }
        dispatch(setIsRehydrating(false));
    };
}
function createSlot(slot, file) {
    return async (dispatch)=>{
        await rn.setItem("metadata/" + slot.name, {
            slot
        });
        await rn.setItem("files/" + slot.name, file);
        dispatch(setSlot(slot));
    };
}
function removeSlot(name) {
    return async (dispatch)=>{
        dispatch(setIsDeleting([
            name,
            true
        ]));
        await rn.removeItem("metadata/" + name);
        await rn.removeItem("files/" + name);
        dispatch(delSlot(name));
        dispatch(setIsDeleting([
            name,
            false
        ]));
    };
}
function startVM(slot) {
    return async (dispatch, getState)=>{
        dispatch(delError());
        dispatch(clearBlocks());
        const metadata = await rn.getItem("metadata/" + slot);
        if (metadata == null) {
            dispatch(setError(new Error(`Metadata for slot ${slot} does not exist`)));
            return;
        }
        const raw = await rn.getItem("files/" + slot);
        if (raw == null) {
            dispatch(setError(new Error(`File for slot ${slot} does not exist`)));
            return;
        }
        const zip = await Xe.loadAsync(await raw.arrayBuffer());
        const files = await extract(zip);
        vm = compile1(files);
        dispatch(incNonce());
        dispatch(clearInput());
        if (inputCallback != null) {
            inputCallback();
        }
        const storagePrefix = `save/${slot}/`;
        const iterator = vm.start({
            getSavedata: async (key)=>{
                const bytes = await rn.getItem(storagePrefix + key + ".gz");
                if (bytes == null) {
                    return undefined;
                }
                return $l.ungzip(bytes, {
                    to: "string"
                });
            },
            setSavedata: async (key, value)=>{
                await rn.setItem(storagePrefix + key + ".gz", $l.gzip(value));
            },
            getFont: ()=>false,
            getTime: ()=>new Date().valueOf()
        });
        try {
            const nonce = selectNonce(getState());
            let output = await iterator.next(null);
            while(true){
                if (output.done === true || nonce !== selectNonce(getState())) {
                    break;
                }
                switch(output.value.type){
                    case "content":
                        {
                            dispatch(pushBlock(output.value));
                            output = await iterator.next(null);
                            break;
                        }
                    case "line":
                        {
                            dispatch(pushBlock(output.value));
                            output = await iterator.next(null);
                            continue;
                        }
                    case "clear":
                        {
                            dispatch(popBlock(output.value.count));
                            output = await iterator.next(null);
                            continue;
                        }
                    case "input":
                        {
                            const input = selectInput(getState());
                            if (input == null) {
                                await new Promise((res)=>{
                                    inputCallback = res;
                                });
                                continue;
                            }
                            switch(input.type){
                                case "skip":
                                    dispatch(shiftInput());
                                    break;
                                case "pass":
                                    dispatch(shiftInput());
                                    break;
                                case "normal":
                                    {
                                        if (output.value.numeric) {
                                            if (!isNaN(Number(input.value))) {
                                                output = await iterator.next(input.value);
                                            }
                                        } else {
                                            output = await iterator.next(input.value);
                                        }
                                        dispatch(shiftInput());
                                    }
                            }
                            break;
                        }
                    case "tinput":
                        {
                            const input1 = selectInput(getState());
                            if (input1 == null) {
                                await new Promise((res)=>{
                                    inputCallback = res;
                                });
                                continue;
                            }
                            switch(input1.type){
                                case "skip":
                                    dispatch(shiftInput());
                                    break;
                                case "pass":
                                    dispatch(shiftInput());
                                    break;
                                case "normal":
                                    {
                                        dispatch(shiftInput());
                                        if (output.value.numeric) {
                                            if (!isNaN(Number(input1.value))) {
                                                output = await iterator.next(input1.value);
                                            }
                                        } else {
                                            output = await iterator.next(input1.value);
                                        }
                                    }
                            }
                            break;
                        }
                    case "wait":
                        {
                            const input2 = selectInput(getState());
                            if (input2 == null) {
                                await new Promise((res)=>{
                                    inputCallback = res;
                                });
                                continue;
                            }
                            switch(input2.type){
                                case "skip":
                                    {
                                        if (output.value.force) {
                                            dispatch(shiftInput());
                                        }
                                        output = await iterator.next(null);
                                        break;
                                    }
                                case "pass":
                                    {
                                        dispatch(shiftInput());
                                        output = await iterator.next(null);
                                        break;
                                    }
                                case "normal":
                                    {
                                        dispatch(shiftInput());
                                        output = await iterator.next(null);
                                        break;
                                    }
                            }
                            break;
                        }
                }
            }
        } catch (e) {
            dispatch(setError(e));
        }
    };
}
var s3 = Object.defineProperty;
var u4 = (e, t)=>{
    for(var n in t)s3(e, n, {
        get: t[n],
        enumerable: !0
    });
};
var f7 = {};
u4(f7, {
    default: ()=>r1
});
function r1() {
    return r1 = Object.assign ? Object.assign.bind() : function(e) {
        for(var t = 1; t < arguments.length; t++){
            var n = arguments[t];
            for(var a in n)Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
        }
        return e;
    }, r1.apply(this, arguments);
}
var { default: o3 , ...d6 } = f7, i9 = o3 !== void 0 ? o3 : d6;
var d7 = Object.defineProperty;
var l4 = (e, r)=>{
    for(var t in r)d7(e, t, {
        get: r[t],
        enumerable: !0
    });
};
var f8 = {};
l4(f8, {
    default: ()=>i10
});
function i10(e, r) {
    if (e == null) return {};
    var t = {}, u = Object.keys(e), o, n;
    for(n = 0; n < u.length; n++)o = u[n], !(r.indexOf(o) >= 0) && (t[o] = e[o]);
    return t;
}
var { default: a7 , ..._5 } = f8, c3 = a7 !== void 0 ? a7 : _5;
var U9 = Object.create;
var C7 = Object.defineProperty;
var q10 = Object.getOwnPropertyDescriptor;
var A9 = Object.getOwnPropertyNames;
var M9 = Object.getPrototypeOf, z11 = Object.prototype.hasOwnProperty;
var k4 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var B11 = (e, t, r, o)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let u of A9(t))!z11.call(e, u) && u !== r && C7(e, u, {
        get: ()=>t[u],
        enumerable: !(o = q10(t, u)) || o.enumerable
    });
    return e;
};
var H9 = (e, t, r)=>(r = e != null ? U9(M9(e)) : {}, B11(t || !e || !e.__esModule ? C7(r, "default", {
        value: e,
        enumerable: !0
    }) : r, e));
var D7 = k4((n)=>{
    "use strict";
    var y = Symbol.for("react.element"), W = Symbol.for("react.portal"), Y = Symbol.for("react.fragment"), G = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), K = Symbol.for("react.provider"), Q = Symbol.for("react.context"), X = Symbol.for("react.forward_ref"), Z = Symbol.for("react.suspense"), ee = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), w = Symbol.iterator;
    function re(e) {
        return e === null || typeof e != "object" ? null : (e = w && e[w] || e["@@iterator"], typeof e == "function" ? e : null);
    }
    var x = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }, O = Object.assign, j = {};
    function p(e, t, r) {
        this.props = e, this.context = t, this.refs = j, this.updater = r || x;
    }
    p.prototype.isReactComponent = {};
    p.prototype.setState = function(e, t) {
        if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, e, t, "setState");
    };
    p.prototype.forceUpdate = function(e) {
        this.updater.enqueueForceUpdate(this, e, "forceUpdate");
    };
    function I() {}
    I.prototype = p.prototype;
    function v(e, t, r) {
        this.props = e, this.context = t, this.refs = j, this.updater = r || x;
    }
    var S = v.prototype = new I;
    S.constructor = v;
    O(S, p.prototype);
    S.isPureReactComponent = !0;
    var b = Array.isArray, g = Object.prototype.hasOwnProperty, E = {
        current: null
    }, P = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function T(e, t, r) {
        var o, u = {}, c = null, f = null;
        if (t != null) for(o in t.ref !== void 0 && (f = t.ref), t.key !== void 0 && (c = "" + t.key), t)g.call(t, o) && !P.hasOwnProperty(o) && (u[o] = t[o]);
        var i = arguments.length - 2;
        if (i === 1) u.children = r;
        else if (1 < i) {
            for(var s = Array(i), a = 0; a < i; a++)s[a] = arguments[a + 2];
            u.children = s;
        }
        if (e && e.defaultProps) for(o in i = e.defaultProps, i)u[o] === void 0 && (u[o] = i[o]);
        return {
            $$typeof: y,
            type: e,
            key: c,
            ref: f,
            props: u,
            _owner: E.current
        };
    }
    function ne(e, t) {
        return {
            $$typeof: y,
            type: e.type,
            key: t,
            ref: e.ref,
            props: e.props,
            _owner: e._owner
        };
    }
    function R(e) {
        return typeof e == "object" && e !== null && e.$$typeof === y;
    }
    function ue(e) {
        var t = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + e.replace(/[=:]/g, function(r) {
            return t[r];
        });
    }
    var $ = /\/+/g;
    function h(e, t) {
        return typeof e == "object" && e !== null && e.key != null ? ue("" + e.key) : t.toString(36);
    }
    function _(e, t, r, o, u) {
        var c = typeof e;
        (c === "undefined" || c === "boolean") && (e = null);
        var f = !1;
        if (e === null) f = !0;
        else switch(c){
            case "string":
            case "number":
                f = !0;
                break;
            case "object":
                switch(e.$$typeof){
                    case y:
                    case W:
                        f = !0;
                }
        }
        if (f) return f = e, u = u(f), e = o === "" ? "." + h(f, 0) : o, b(u) ? (r = "", e != null && (r = e.replace($, "$&/") + "/"), _(u, t, r, "", function(a) {
            return a;
        })) : u != null && (R(u) && (u = ne(u, r + (!u.key || f && f.key === u.key ? "" : ("" + u.key).replace($, "$&/") + "/") + e)), t.push(u)), 1;
        if (f = 0, o = o === "" ? "." : o + ":", b(e)) for(var i = 0; i < e.length; i++){
            c = e[i];
            var s = o + h(c, i);
            f += _(c, t, r, s, u);
        }
        else if (s = re(e), typeof s == "function") for(e = s.call(e), i = 0; !(c = e.next()).done;)c = c.value, s = o + h(c, i++), f += _(c, t, r, s, u);
        else if (c === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
        return f;
    }
    function d(e, t, r) {
        if (e == null) return e;
        var o = [], u = 0;
        return _(e, o, "", "", function(c) {
            return t.call(r, c, u++);
        }), o;
    }
    function oe(e) {
        if (e._status === -1) {
            var t = e._result;
            t = t(), t.then(function(r) {
                (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r);
            }, function(r) {
                (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r);
            }), e._status === -1 && (e._status = 0, e._result = t);
        }
        if (e._status === 1) return e._result.default;
        throw e._result;
    }
    var l = {
        current: null
    }, m = {
        transition: null
    }, se = {
        ReactCurrentDispatcher: l,
        ReactCurrentBatchConfig: m,
        ReactCurrentOwner: E
    };
    n.Children = {
        map: d,
        forEach: function(e, t, r) {
            d(e, function() {
                t.apply(this, arguments);
            }, r);
        },
        count: function(e) {
            var t = 0;
            return d(e, function() {
                t++;
            }), t;
        },
        toArray: function(e) {
            return d(e, function(t) {
                return t;
            }) || [];
        },
        only: function(e) {
            if (!R(e)) throw Error("React.Children.only expected to receive a single React element child.");
            return e;
        }
    };
    n.Component = p;
    n.Fragment = Y;
    n.Profiler = J;
    n.PureComponent = v;
    n.StrictMode = G;
    n.Suspense = Z;
    n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se;
    n.cloneElement = function(e, t, r) {
        if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
        var o = O({}, e.props), u = e.key, c = e.ref, f = e._owner;
        if (t != null) {
            if (t.ref !== void 0 && (c = t.ref, f = E.current), t.key !== void 0 && (u = "" + t.key), e.type && e.type.defaultProps) var i = e.type.defaultProps;
            for(s in t)g.call(t, s) && !P.hasOwnProperty(s) && (o[s] = t[s] === void 0 && i !== void 0 ? i[s] : t[s]);
        }
        var s = arguments.length - 2;
        if (s === 1) o.children = r;
        else if (1 < s) {
            i = Array(s);
            for(var a = 0; a < s; a++)i[a] = arguments[a + 2];
            o.children = i;
        }
        return {
            $$typeof: y,
            type: e.type,
            key: u,
            ref: c,
            props: o,
            _owner: f
        };
    };
    n.createContext = function(e) {
        return e = {
            $$typeof: Q,
            _currentValue: e,
            _currentValue2: e,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        }, e.Provider = {
            $$typeof: K,
            _context: e
        }, e.Consumer = e;
    };
    n.createElement = T;
    n.createFactory = function(e) {
        var t = T.bind(null, e);
        return t.type = e, t;
    };
    n.createRef = function() {
        return {
            current: null
        };
    };
    n.forwardRef = function(e) {
        return {
            $$typeof: X,
            render: e
        };
    };
    n.isValidElement = R;
    n.lazy = function(e) {
        return {
            $$typeof: te,
            _payload: {
                _status: -1,
                _result: e
            },
            _init: oe
        };
    };
    n.memo = function(e, t) {
        return {
            $$typeof: ee,
            type: e,
            compare: t === void 0 ? null : t
        };
    };
    n.startTransition = function(e) {
        var t = m.transition;
        m.transition = {};
        try {
            e();
        } finally{
            m.transition = t;
        }
    };
    n.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
    };
    n.useCallback = function(e, t) {
        return l.current.useCallback(e, t);
    };
    n.useContext = function(e) {
        return l.current.useContext(e);
    };
    n.useDebugValue = function() {};
    n.useDeferredValue = function(e) {
        return l.current.useDeferredValue(e);
    };
    n.useEffect = function(e, t) {
        return l.current.useEffect(e, t);
    };
    n.useId = function() {
        return l.current.useId();
    };
    n.useImperativeHandle = function(e, t, r) {
        return l.current.useImperativeHandle(e, t, r);
    };
    n.useInsertionEffect = function(e, t) {
        return l.current.useInsertionEffect(e, t);
    };
    n.useLayoutEffect = function(e, t) {
        return l.current.useLayoutEffect(e, t);
    };
    n.useMemo = function(e, t) {
        return l.current.useMemo(e, t);
    };
    n.useReducer = function(e, t, r) {
        return l.current.useReducer(e, t, r);
    };
    n.useRef = function(e) {
        return l.current.useRef(e);
    };
    n.useState = function(e) {
        return l.current.useState(e);
    };
    n.useSyncExternalStore = function(e, t, r) {
        return l.current.useSyncExternalStore(e, t, r);
    };
    n.useTransition = function() {
        return l.current.useTransition();
    };
    n.version = "18.2.0";
});
var L9 = k4((le, V)=>{
    "use strict";
    V.exports = D7();
});
var F7 = H9(L9()), { Children: ae10 , Component: pe12 , Fragment: ye9 , Profiler: de10 , PureComponent: _e10 , StrictMode: me9 , Suspense: he7 , __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ve8 , cloneElement: Se8 , createContext: Ee7 , createElement: Re6 , createFactory: Ce12 , createRef: ke8 , forwardRef: we11 , isValidElement: be7 , lazy: $e7 , memo: xe9 , startTransition: Oe6 , unstable_act: je6 , useCallback: Ie6 , useContext: ge8 , useDebugValue: Pe9 , useDeferredValue: Te7 , useEffect: De6 , useId: Ve2 , useImperativeHandle: Le6 , useInsertionEffect: Ne7 , useLayoutEffect: Fe6 , useMemo: Ue5 , useReducer: qe5 , useRef: Ae6 , useState: Me9 , useSyncExternalStore: ze5 , useTransition: Be3 , version: He3  } = F7, { default: N6 , ...ce8 } = F7, We4 = N6 !== void 0 ? N6 : ce8;
var z12 = Object.create;
var x9 = Object.defineProperty;
var j14 = Object.getOwnPropertyDescriptor;
var A10 = Object.getOwnPropertyNames;
var h12 = Object.getPrototypeOf, L10 = Object.prototype.hasOwnProperty;
var P10 = (e, o)=>()=>(o || e((o = {
            exports: {}
        }).exports, o), o.exports);
var R11 = (e, o, s, M)=>{
    if (o && typeof o == "object" || typeof o == "function") for (let c of A10(o))!L10.call(e, c) && c !== s && x9(e, c, {
        get: ()=>o[c],
        enumerable: !(M = j14(o, c)) || M.enumerable
    });
    return e;
};
var q11 = (e, o, s)=>(s = e != null ? z12(h12(e)) : {}, R11(o || !e || !e.__esModule ? x9(s, "default", {
        value: e,
        enumerable: !0
    }) : s, e));
var v10 = P10((r)=>{
    "use strict";
    var t = typeof Symbol == "function" && Symbol.for, b = t ? Symbol.for("react.element") : 60103, $ = t ? Symbol.for("react.portal") : 60106, f = t ? Symbol.for("react.fragment") : 60107, i = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, l = t ? Symbol.for("react.provider") : 60109, y = t ? Symbol.for("react.context") : 60110, C = t ? Symbol.for("react.async_mode") : 60111, m = t ? Symbol.for("react.concurrent_mode") : 60111, p = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, O = t ? Symbol.for("react.suspense_list") : 60120, a = t ? Symbol.for("react.memo") : 60115, S = t ? Symbol.for("react.lazy") : 60116, V = t ? Symbol.for("react.block") : 60121, k = t ? Symbol.for("react.fundamental") : 60117, N = t ? Symbol.for("react.responder") : 60118, T = t ? Symbol.for("react.scope") : 60119;
    function n(e) {
        if (typeof e == "object" && e !== null) {
            var o = e.$$typeof;
            switch(o){
                case b:
                    switch(e = e.type, e){
                        case C:
                        case m:
                        case f:
                        case u:
                        case i:
                        case d:
                            return e;
                        default:
                            switch(e = e && e.$$typeof, e){
                                case y:
                                case p:
                                case S:
                                case a:
                                case l:
                                    return e;
                                default:
                                    return o;
                            }
                    }
                case $:
                    return o;
            }
        }
    }
    function _(e) {
        return n(e) === m;
    }
    r.AsyncMode = C;
    r.ConcurrentMode = m;
    r.ContextConsumer = y;
    r.ContextProvider = l;
    r.Element = b;
    r.ForwardRef = p;
    r.Fragment = f;
    r.Lazy = S;
    r.Memo = a;
    r.Portal = $;
    r.Profiler = u;
    r.StrictMode = i;
    r.Suspense = d;
    r.isAsyncMode = function(e) {
        return _(e) || n(e) === C;
    };
    r.isConcurrentMode = _;
    r.isContextConsumer = function(e) {
        return n(e) === y;
    };
    r.isContextProvider = function(e) {
        return n(e) === l;
    };
    r.isElement = function(e) {
        return typeof e == "object" && e !== null && e.$$typeof === b;
    };
    r.isForwardRef = function(e) {
        return n(e) === p;
    };
    r.isFragment = function(e) {
        return n(e) === f;
    };
    r.isLazy = function(e) {
        return n(e) === S;
    };
    r.isMemo = function(e) {
        return n(e) === a;
    };
    r.isPortal = function(e) {
        return n(e) === $;
    };
    r.isProfiler = function(e) {
        return n(e) === u;
    };
    r.isStrictMode = function(e) {
        return n(e) === i;
    };
    r.isSuspense = function(e) {
        return n(e) === d;
    };
    r.isValidElementType = function(e) {
        return typeof e == "string" || typeof e == "function" || e === f || e === m || e === u || e === i || e === d || e === O || typeof e == "object" && e !== null && (e.$$typeof === S || e.$$typeof === a || e.$$typeof === l || e.$$typeof === y || e.$$typeof === p || e.$$typeof === k || e.$$typeof === N || e.$$typeof === T || e.$$typeof === V);
    };
    r.typeOf = n;
});
var E6 = P10((H, w)=>{
    "use strict";
    w.exports = v10();
});
var g11 = q11(E6()), { AsyncMode: I10 , ConcurrentMode: J9 , ContextConsumer: K13 , ContextProvider: Q13 , Element: U10 , ForwardRef: W12 , Fragment: X14 , Lazy: Y11 , Memo: Z12 , Portal: ee12 , Profiler: re8 , StrictMode: te9 , Suspense: oe9 , isAsyncMode: ne10 , isConcurrentMode: se8 , isContextConsumer: ce9 , isContextProvider: fe9 , isElement: ie8 , isForwardRef: ue4 , isFragment: le8 , isLazy: ye10 , isMemo: me10 , isPortal: pe13 , isProfiler: de11 , isStrictMode: ae11 , isSuspense: Se9 , isValidElementType: be8 , typeOf: $e8  } = g11, { default: F8 , ...D8 } = g11, Ce13 = F8 !== void 0 ? F8 : D8;
var N7 = Object.create;
var s4 = Object.defineProperty;
var b10 = Object.getOwnPropertyDescriptor;
var j15 = Object.getOwnPropertyNames;
var m7 = Object.getPrototypeOf, w7 = Object.prototype.hasOwnProperty;
((r)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(r, {
        get: (e, t)=>(typeof require < "u" ? require : e)[t]
    }) : r)(function(r) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var n4 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var x10 = (r, e, t, u)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let a of j15(e))!w7.call(r, a) && a !== t && s4(r, a, {
        get: ()=>e[a],
        enumerable: !(u = b10(e, a)) || u.enumerable
    });
    return r;
};
var D9 = (r, e, t)=>(t = r != null ? N7(m7(r)) : {}, x10(e || !r || !r.__esModule ? s4(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r));
var S9 = n4((z, l)=>{
    "use strict";
    var f = Ce13, I = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    }, R = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    }, $ = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    }, P = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    }, y = {};
    y[f.ForwardRef] = $;
    y[f.Memo] = P;
    function T(r) {
        return f.isMemo(r) ? P : y[r.$$typeof] || I;
    }
    var E = Object.defineProperty, F = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, M = Object.getOwnPropertyDescriptor, h = Object.getPrototypeOf, O = Object.prototype;
    function c(r, e, t) {
        if (typeof e != "string") {
            if (O) {
                var u = h(e);
                u && u !== O && c(r, u, t);
            }
            var a = F(e);
            d && (a = a.concat(d(e)));
            for(var v = T(r), i = T(e), o = 0; o < a.length; ++o){
                var p = a[o];
                if (!R[p] && !(t && t[p]) && !(i && i[p]) && !(v && v[p])) {
                    var _ = M(e, p);
                    try {
                        E(r, p, _);
                    } catch  {}
                }
            }
        }
        return r;
    }
    l.exports = c;
});
var W13 = D9(S9()), { default: g12 , ...q12 } = W13, B12 = g12 !== void 0 ? g12 : q12;
var i11 = !0;
function e8(n, o) {
    if (!i11) {
        if (n) return;
        var r = "Warning: " + o;
        typeof console < "u" && console.warn(r);
        try {
            throw Error(r);
        } catch  {}
    }
}
var t1 = e8;
var d8 = Object.create;
var c4 = Object.defineProperty;
var b11 = Object.getOwnPropertyDescriptor;
var P11 = Object.getOwnPropertyNames;
var R12 = Object.getPrototypeOf, g13 = Object.prototype.hasOwnProperty;
var s5 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var v11 = (e, r, t, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let o of P11(r))!g13.call(e, o) && o !== t && c4(e, o, {
        get: ()=>r[o],
        enumerable: !(n = b11(r, o)) || n.enumerable
    });
    return e;
};
var x11 = (e, r, t)=>(t = e != null ? d8(R12(e)) : {}, v11(r || !e || !e.__esModule ? c4(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var i12 = s5((q, p)=>{
    "use strict";
    var E = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    p.exports = E;
});
var l5 = s5((D, f)=>{
    "use strict";
    var S = i12();
    function u() {}
    function y() {}
    y.resetWarningCache = u;
    f.exports = function() {
        function e(n, o, C, I, N, _) {
            if (_ !== S) {
                var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw a.name = "Invariant Violation", a;
            }
        }
        e.isRequired = e;
        function r() {
            return e;
        }
        var t = {
            array: e,
            bigint: e,
            bool: e,
            func: e,
            number: e,
            object: e,
            string: e,
            symbol: e,
            any: e,
            arrayOf: r,
            element: e,
            elementType: e,
            instanceOf: r,
            node: e,
            objectOf: r,
            oneOf: r,
            oneOfType: r,
            shape: r,
            exact: r,
            checkPropTypes: y,
            resetWarningCache: u
        };
        return t.PropTypes = t, t;
    };
});
var h13 = s5((F, m)=>{
    m.exports = l5()();
});
var O14 = x11(h13()), { array: A11 , bigint: L11 , bool: U11 , func: V8 , number: B13 , object: H10 , string: Y12 , symbol: z13 , any: G11 , arrayOf: J10 , element: K14 , elementType: M10 , instanceOf: Q14 , node: X15 , objectOf: Z13 , oneOf: $11 , oneOfType: ee13 , shape: re9 , exact: te10 , checkPropTypes: oe10 , resetWarningCache: ne11 , PropTypes: se9  } = O14, { default: T6 , ...k5 } = O14;
var f9 = Object.create;
var l6 = Object.defineProperty;
var i13 = Object.getOwnPropertyDescriptor;
var n5 = Object.getOwnPropertyNames;
var c5 = Object.getPrototypeOf, o4 = Object.prototype.hasOwnProperty;
var y6 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var g14 = (e, t, u, d)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let r of n5(t))!o4.call(e, r) && r !== u && l6(e, r, {
        get: ()=>t[r],
        enumerable: !(d = i13(t, r)) || d.enumerable
    });
    return e;
};
var p4 = (e, t, u)=>(u = e != null ? f9(c5(e)) : {}, g14(t || !e || !e.__esModule ? l6(u, "default", {
        value: e,
        enumerable: !0
    }) : u, e));
var s6 = y6((a)=>{
    "use strict";
    Object.defineProperty(a, "__esModule", {
        value: !0
    });
    a.default = m;
    function m(e) {
        return e.displayName || e.name || (typeof e == "string" && e.length > 0 ? e : "Unknown");
    }
});
var x12 = p4(s6()), { default: _6 , ...M11 } = x12;
function u5(e, r, t) {
    return r in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function p5() {
    return p5 = Object.assign || function(e) {
        for(var r = 1; r < arguments.length; r++){
            var t = arguments[r];
            for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        }
        return e;
    }, p5.apply(this, arguments);
}
function P12(e, r) {
    e.prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;
}
function h14(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function y7(e) {
    var r = function(t) {
        P12(n, t);
        function n() {
            for(var i, o = arguments.length, c = new Array(o), s = 0; s < o; s++)c[s] = arguments[s];
            return i = t.call.apply(t, [
                this
            ].concat(c)) || this, u5(h14(h14(i)), "cachedTheme", void 0), u5(h14(h14(i)), "lastOuterTheme", void 0), u5(h14(h14(i)), "lastTheme", void 0), u5(h14(h14(i)), "renderProvider", function(T) {
                var f = i.props.children;
                return We4.createElement(e.Provider, {
                    value: i.getTheme(T)
                }, f);
            }), i;
        }
        var a = n.prototype;
        return a.getTheme = function(o) {
            if (this.props.theme !== this.lastTheme || o !== this.lastOuterTheme || !this.cachedTheme) if (this.lastOuterTheme = o, this.lastTheme = this.props.theme, typeof this.lastTheme == "function") {
                var c = this.props.theme;
                this.cachedTheme = c(o);
            } else {
                var s = this.props.theme;
                this.cachedTheme = o ? p5({}, o, s) : s;
            }
            return this.cachedTheme;
        }, a.render = function() {
            var o = this.props.children;
            return o ? We4.createElement(e.Consumer, null, this.renderProvider) : null;
        }, n;
    }(We4.Component);
    return r;
}
function g15(e) {
    return function(t) {
        var n = We4.forwardRef(function(a, i) {
            return We4.createElement(e.Consumer, null, function(o) {
                return We4.createElement(t, p5({
                    theme: o,
                    ref: i
                }, a));
            });
        });
        return B12(n, t), n;
    };
}
function O15(e) {
    var r = function() {
        var n = We4.useContext(e);
        return n;
    };
    return r;
}
function w8(e) {
    return {
        context: e,
        withTheme: g15(e),
        useTheme: O15(e),
        ThemeProvider: y7(e)
    };
}
var E7 = Ee7(), d9 = w8(E7), R13 = d9.withTheme, W14 = d9.ThemeProvider, q13 = d9.useTheme;
var e9 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
    return typeof o;
} : function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
}, t2 = (typeof window > "u" ? "undefined" : e9(window)) === "object" && (typeof document > "u" ? "undefined" : e9(document)) === "object" && document.nodeType === 9, n6 = t2;
var b12 = Object.defineProperty;
var i14 = (f, a)=>{
    for(var e in a)b12(f, e, {
        get: a[e],
        enumerable: !0
    });
};
var n7 = {};
i14(n7, {
    default: ()=>u6
});
function t3(f, a) {
    for(var e = 0; e < a.length; e++){
        var l = a[e];
        l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(f, l.key, l);
    }
}
function u6(f, a, e) {
    return a && t3(f.prototype, a), e && t3(f, e), Object.defineProperty(f, "prototype", {
        writable: !1
    }), f;
}
var { default: _7 , ...m8 } = n7, d10 = _7 !== void 0 ? _7 : m8;
var d11 = Object.defineProperty;
var i15 = (t, e)=>{
    for(var r in e)d11(t, r, {
        get: e[r],
        enumerable: !0
    });
};
var f10 = {};
i15(f10, {
    default: ()=>n8
});
function o5(t, e) {
    return o5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(p, c) {
        return p.__proto__ = c, p;
    }, o5(t, e);
}
function n8(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, o5(t, e);
}
var { default: _8 , ...u7 } = f10, P13 = _8 !== void 0 ? _8 : u7;
var d12 = Object.defineProperty;
var o6 = (e, i)=>{
    for(var n in i)d12(e, n, {
        get: i[n],
        enumerable: !0
    });
};
var t4 = {};
o6(t4, {
    default: ()=>r2
});
function r2(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
var { default: a8 , ...s7 } = t4, f11 = a8 !== void 0 ? a8 : s7;
var te11 = {}.constructor;
function P14(a) {
    if (a == null || typeof a != "object") return a;
    if (Array.isArray(a)) return a.map(P14);
    if (a.constructor !== te11) return a;
    var t = {};
    for(var n in a)t[n] = P14(a[n]);
    return t;
}
function L12(a, t, n) {
    a === void 0 && (a = "unnamed");
    var e = n.jss, r = P14(t), i = e.plugins.onCreateRule(a, r, n);
    return i || (a[0], null);
}
var D10 = function(t, n) {
    for(var e = "", r = 0; r < t.length && t[r] !== "!important"; r++)e && (e += n), e += t[r];
    return e;
}, R14 = function(t, n) {
    if (n === void 0 && (n = !1), !Array.isArray(t)) return t;
    var e = "";
    if (Array.isArray(t[0])) for(var r = 0; r < t.length && t[r] !== "!important"; r++)e && (e += ", "), e += D10(t[r], " ");
    else e = D10(t, ", ");
    return !n && t[t.length - 1] === "!important" && (e += " !important"), e;
};
function y8(a) {
    return a && a.format === !1 ? {
        linebreak: "",
        space: ""
    } : {
        linebreak: `
`,
        space: " "
    };
}
function m9(a, t) {
    for(var n = "", e = 0; e < t; e++)n += "  ";
    return n + a;
}
function k6(a, t, n) {
    n === void 0 && (n = {});
    var e = "";
    if (!t) return e;
    var r = n, i = r.indent, s = i === void 0 ? 0 : i, o = t.fallbacks;
    n.format === !1 && (s = -1 / 0);
    var f = y8(n), u = f.linebreak, l = f.space;
    if (a && s++, o) if (Array.isArray(o)) for(var h = 0; h < o.length; h++){
        var g = o[h];
        for(var d in g){
            var c = g[d];
            c != null && (e && (e += u), e += m9(d + ":" + l + R14(c) + ";", s));
        }
    }
    else for(var v in o){
        var x = o[v];
        x != null && (e && (e += u), e += m9(v + ":" + l + R14(x) + ";", s));
    }
    for(var b in t){
        var M = t[b];
        M != null && b !== "fallbacks" && (e && (e += u), e += m9(b + ":" + l + R14(M) + ";", s));
    }
    return !e && !n.allowEmpty || !a ? e : (s--, e && (e = "" + u + e + u), m9("" + a + l + "{" + e, s) + m9("}", s));
}
var re10 = /([[\].#*$><+~=|^:(),"'`\s])/g, q14 = typeof CSS < "u" && CSS.escape, j16 = function(a) {
    return q14 ? q14(a) : a.replace(re10, "\\$1");
}, H11 = function() {
    function a(n, e, r) {
        this.type = "style", this.isProcessed = !1;
        var i = r.sheet, s = r.Renderer;
        this.key = n, this.options = r, this.style = e, i ? this.renderer = i.renderer : s && (this.renderer = new s);
    }
    var t = a.prototype;
    return t.prop = function(e, r, i) {
        if (r === void 0) return this.style[e];
        var s = i ? i.force : !1;
        if (!s && this.style[e] === r) return this;
        var o = r;
        (!i || i.process !== !1) && (o = this.options.jss.plugins.onChangeValue(r, e, this));
        var f = o == null || o === !1, u = e in this.style;
        if (f && !u && !s) return this;
        var l = f && u;
        if (l ? delete this.style[e] : this.style[e] = o, this.renderable && this.renderer) return l ? this.renderer.removeProperty(this.renderable, e) : this.renderer.setProperty(this.renderable, e, o), this;
        var h = this.options.sheet;
        return h && h.attached, this;
    }, a;
}(), O16 = function(a) {
    P13(t, a);
    function t(e, r, i) {
        var s;
        s = a.call(this, e, r, i) || this;
        var o = i.selector, f = i.scoped, u = i.sheet, l = i.generateId;
        return o ? s.selectorText = o : f !== !1 && (s.id = l(f11(f11(s)), u), s.selectorText = "." + j16(s.id)), s;
    }
    var n = t.prototype;
    return n.applyTo = function(r) {
        var i = this.renderer;
        if (i) {
            var s = this.toJSON();
            for(var o in s)i.setProperty(r, o, s[o]);
        }
        return this;
    }, n.toJSON = function() {
        var r = {};
        for(var i in this.style){
            var s = this.style[i];
            typeof s != "object" ? r[i] = s : Array.isArray(s) && (r[i] = R14(s));
        }
        return r;
    }, n.toString = function(r) {
        var i = this.options.sheet, s = i ? i.options.link : !1, o = s ? i9({}, r, {
            allowEmpty: !0
        }) : r;
        return k6(this.selectorText, this.style, o);
    }, d10(t, [
        {
            key: "selector",
            set: function(r) {
                if (r !== this.selectorText) {
                    this.selectorText = r;
                    var i = this.renderer, s = this.renderable;
                    if (!(!s || !i)) {
                        var o = i.setSelector(s, r);
                        o || i.replaceRule(s, this);
                    }
                }
            },
            get: function() {
                return this.selectorText;
            }
        }
    ]), t;
}(H11), ne12 = {
    onCreateRule: function(t, n, e) {
        return t[0] === "@" || e.parent && e.parent.type === "keyframes" ? null : new O16(t, n, e);
    }
}, w9 = {
    indent: 1,
    children: !0
}, ie9 = /@([\w-]+)/, se10 = function() {
    function a(n, e, r) {
        this.type = "conditional", this.isProcessed = !1, this.key = n;
        var i = n.match(ie9);
        this.at = i ? i[1] : "unknown", this.query = r.name || "@" + this.at, this.options = r, this.rules = new A12(i9({}, r, {
            parent: this
        }));
        for(var s in e)this.rules.add(s, e[s]);
        this.rules.process();
    }
    var t = a.prototype;
    return t.getRule = function(e) {
        return this.rules.get(e);
    }, t.indexOf = function(e) {
        return this.rules.indexOf(e);
    }, t.addRule = function(e, r, i) {
        var s = this.rules.add(e, r, i);
        return s ? (this.options.jss.plugins.onProcessRule(s), s) : null;
    }, t.toString = function(e) {
        e === void 0 && (e = w9);
        var r = y8(e), i = r.linebreak;
        if (e.indent == null && (e.indent = w9.indent), e.children == null && (e.children = w9.children), e.children === !1) return this.query + " {}";
        var s = this.rules.toString(e);
        return s ? this.query + " {" + i + s + i + "}" : "";
    }, a;
}(), ae12 = /@media|@supports\s+/, oe11 = {
    onCreateRule: function(t, n, e) {
        return ae12.test(t) ? new se10(t, n, e) : null;
    }
}, C8 = {
    indent: 1,
    children: !0
}, ue5 = /@keyframes\s+([\w-]+)/, I11 = function() {
    function a(n, e, r) {
        this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1;
        var i = n.match(ue5);
        i && i[1] ? this.name = i[1] : this.name = "noname", this.key = this.type + "-" + this.name, this.options = r;
        var s = r.scoped, o = r.sheet, f = r.generateId;
        this.id = s === !1 ? this.name : j16(f(this, o)), this.rules = new A12(i9({}, r, {
            parent: this
        }));
        for(var u in e)this.rules.add(u, e[u], i9({}, r, {
            parent: this
        }));
        this.rules.process();
    }
    var t = a.prototype;
    return t.toString = function(e) {
        e === void 0 && (e = C8);
        var r = y8(e), i = r.linebreak;
        if (e.indent == null && (e.indent = C8.indent), e.children == null && (e.children = C8.children), e.children === !1) return this.at + " " + this.id + " {}";
        var s = this.rules.toString(e);
        return s && (s = "" + i + s + i), this.at + " " + this.id + " {" + s + "}";
    }, a;
}(), fe10 = /@keyframes\s+/, le9 = /\$([\w-]+)/g, E8 = function(t, n) {
    return typeof t == "string" ? t.replace(le9, function(e, r) {
        return r in n ? n[r] : e;
    }) : t;
}, $12 = function(t, n, e) {
    var r = t[n], i = E8(r, e);
    i !== r && (t[n] = i);
}, he8 = {
    onCreateRule: function(t, n, e) {
        return typeof t == "string" && fe10.test(t) ? new I11(t, n, e) : null;
    },
    onProcessStyle: function(t, n, e) {
        return n.type !== "style" || !e || ("animation-name" in t && $12(t, "animation-name", e.keyframes), "animation" in t && $12(t, "animation", e.keyframes)), t;
    },
    onChangeValue: function(t, n, e) {
        var r = e.options.sheet;
        if (!r) return t;
        switch(n){
            case "animation":
                return E8(t, r.keyframes);
            case "animation-name":
                return E8(t, r.keyframes);
            default:
                return t;
        }
    }
}, de12 = function(a) {
    P13(t, a);
    function t() {
        return a.apply(this, arguments) || this;
    }
    var n = t.prototype;
    return n.toString = function(r) {
        var i = this.options.sheet, s = i ? i.options.link : !1, o = s ? i9({}, r, {
            allowEmpty: !0
        }) : r;
        return k6(this.key, this.style, o);
    }, t;
}(H11), ce10 = {
    onCreateRule: function(t, n, e) {
        return e.parent && e.parent.type === "keyframes" ? new de12(t, n, e) : null;
    }
}, pe14 = function() {
    function a(n, e, r) {
        this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = n, this.style = e, this.options = r;
    }
    var t = a.prototype;
    return t.toString = function(e) {
        var r = y8(e), i = r.linebreak;
        if (Array.isArray(this.style)) {
            for(var s = "", o = 0; o < this.style.length; o++)s += k6(this.at, this.style[o]), this.style[o + 1] && (s += i);
            return s;
        }
        return k6(this.at, this.style, e);
    }, a;
}(), ve9 = /@font-face/, ge9 = {
    onCreateRule: function(t, n, e) {
        return ve9.test(t) ? new pe14(t, n, e) : null;
    }
}, ye11 = function() {
    function a(n, e, r) {
        this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = n, this.style = e, this.options = r;
    }
    var t = a.prototype;
    return t.toString = function(e) {
        return k6(this.key, this.style, e);
    }, a;
}(), me11 = {
    onCreateRule: function(t, n, e) {
        return t === "@viewport" || t === "@-ms-viewport" ? new ye11(t, n, e) : null;
    }
}, Re7 = function() {
    function a(n, e, r) {
        this.type = "simple", this.isProcessed = !1, this.key = n, this.value = e, this.options = r;
    }
    var t = a.prototype;
    return t.toString = function(e) {
        if (Array.isArray(this.value)) {
            for(var r = "", i = 0; i < this.value.length; i++)r += this.key + " " + this.value[i] + ";", this.value[i + 1] && (r += `
`);
            return r;
        }
        return this.key + " " + this.value + ";";
    }, a;
}(), Se10 = {
    "@charset": !0,
    "@import": !0,
    "@namespace": !0
}, ke9 = {
    onCreateRule: function(t, n, e) {
        return t in Se10 ? new Re7(t, n, e) : null;
    }
}, U12 = [
    ne12,
    oe11,
    he8,
    ce10,
    ge9,
    me11,
    ke9
], xe10 = {
    process: !0
}, K15 = {
    force: !0,
    process: !0
}, A12 = function() {
    function a(n) {
        this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = n, this.classes = n.classes, this.keyframes = n.keyframes;
    }
    var t = a.prototype;
    return t.add = function(e, r, i) {
        var s = this.options, o = s.parent, f = s.sheet, u = s.jss, l = s.Renderer, h = s.generateId, g = s.scoped, d = i9({
            classes: this.classes,
            parent: o,
            sheet: f,
            jss: u,
            Renderer: l,
            generateId: h,
            scoped: g,
            name: e,
            keyframes: this.keyframes,
            selector: void 0
        }, i), c = e;
        e in this.raw && (c = e + "-d" + this.counter++), this.raw[c] = r, c in this.classes && (d.selector = "." + j16(this.classes[c]));
        var v = L12(c, r, d);
        if (!v) return null;
        this.register(v);
        var x = d.index === void 0 ? this.index.length : d.index;
        return this.index.splice(x, 0, v), v;
    }, t.get = function(e) {
        return this.map[e];
    }, t.remove = function(e) {
        this.unregister(e), delete this.raw[e.key], this.index.splice(this.index.indexOf(e), 1);
    }, t.indexOf = function(e) {
        return this.index.indexOf(e);
    }, t.process = function() {
        var e = this.options.jss.plugins;
        this.index.slice(0).forEach(e.onProcessRule, e);
    }, t.register = function(e) {
        this.map[e.key] = e, e instanceof O16 ? (this.map[e.selector] = e, e.id && (this.classes[e.key] = e.id)) : e instanceof I11 && this.keyframes && (this.keyframes[e.name] = e.id);
    }, t.unregister = function(e) {
        delete this.map[e.key], e instanceof O16 ? (delete this.map[e.selector], delete this.classes[e.key]) : e instanceof I11 && delete this.keyframes[e.name];
    }, t.update = function() {
        var e, r, i;
        if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (e = arguments.length <= 0 ? void 0 : arguments[0], r = arguments.length <= 1 ? void 0 : arguments[1], i = arguments.length <= 2 ? void 0 : arguments[2]) : (r = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], e = null), e) this.updateOne(this.map[e], r, i);
        else for(var s = 0; s < this.index.length; s++)this.updateOne(this.index[s], r, i);
    }, t.updateOne = function(e, r, i) {
        i === void 0 && (i = xe10);
        var s = this.options, o = s.jss.plugins, f = s.sheet;
        if (e.rules instanceof a) {
            e.rules.update(r, i);
            return;
        }
        var u = e.style;
        if (o.onUpdate(r, e, f, i), i.process && u && u !== e.style) {
            o.onProcessStyle(e.style, e, f);
            for(var l in e.style){
                var h = e.style[l], g = u[l];
                h !== g && e.prop(l, h, K15);
            }
            for(var d in u){
                var c = e.style[d], v = u[d];
                c == null && c !== v && e.prop(d, null, K15);
            }
        }
    }, t.toString = function(e) {
        for(var r = "", i = this.options.sheet, s = i ? i.options.link : !1, o = y8(e), f = o.linebreak, u = 0; u < this.index.length; u++){
            var l = this.index[u], h = l.toString(e);
            !h && !s || (r && (r += f), r += h);
        }
        return r;
    }, a;
}(), Y13 = function() {
    function a(n, e) {
        this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = i9({}, e, {
            sheet: this,
            parent: this,
            classes: this.classes,
            keyframes: this.keyframes
        }), e.Renderer && (this.renderer = new e.Renderer(this)), this.rules = new A12(this.options);
        for(var r in n)this.rules.add(r, n[r]);
        this.rules.process();
    }
    var t = a.prototype;
    return t.attach = function() {
        return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this);
    }, t.detach = function() {
        return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this;
    }, t.addRule = function(e, r, i) {
        var s = this.queue;
        this.attached && !s && (this.queue = []);
        var o = this.rules.add(e, r, i);
        return o ? (this.options.jss.plugins.onProcessRule(o), this.attached ? (this.deployed && (s ? s.push(o) : (this.insertRule(o), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), o) : (this.deployed = !1, o)) : null;
    }, t.insertRule = function(e) {
        this.renderer && this.renderer.insertRule(e);
    }, t.addRules = function(e, r) {
        var i = [];
        for(var s in e){
            var o = this.addRule(s, e[s], r);
            o && i.push(o);
        }
        return i;
    }, t.getRule = function(e) {
        return this.rules.get(e);
    }, t.deleteRule = function(e) {
        var r = typeof e == "object" ? e : this.rules.get(e);
        return !r || this.attached && !r.renderable ? !1 : (this.rules.remove(r), this.attached && r.renderable && this.renderer ? this.renderer.deleteRule(r.renderable) : !0);
    }, t.indexOf = function(e) {
        return this.rules.indexOf(e);
    }, t.deploy = function() {
        return this.renderer && this.renderer.deploy(), this.deployed = !0, this;
    }, t.update = function() {
        var e;
        return (e = this.rules).update.apply(e, arguments), this;
    }, t.updateOne = function(e, r, i) {
        return this.rules.updateOne(e, r, i), this;
    }, t.toString = function(e) {
        return this.rules.toString(e);
    }, a;
}(), be9 = function() {
    function a() {
        this.plugins = {
            internal: [],
            external: []
        }, this.registry = {};
    }
    var t = a.prototype;
    return t.onCreateRule = function(e, r, i) {
        for(var s = 0; s < this.registry.onCreateRule.length; s++){
            var o = this.registry.onCreateRule[s](e, r, i);
            if (o) return o;
        }
        return null;
    }, t.onProcessRule = function(e) {
        if (!e.isProcessed) {
            for(var r = e.options.sheet, i = 0; i < this.registry.onProcessRule.length; i++)this.registry.onProcessRule[i](e, r);
            e.style && this.onProcessStyle(e.style, e, r), e.isProcessed = !0;
        }
    }, t.onProcessStyle = function(e, r, i) {
        for(var s = 0; s < this.registry.onProcessStyle.length; s++)r.style = this.registry.onProcessStyle[s](r.style, r, i);
    }, t.onProcessSheet = function(e) {
        for(var r = 0; r < this.registry.onProcessSheet.length; r++)this.registry.onProcessSheet[r](e);
    }, t.onUpdate = function(e, r, i, s) {
        for(var o = 0; o < this.registry.onUpdate.length; o++)this.registry.onUpdate[o](e, r, i, s);
    }, t.onChangeValue = function(e, r, i) {
        for(var s = e, o = 0; o < this.registry.onChangeValue.length; o++)s = this.registry.onChangeValue[o](s, r, i);
        return s;
    }, t.use = function(e, r) {
        r === void 0 && (r = {
            queue: "external"
        });
        var i = this.plugins[r.queue];
        i.indexOf(e) === -1 && (i.push(e), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(s, o) {
            for(var f in o)f in s && s[f].push(o[f]);
            return s;
        }, {
            onCreateRule: [],
            onProcessRule: [],
            onProcessStyle: [],
            onProcessSheet: [],
            onChangeValue: [],
            onUpdate: []
        }));
    }, a;
}(), we12 = function() {
    function a() {
        this.registry = [];
    }
    var t = a.prototype;
    return t.add = function(e) {
        var r = this.registry, i = e.options.index;
        if (r.indexOf(e) === -1) {
            if (r.length === 0 || i >= this.index) {
                r.push(e);
                return;
            }
            for(var s = 0; s < r.length; s++)if (r[s].options.index > i) {
                r.splice(s, 0, e);
                return;
            }
        }
    }, t.reset = function() {
        this.registry = [];
    }, t.remove = function(e) {
        var r = this.registry.indexOf(e);
        this.registry.splice(r, 1);
    }, t.toString = function(e) {
        for(var r = e === void 0 ? {} : e, i = r.attached, s = c3(r, [
            "attached"
        ]), o = y8(s), f = o.linebreak, u = "", l = 0; l < this.registry.length; l++){
            var h = this.registry[l];
            i != null && h.attached !== i || (u && (u += f), u += h.toString(s));
        }
        return u;
    }, d10(a, [
        {
            key: "index",
            get: function() {
                return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
            }
        }
    ]), a;
}(), S10 = new we12, N8 = typeof globalThis < "u" ? globalThis : typeof document < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), _9 = "2f1acc6c3a606b082e5eef5e54414ffb";
N8[_9] == null && (N8[_9] = 0);
var W15 = N8[_9]++, Ce14 = 1e10, G12 = function(t) {
    t === void 0 && (t = {});
    var n = 0, e = function(i, s) {
        n += 1, n > Ce14;
        var o = "", f = "";
        return s && (s.options.classNamePrefix && (f = s.options.classNamePrefix), s.options.jss.id != null && (o = String(s.options.jss.id))), t.minify ? "" + (f || "c") + W15 + o + n : f + i.key + "-" + W15 + (o ? "-" + o : "") + "-" + n;
    };
    return e;
}, Q15 = function(t) {
    var n;
    return function() {
        return n || (n = t()), n;
    };
}, Pe10 = function(t, n) {
    try {
        return t.attributeStyleMap ? t.attributeStyleMap.get(n) : t.style.getPropertyValue(n);
    } catch  {
        return "";
    }
}, Oe7 = function(t, n, e) {
    try {
        var r = e;
        if (Array.isArray(e) && (r = R14(e, !0), e[e.length - 1] === "!important")) return t.style.setProperty(n, r, "important"), !0;
        t.attributeStyleMap ? t.attributeStyleMap.set(n, r) : t.style.setProperty(n, r);
    } catch  {
        return !1;
    }
    return !0;
}, Ie7 = function(t, n) {
    try {
        t.attributeStyleMap ? t.attributeStyleMap.delete(n) : t.style.removeProperty(n);
    } catch  {}
}, Ee8 = function(t, n) {
    return t.selectorText = n, t.selectorText === n;
}, X16 = Q15(function() {
    return document.querySelector("head");
});
function Ne8(a, t) {
    for(var n = 0; n < a.length; n++){
        var e = a[n];
        if (e.attached && e.options.index > t.index && e.options.insertionPoint === t.insertionPoint) return e;
    }
    return null;
}
function _e11(a, t) {
    for(var n = a.length - 1; n >= 0; n--){
        var e = a[n];
        if (e.attached && e.options.insertionPoint === t.insertionPoint) return e;
    }
    return null;
}
function Ve3(a) {
    for(var t = X16(), n = 0; n < t.childNodes.length; n++){
        var e = t.childNodes[n];
        if (e.nodeType === 8 && e.nodeValue.trim() === a) return e;
    }
    return null;
}
function je7(a) {
    var t = S10.registry;
    if (t.length > 0) {
        var n = Ne8(t, a);
        if (n && n.renderer) return {
            parent: n.renderer.element.parentNode,
            node: n.renderer.element
        };
        if (n = _e11(t, a), n && n.renderer) return {
            parent: n.renderer.element.parentNode,
            node: n.renderer.element.nextSibling
        };
    }
    var e = a.insertionPoint;
    if (e && typeof e == "string") {
        var r = Ve3(e);
        if (r) return {
            parent: r.parentNode,
            node: r.nextSibling
        };
    }
    return !1;
}
function Ae7(a, t) {
    var n = t.insertionPoint, e = je7(t);
    if (e !== !1 && e.parent) {
        e.parent.insertBefore(a, e.node);
        return;
    }
    if (n && typeof n.nodeType == "number") {
        var r = n, i = r.parentNode;
        i && i.insertBefore(a, r.nextSibling);
        return;
    }
    X16().appendChild(a);
}
var Me10 = Q15(function() {
    var a = document.querySelector('meta[property="csp-nonce"]');
    return a ? a.getAttribute("content") : null;
}), F9 = function(t, n, e) {
    try {
        "insertRule" in t ? t.insertRule(n, e) : "appendRule" in t && t.appendRule(n);
    } catch  {
        return !1;
    }
    return t.cssRules[e];
}, B14 = function(t, n) {
    var e = t.cssRules.length;
    return n === void 0 || n > e ? e : n;
}, Te8 = function() {
    var t = document.createElement("style");
    return t.textContent = `
`, t;
}, Je2 = function() {
    function a(n) {
        this.getPropertyValue = Pe10, this.setProperty = Oe7, this.removeProperty = Ie7, this.setSelector = Ee8, this.hasInsertedRules = !1, this.cssRules = [], n && S10.add(n), this.sheet = n;
        var e = this.sheet ? this.sheet.options : {}, r = e.media, i = e.meta, s = e.element;
        this.element = s || Te8(), this.element.setAttribute("data-jss", ""), r && this.element.setAttribute("media", r), i && this.element.setAttribute("data-meta", i);
        var o = Me10();
        o && this.element.setAttribute("nonce", o);
    }
    var t = a.prototype;
    return t.attach = function() {
        if (!(this.element.parentNode || !this.sheet)) {
            Ae7(this.element, this.sheet.options);
            var e = Boolean(this.sheet && this.sheet.deployed);
            this.hasInsertedRules && e && (this.hasInsertedRules = !1, this.deploy());
        }
    }, t.detach = function() {
        if (!!this.sheet) {
            var e = this.element.parentNode;
            e && e.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`);
        }
    }, t.deploy = function() {
        var e = this.sheet;
        if (!!e) {
            if (e.options.link) {
                this.insertRules(e.rules);
                return;
            }
            this.element.textContent = `
` + e.toString() + `
`;
        }
    }, t.insertRules = function(e, r) {
        for(var i = 0; i < e.index.length; i++)this.insertRule(e.index[i], i, r);
    }, t.insertRule = function(e, r, i) {
        if (i === void 0 && (i = this.element.sheet), e.rules) {
            var s = e, o = i;
            if (e.type === "conditional" || e.type === "keyframes") {
                var f = B14(i, r);
                if (o = F9(i, s.toString({
                    children: !1
                }), f), o === !1) return !1;
                this.refCssRule(e, f, o);
            }
            return this.insertRules(s.rules, o), o;
        }
        var u = e.toString();
        if (!u) return !1;
        var l = B14(i, r), h = F9(i, u, l);
        return h === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(e, l, h), h);
    }, t.refCssRule = function(e, r, i) {
        e.renderable = i, e.options.parent instanceof Y13 && (this.cssRules[r] = i);
    }, t.deleteRule = function(e) {
        var r = this.element.sheet, i = this.indexOf(e);
        return i === -1 ? !1 : (r.deleteRule(i), this.cssRules.splice(i, 1), !0);
    }, t.indexOf = function(e) {
        return this.cssRules.indexOf(e);
    }, t.replaceRule = function(e, r) {
        var i = this.indexOf(e);
        return i === -1 ? !1 : (this.element.sheet.deleteRule(i), this.cssRules.splice(i, 1), this.insertRule(r, i));
    }, t.getRules = function() {
        return this.element.sheet.cssRules;
    }, a;
}(), De7 = 0, qe6 = function() {
    function a(n) {
        this.id = De7++, this.version = "10.8.0", this.plugins = new be9, this.options = {
            id: {
                minify: !1
            },
            createGenerateId: G12,
            Renderer: n6 ? Je2 : null,
            plugins: []
        }, this.generateId = G12({
            minify: !1
        });
        for(var e = 0; e < U12.length; e++)this.plugins.use(U12[e], {
            queue: "internal"
        });
        this.setup(n);
    }
    var t = a.prototype;
    return t.setup = function(e) {
        return e === void 0 && (e = {}), e.createGenerateId && (this.options.createGenerateId = e.createGenerateId), e.id && (this.options.id = i9({}, this.options.id, e.id)), (e.createGenerateId || e.id) && (this.generateId = this.options.createGenerateId(this.options.id)), e.insertionPoint != null && (this.options.insertionPoint = e.insertionPoint), "Renderer" in e && (this.options.Renderer = e.Renderer), e.plugins && this.use.apply(this, e.plugins), this;
    }, t.createStyleSheet = function(e, r) {
        r === void 0 && (r = {});
        var i = r, s = i.index;
        typeof s != "number" && (s = S10.index === 0 ? 0 : S10.index + 1);
        var o = new Y13(e, i9({}, r, {
            jss: this,
            generateId: r.generateId || this.generateId,
            insertionPoint: this.options.insertionPoint,
            Renderer: this.options.Renderer,
            index: s
        }));
        return this.plugins.onProcessSheet(o), o;
    }, t.removeStyleSheet = function(e) {
        return e.detach(), S10.remove(e), this;
    }, t.createRule = function(e, r, i) {
        if (r === void 0 && (r = {}), i === void 0 && (i = {}), typeof e == "object") return this.createRule(void 0, e, r);
        var s = i9({}, i, {
            name: e,
            jss: this,
            Renderer: this.options.Renderer
        });
        s.generateId || (s.generateId = this.generateId), s.classes || (s.classes = {}), s.keyframes || (s.keyframes = {});
        var o = L12(e, r, s);
        return o && this.plugins.onProcessRule(o), o;
    }, t.use = function() {
        for(var e = this, r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s];
        return i.forEach(function(o) {
            e.plugins.use(o);
        }), this;
    }, a;
}(), $e9 = function(t) {
    return new qe6(t);
}, Ye6 = function() {
    function a() {
        this.length = 0, this.sheets = new WeakMap;
    }
    var t = a.prototype;
    return t.get = function(e) {
        var r = this.sheets.get(e);
        return r && r.sheet;
    }, t.add = function(e, r) {
        this.sheets.has(e) || (this.length++, this.sheets.set(e, {
            sheet: r,
            refs: 0
        }));
    }, t.manage = function(e) {
        var r = this.sheets.get(e);
        if (r) return r.refs === 0 && r.sheet.attach(), r.refs++, r.sheet;
        t1(!1, "[JSS] SheetsManager: can't find sheet to manage");
    }, t.unmanage = function(e) {
        var r = this.sheets.get(e);
        r ? r.refs > 0 && (r.refs--, r.refs === 0 && r.sheet.detach()) : t1(!1, "SheetsManager: can't find sheet to unmanage");
    }, d10(a, [
        {
            key: "size",
            get: function() {
                return this.length;
            }
        }
    ]), a;
}(), Qe1 = typeof CSS == "object" && CSS != null && "number" in CSS;
function Ue6(a) {
    var t = null;
    for(var n in a){
        var e = a[n], r = typeof e;
        if (r === "function") t || (t = {}), t[n] = e;
        else if (r === "object" && e !== null && !Array.isArray(e)) {
            var i = Ue6(e);
            i && (t || (t = {}), t[n] = i);
        }
    }
    return t;
}
$e9();
var c6 = Date.now(), f12 = "fnValues" + c6, i16 = "fnStyle" + ++c6, p6 = function() {
    return {
        onCreateRule: function(n, e, t) {
            if (typeof e != "function") return null;
            var r = L12(n, {}, t);
            return r[i16] = e, r;
        },
        onProcessStyle: function(n, e) {
            if (f12 in e || i16 in e) return n;
            var t = {};
            for(var r in n){
                var o = n[r];
                typeof o == "function" && (delete n[r], t[r] = o);
            }
            return e[f12] = t, n;
        },
        onUpdate: function(n, e, t, r) {
            var o = e, l = o[i16];
            if (l && (o.style = l(n) || {}, !1)) for(var R in o.style);
            var u = o[f12];
            if (u) for(var s in u)o.prop(s, u[s](n), r);
        }
    };
}, m10 = p6;
var __global$3 = globalThis || (typeof window !== "undefined" ? window : self);
function f13(r) {
    var l, o = r.Symbol;
    return typeof o == "function" ? o.observable ? l = o.observable : (l = o("observable"), o.observable = l) : l = "@@observable", l;
}
var e10;
typeof self < "u" ? e10 = self : typeof document < "u" ? e10 = window : typeof __global$3 < "u" ? e10 = __global$3 : typeof module < "u" ? e10 = module : e10 = Function("return this")();
var n9 = f13(e10), s8 = n9;
var b13 = function(e) {
    return e && e[s8] && e === e[s8]();
}, m11 = function(e) {
    return {
        onCreateRule: function(r, n, t) {
            if (!b13(n)) return null;
            var i = n, o = L12(r, {}, t);
            return i.subscribe(function(u) {
                for(var l in u)o.prop(l, u[l], e);
            }), o;
        },
        onProcessRule: function(r) {
            if (!(r && r.type !== "style")) {
                var n = r, t = n.style, i = function(s) {
                    var a = t[s];
                    if (!b13(a)) return "continue";
                    delete t[s], a.subscribe({
                        next: function(R) {
                            n.prop(s, R, e);
                        }
                    });
                };
                for(var o in t)i(o);
            }
        }
    };
}, g16 = m11;
var u8 = /;\n/, v12 = function(r) {
    for(var e = {}, i = r.split(u8), s = 0; s < i.length; s++){
        var t = (i[s] || "").trim();
        if (!!t) {
            var n = t.indexOf(":");
            if (n !== -1) {
                var o = t.substr(0, n).trim(), f = t.substr(n + 1).trim();
                e[o] = f;
            }
        }
    }
    return e;
}, l7 = function(r) {
    typeof r.style == "string" && (r.style = v12(r.style));
};
function p7() {
    return {
        onProcessRule: l7
    };
}
var g17 = p7;
var i17 = "@global", a9 = "@global ", c7 = function() {
    function l(r, t, e) {
        this.type = "global", this.at = i17, this.isProcessed = !1, this.key = r, this.options = e, this.rules = new A12(i9({}, e, {
            parent: this
        }));
        for(var n in t)this.rules.add(n, t[n]);
        this.rules.process();
    }
    var s = l.prototype;
    return s.getRule = function(t) {
        return this.rules.get(t);
    }, s.addRule = function(t, e, n) {
        var u = this.rules.add(t, e, n);
        return u && this.options.jss.plugins.onProcessRule(u), u;
    }, s.indexOf = function(t) {
        return this.rules.indexOf(t);
    }, s.toString = function() {
        return this.rules.toString();
    }, l;
}(), h15 = function() {
    function l(r, t, e) {
        this.type = "global", this.at = i17, this.isProcessed = !1, this.key = r, this.options = e;
        var n = r.substr(a9.length);
        this.rule = e.jss.createRule(n, t, i9({}, e, {
            parent: this
        }));
    }
    var s = l.prototype;
    return s.toString = function(t) {
        return this.rule ? this.rule.toString(t) : "";
    }, l;
}(), g18 = /\s*,\s*/g;
function f14(l, s) {
    for(var r = l.split(g18), t = "", e = 0; e < r.length; e++)t += s + " " + r[e].trim(), r[e + 1] && (t += ", ");
    return t;
}
function p8(l, s) {
    var r = l.options, t = l.style, e = t ? t[i17] : null;
    if (!!e) {
        for(var n in e)s.addRule(n, e[n], i9({}, r, {
            selector: f14(n, l.selector)
        }));
        delete t[i17];
    }
}
function v13(l, s) {
    var r = l.options, t = l.style;
    for(var e in t)if (!(e[0] !== "@" || e.substr(0, i17.length) !== i17)) {
        var n = f14(e.substr(i17.length), l.selector);
        s.addRule(n, t[e], i9({}, r, {
            selector: n
        })), delete t[e];
    }
}
function R15() {
    function l(r, t, e) {
        if (!r) return null;
        if (r === i17) return new c7(r, t, e);
        if (r[0] === "@" && r.substr(0, a9.length) === a9) return new h15(r, t, e);
        var n = e.parent;
        return n && (n.type === "global" || n.options.parent && n.options.parent.type === "global") && (e.scoped = !1), e.scoped === !1 && (e.selector = r), null;
    }
    function s(r, t) {
        r.type !== "style" || !t || (p8(r, t), v13(r, t));
    }
    return {
        onCreateRule: l,
        onProcessRule: s
    };
}
var x13 = R15;
var c8 = function(t) {
    return t && typeof t == "object" && !Array.isArray(t);
}, e13 = "extendCurrValue" + Date.now();
function V9(n, t, r, i) {
    var f = typeof n.extend;
    if (f === "string") {
        if (!r) return;
        var a = r.getRule(n.extend);
        if (!a || a === t) return;
        var u = a.options.parent;
        if (u) {
            var g = u.rules.raw[n.extend];
            d13(g, t, r, i);
        }
        return;
    }
    if (Array.isArray(n.extend)) {
        for(var x = 0; x < n.extend.length; x++){
            var v = n.extend[x], m = typeof v == "string" ? i9({}, n, {
                extend: v
            }) : n.extend[x];
            d13(m, t, r, i);
        }
        return;
    }
    for(var o in n.extend){
        if (o === "extend") {
            d13(n.extend.extend, t, r, i);
            continue;
        }
        if (c8(n.extend[o])) {
            o in i || (i[o] = {}), d13(n.extend[o], t, r, i[o]);
            continue;
        }
        i[o] = n.extend[o];
    }
}
function j17(n, t, r, i) {
    for(var f in n)if (f !== "extend") {
        if (c8(i[f]) && c8(n[f])) {
            d13(n[f], t, r, i[f]);
            continue;
        }
        if (c8(n[f])) {
            i[f] = d13(n[f], t, r);
            continue;
        }
        i[f] = n[f];
    }
}
function d13(n, t, r, i) {
    return i === void 0 && (i = {}), V9(n, t, r, i), j17(n, t, r, i), i;
}
function C9() {
    function n(r, i, f) {
        return "extend" in r ? d13(r, i, f) : r;
    }
    function t(r, i, f) {
        if (i !== "extend") return r;
        if (r == null || r === !1) {
            for(var a in f[e13])f.prop(a, null);
            return f[e13] = null, null;
        }
        if (typeof r == "object") {
            for(var u in r)f.prop(u, r[u]);
            f[e13] = r;
        }
        return null;
    }
    return {
        onProcessStyle: n,
        onChangeValue: t
    };
}
var b14 = C9;
var s9 = /\s*,\s*/g, p9 = /&/g, m12 = /\$([\w-]+)/g;
function S11() {
    function d(r, a) {
        return function(i, e) {
            var n = r.getRule(e) || a && a.getRule(e);
            return n ? n.selector : e;
        };
    }
    function g(r, a) {
        for(var i = a.split(s9), e = r.split(s9), n = "", o = 0; o < i.length; o++)for(var f = i[o], t = 0; t < e.length; t++){
            var l = e[t];
            n && (n += ", "), n += l.indexOf("&") !== -1 ? l.replace(p9, f) : f + " " + l;
        }
        return n;
    }
    function R(r, a, i) {
        if (i) return i9({}, i, {
            index: i.index + 1
        });
        var e = r.options.nestingLevel;
        e = e === void 0 ? 1 : e + 1;
        var n = i9({}, r.options, {
            nestingLevel: e,
            index: a.indexOf(r) + 1
        });
        return delete n.name, n;
    }
    function x(r, a, i) {
        if (a.type !== "style") return r;
        var e = a, n = e.options.parent, o, f;
        for(var t in r){
            var l = t.indexOf("&") !== -1, v = t[0] === "@";
            if (!(!l && !v)) {
                if (o = R(e, n, o), l) {
                    var u = g(t, e.selector);
                    f || (f = d(n, i)), u = u.replace(m12, f), n.addRule(u, r[t], i9({}, o, {
                        selector: u
                    }));
                } else v && n.addRule(t, {}, o).addRule(e.key, r[t], {
                    selector: e.selector
                });
                delete r[t];
            }
        }
        return r;
    }
    return {
        onProcessStyle: x
    };
}
var L13 = S11;
function i18(n, r) {
    if (!r) return !0;
    if (Array.isArray(r)) {
        for(var e = 0; e < r.length; e++){
            var s = i18(n, r[e]);
            if (!s) return !1;
        }
        return !0;
    }
    if (r.indexOf(" ") > -1) return i18(n, r.split(" "));
    var t = n.options.parent;
    if (r[0] === "$") {
        var o = t.getRule(r.substr(1));
        return !o || o === n ? !1 : (t.classes[n.key] += " " + t.classes[o.key], !0);
    }
    return t.classes[n.key] += " " + r, !0;
}
function f15() {
    function n(r, e) {
        return "composes" in r && (i18(e, r.composes), delete r.composes), r;
    }
    return {
        onProcessStyle: n
    };
}
var c9 = f15;
var a10 = /[A-Z]/g, n10 = /^ms-/, t5 = {};
function o7(e) {
    return "-" + e.toLowerCase();
}
function p10(e) {
    if (t5.hasOwnProperty(e)) return t5[e];
    var r = e.replace(a10, o7);
    return t5[e] = n10.test(r) ? "-" + r : r;
}
var u9 = p10;
function e14(n) {
    var f = {};
    for(var r in n){
        var a = r.indexOf("--") === 0 ? r : u9(r);
        f[a] = n[r];
    }
    return n.fallbacks && (Array.isArray(n.fallbacks) ? f.fallbacks = n.fallbacks.map(e14) : f.fallbacks = e14(n.fallbacks)), f;
}
function i19() {
    function n(r) {
        if (Array.isArray(r)) {
            for(var a = 0; a < r.length; a++)r[a] = e14(r[a]);
            return r;
        }
        return e14(r);
    }
    function f(r, a, u) {
        if (a.indexOf("--") === 0) return r;
        var c = u9(a);
        return a === c ? r : (u.prop(c, r), null);
    }
    return {
        onProcessStyle: n,
        onChangeValue: f
    };
}
var l8 = i19;
var r3 = Qe1 && CSS ? CSS.px : "px", b15 = Qe1 && CSS ? CSS.ms : "ms", s10 = Qe1 && CSS ? CSS.percent : "%", m13 = {
    "animation-delay": b15,
    "animation-duration": b15,
    "background-position": r3,
    "background-position-x": r3,
    "background-position-y": r3,
    "background-size": r3,
    border: r3,
    "border-bottom": r3,
    "border-bottom-left-radius": r3,
    "border-bottom-right-radius": r3,
    "border-bottom-width": r3,
    "border-left": r3,
    "border-left-width": r3,
    "border-radius": r3,
    "border-right": r3,
    "border-right-width": r3,
    "border-top": r3,
    "border-top-left-radius": r3,
    "border-top-right-radius": r3,
    "border-top-width": r3,
    "border-width": r3,
    "border-block": r3,
    "border-block-end": r3,
    "border-block-end-width": r3,
    "border-block-start": r3,
    "border-block-start-width": r3,
    "border-block-width": r3,
    "border-inline": r3,
    "border-inline-end": r3,
    "border-inline-end-width": r3,
    "border-inline-start": r3,
    "border-inline-start-width": r3,
    "border-inline-width": r3,
    "border-start-start-radius": r3,
    "border-start-end-radius": r3,
    "border-end-start-radius": r3,
    "border-end-end-radius": r3,
    margin: r3,
    "margin-bottom": r3,
    "margin-left": r3,
    "margin-right": r3,
    "margin-top": r3,
    "margin-block": r3,
    "margin-block-end": r3,
    "margin-block-start": r3,
    "margin-inline": r3,
    "margin-inline-end": r3,
    "margin-inline-start": r3,
    padding: r3,
    "padding-bottom": r3,
    "padding-left": r3,
    "padding-right": r3,
    "padding-top": r3,
    "padding-block": r3,
    "padding-block-end": r3,
    "padding-block-start": r3,
    "padding-inline": r3,
    "padding-inline-end": r3,
    "padding-inline-start": r3,
    "mask-position-x": r3,
    "mask-position-y": r3,
    "mask-size": r3,
    height: r3,
    width: r3,
    "min-height": r3,
    "max-height": r3,
    "min-width": r3,
    "max-width": r3,
    bottom: r3,
    left: r3,
    top: r3,
    right: r3,
    inset: r3,
    "inset-block": r3,
    "inset-block-end": r3,
    "inset-block-start": r3,
    "inset-inline": r3,
    "inset-inline-end": r3,
    "inset-inline-start": r3,
    "box-shadow": r3,
    "text-shadow": r3,
    "column-gap": r3,
    "column-rule": r3,
    "column-rule-width": r3,
    "column-width": r3,
    "font-size": r3,
    "font-size-delta": r3,
    "letter-spacing": r3,
    "text-decoration-thickness": r3,
    "text-indent": r3,
    "text-stroke": r3,
    "text-stroke-width": r3,
    "word-spacing": r3,
    motion: r3,
    "motion-offset": r3,
    outline: r3,
    "outline-offset": r3,
    "outline-width": r3,
    perspective: r3,
    "perspective-origin-x": s10,
    "perspective-origin-y": s10,
    "transform-origin": s10,
    "transform-origin-x": s10,
    "transform-origin-y": s10,
    "transform-origin-z": s10,
    "transition-delay": b15,
    "transition-duration": b15,
    "vertical-align": r3,
    "flex-basis": r3,
    "shape-margin": r3,
    size: r3,
    gap: r3,
    grid: r3,
    "grid-gap": r3,
    "row-gap": r3,
    "grid-row-gap": r3,
    "grid-column-gap": r3,
    "grid-template-rows": r3,
    "grid-template-columns": r3,
    "grid-auto-rows": r3,
    "grid-auto-columns": r3,
    "box-shadow-x": r3,
    "box-shadow-y": r3,
    "box-shadow-blur": r3,
    "box-shadow-spread": r3,
    "font-line-height": r3,
    "text-shadow-x": r3,
    "text-shadow-y": r3,
    "text-shadow-blur": r3
};
function c10(n) {
    var t = /(-[a-z])/g, d = function(e) {
        return e[1].toUpperCase();
    }, o = {};
    for(var i in n)o[i] = n[i], o[i.replace(t, d)] = n[i];
    return o;
}
var f16 = c10(m13);
function g19(n, t, d) {
    if (t == null) return t;
    if (Array.isArray(t)) for(var o = 0; o < t.length; o++)t[o] = g19(n, t[o], d);
    else if (typeof t == "object") if (n === "fallbacks") for(var i in t)t[i] = g19(i, t[i], d);
    else for(var a in t)t[a] = g19(n + "-" + a, t[a], d);
    else if (typeof t == "number" && isNaN(t) === !1) {
        var e = d[n] || f16[n];
        return e && !(t === 0 && e === r3) ? typeof e == "function" ? e(t).toString() : "" + t + e : t.toString();
    }
    return t;
}
function h16(n) {
    n === void 0 && (n = {});
    var t = c10(n);
    function d(i, a) {
        if (a.type !== "style") return i;
        for(var e in i)i[e] = g19(e, i[e], t);
        return i;
    }
    function o(i, a) {
        return g19(a, i, t);
    }
    return {
        onProcessStyle: d,
        onChangeValue: o
    };
}
var u10 = h16;
var c11 = {
    "background-size": !0,
    "background-position": !0,
    border: !0,
    "border-bottom": !0,
    "border-left": !0,
    "border-top": !0,
    "border-right": !0,
    "border-radius": !0,
    "border-image": !0,
    "border-width": !0,
    "border-style": !0,
    "border-color": !0,
    "box-shadow": !0,
    flex: !0,
    margin: !0,
    padding: !0,
    outline: !0,
    "transform-origin": !0,
    transform: !0,
    transition: !0
}, m14 = {
    position: !0,
    size: !0
}, a11 = {
    padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    margin: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    background: {
        attachment: null,
        color: null,
        image: null,
        position: null,
        repeat: null
    },
    border: {
        width: null,
        style: null,
        color: null
    },
    "border-top": {
        width: null,
        style: null,
        color: null
    },
    "border-right": {
        width: null,
        style: null,
        color: null
    },
    "border-bottom": {
        width: null,
        style: null,
        color: null
    },
    "border-left": {
        width: null,
        style: null,
        color: null
    },
    outline: {
        width: null,
        style: null,
        color: null
    },
    "list-style": {
        type: null,
        position: null,
        image: null
    },
    transition: {
        property: null,
        duration: null,
        "timing-function": null,
        timingFunction: null,
        delay: null
    },
    animation: {
        name: null,
        duration: null,
        "timing-function": null,
        timingFunction: null,
        delay: null,
        "iteration-count": null,
        iterationCount: null,
        direction: null,
        "fill-mode": null,
        fillMode: null,
        "play-state": null,
        playState: null
    },
    "box-shadow": {
        x: 0,
        y: 0,
        blur: 0,
        spread: 0,
        color: null,
        inset: null
    },
    "text-shadow": {
        x: 0,
        y: 0,
        blur: null,
        color: null
    }
}, d14 = {
    border: {
        radius: "border-radius",
        image: "border-image",
        width: "border-width",
        style: "border-style",
        color: "border-color"
    },
    "border-bottom": {
        width: "border-bottom-width",
        style: "border-bottom-style",
        color: "border-bottom-color"
    },
    "border-top": {
        width: "border-top-width",
        style: "border-top-style",
        color: "border-top-color"
    },
    "border-left": {
        width: "border-left-width",
        style: "border-left-style",
        color: "border-left-color"
    },
    "border-right": {
        width: "border-right-width",
        style: "border-right-style",
        color: "border-right-color"
    },
    background: {
        size: "background-size",
        image: "background-image"
    },
    font: {
        style: "font-style",
        variant: "font-variant",
        weight: "font-weight",
        stretch: "font-stretch",
        size: "font-size",
        family: "font-family",
        lineHeight: "line-height",
        "line-height": "line-height"
    },
    flex: {
        grow: "flex-grow",
        basis: "flex-basis",
        direction: "flex-direction",
        wrap: "flex-wrap",
        flow: "flex-flow",
        shrink: "flex-shrink"
    },
    align: {
        self: "align-self",
        items: "align-items",
        content: "align-content"
    },
    grid: {
        "template-columns": "grid-template-columns",
        templateColumns: "grid-template-columns",
        "template-rows": "grid-template-rows",
        templateRows: "grid-template-rows",
        "template-areas": "grid-template-areas",
        templateAreas: "grid-template-areas",
        template: "grid-template",
        "auto-columns": "grid-auto-columns",
        autoColumns: "grid-auto-columns",
        "auto-rows": "grid-auto-rows",
        autoRows: "grid-auto-rows",
        "auto-flow": "grid-auto-flow",
        autoFlow: "grid-auto-flow",
        row: "grid-row",
        column: "grid-column",
        "row-start": "grid-row-start",
        rowStart: "grid-row-start",
        "row-end": "grid-row-end",
        rowEnd: "grid-row-end",
        "column-start": "grid-column-start",
        columnStart: "grid-column-start",
        "column-end": "grid-column-end",
        columnEnd: "grid-column-end",
        area: "grid-area",
        gap: "grid-gap",
        "row-gap": "grid-row-gap",
        rowGap: "grid-row-gap",
        "column-gap": "grid-column-gap",
        columnGap: "grid-column-gap"
    }
};
function b16(r, t, n) {
    return r.map(function(o) {
        return s11(o, t, n, !1, !0);
    });
}
function g20(r, t, n, o) {
    return n[t] == null ? r : r.length === 0 ? [] : Array.isArray(r[0]) ? g20(r[0], t, n, o) : typeof r[0] == "object" ? b16(r, t, o) : [
        r
    ];
}
function s11(r, t, n, o, e) {
    if (!(a11[t] || d14[t])) return [];
    var l = [];
    if (d14[t] && (r = w10(r, n, d14[t], o)), Object.keys(r).length) for(var i in a11[t]){
        if (r[i]) {
            Array.isArray(r[i]) ? l.push(m14[i] === null ? r[i] : r[i].join(" ")) : l.push(r[i]);
            continue;
        }
        a11[t][i] != null && l.push(a11[t][i]);
    }
    return !l.length || e ? l : [
        l
    ];
}
function w10(r, t, n, o) {
    for(var e in n){
        var l = n[e];
        if (typeof r[e] < "u" && (o || !t.prop(l))) {
            var i, f = u11((i = {}, i[l] = r[e], i), t)[l];
            o ? t.style.fallbacks[l] = f : t.style[l] = f;
        }
        delete r[e];
    }
    return r;
}
function u11(r, t, n) {
    for(var o in r){
        var e = r[o];
        if (Array.isArray(e)) {
            if (!Array.isArray(e[0])) {
                if (o === "fallbacks") {
                    for(var l = 0; l < r.fallbacks.length; l++)r.fallbacks[l] = u11(r.fallbacks[l], t, !0);
                    continue;
                }
                r[o] = g20(e, o, c11, t), r[o].length || delete r[o];
            }
        } else if (typeof e == "object") {
            if (o === "fallbacks") {
                r.fallbacks = u11(r.fallbacks, t, !0);
                continue;
            }
            r[o] = s11(e, o, t, n), r[o].length || delete r[o];
        } else r[o] === "" && delete r[o];
    }
    return r;
}
function h17() {
    function r(t, n) {
        if (!t || n.type !== "style") return t;
        if (Array.isArray(t)) {
            for(var o = 0; o < t.length; o++)t[o] = u11(t[o], n);
            return t;
        }
        return u11(t, n);
    }
    return {
        onProcessStyle: r
    };
}
var y9 = h17;
var m15 = Object.defineProperty;
var d15 = (r, e)=>{
    for(var t in e)m15(r, t, {
        get: e[t],
        enumerable: !0
    });
};
var i20 = {};
d15(i20, {
    default: ()=>p11
});
function o8(r, e) {
    (e == null || e > r.length) && (e = r.length);
    for(var t = 0, l = new Array(e); t < e; t++)l[t] = r[t];
    return l;
}
function a12(r) {
    if (Array.isArray(r)) return o8(r);
}
function n11(r) {
    if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function u12(r, e) {
    if (!!r) {
        if (typeof r == "string") return o8(r, e);
        var t = Object.prototype.toString.call(r).slice(8, -1);
        if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r);
        if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return o8(r, e);
    }
}
function f17() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function p11(r) {
    return a12(r) || n11(r) || u12(r) || f17();
}
var { default: y10 , ...s12 } = i20, k7 = y10 !== void 0 ? y10 : s12;
var l9 = "", y11 = "", W16 = "", z14 = "", V10 = n6 && "ontouchstart" in document.documentElement;
if (n6) {
    v14 = {
        Moz: "-moz-",
        ms: "-ms-",
        O: "-o-",
        Webkit: "-webkit-"
    }, h18 = document.createElement("p"), p12 = h18.style, k8 = "Transform";
    for(m16 in v14)if (m16 + k8 in p12) {
        l9 = m16, y11 = v14[m16];
        break;
    }
    l9 === "Webkit" && "msHyphens" in p12 && (l9 = "ms", y11 = v14.ms, z14 = "edge"), l9 === "Webkit" && "-apple-trailing-word" in p12 && (W16 = "apple");
}
var v14, h18, p12, k8, m16, t6 = {
    js: l9,
    css: y11,
    vendor: W16,
    browser: z14,
    isTouch: V10
};
function sr1(e) {
    return e[1] === "-" || t6.js === "ms" ? e : "@" + t6.css + "keyframes" + e.substr(10);
}
var A13 = {
    noPrefill: [
        "appearance"
    ],
    supportedProperty: function(r) {
        return r !== "appearance" ? !1 : t6.js === "ms" ? "-webkit-" + r : t6.css + r;
    }
}, C10 = {
    noPrefill: [
        "color-adjust"
    ],
    supportedProperty: function(r) {
        return r !== "color-adjust" ? !1 : t6.js === "Webkit" ? t6.css + "print-" + r : r;
    }
}, D11 = /[-\s]+(.)?/g;
function K16(e, r) {
    return r ? r.toUpperCase() : "";
}
function g21(e) {
    return e.replace(D11, K16);
}
function a13(e) {
    return g21("-" + e);
}
var M12 = {
    noPrefill: [
        "mask"
    ],
    supportedProperty: function(r, n) {
        if (!/^mask/.test(r)) return !1;
        if (t6.js === "Webkit") {
            var i = "mask-image";
            if (g21(i) in n) return r;
            if (t6.js + a13(i) in n) return t6.css + r;
        }
        return r;
    }
}, S12 = {
    noPrefill: [
        "text-orientation"
    ],
    supportedProperty: function(r) {
        return r !== "text-orientation" ? !1 : t6.vendor === "apple" && !t6.isTouch ? t6.css + r : r;
    }
}, B15 = {
    noPrefill: [
        "transform"
    ],
    supportedProperty: function(r, n, i) {
        return r !== "transform" ? !1 : i.transform ? r : t6.css + r;
    }
}, I12 = {
    noPrefill: [
        "transition"
    ],
    supportedProperty: function(r, n, i) {
        return r !== "transition" ? !1 : i.transition ? r : t6.css + r;
    }
}, U13 = {
    noPrefill: [
        "writing-mode"
    ],
    supportedProperty: function(r) {
        return r !== "writing-mode" ? !1 : t6.js === "Webkit" || t6.js === "ms" && t6.browser !== "edge" ? t6.css + r : r;
    }
}, H12 = {
    noPrefill: [
        "user-select"
    ],
    supportedProperty: function(r) {
        return r !== "user-select" ? !1 : t6.js === "Moz" || t6.js === "ms" || t6.vendor === "apple" ? t6.css + r : r;
    }
}, L14 = {
    supportedProperty: function(r, n) {
        if (!/^break-/.test(r)) return !1;
        if (t6.js === "Webkit") {
            var i = "WebkitColumn" + a13(r);
            return i in n ? t6.css + "column-" + r : !1;
        }
        if (t6.js === "Moz") {
            var d = "page" + a13(r);
            return d in n ? "page-" + r : !1;
        }
        return !1;
    }
}, R16 = {
    supportedProperty: function(r, n) {
        if (!/^(border|margin|padding)-inline/.test(r)) return !1;
        if (t6.js === "Moz") return r;
        var i = r.replace("-inline", "");
        return t6.js + a13(i) in n ? t6.css + i : !1;
    }
}, _10 = {
    supportedProperty: function(r, n) {
        return g21(r) in n ? r : !1;
    }
}, q15 = {
    supportedProperty: function(r, n) {
        var i = a13(r);
        return r[0] === "-" || r[0] === "-" && r[1] === "-" ? r : t6.js + i in n ? t6.css + r : t6.js !== "Webkit" && "Webkit" + i in n ? "-webkit-" + r : !1;
    }
}, F10 = {
    supportedProperty: function(r) {
        return r.substring(0, 11) !== "scroll-snap" ? !1 : t6.js === "ms" ? "" + t6.css + r : r;
    }
}, G13 = {
    supportedProperty: function(r) {
        return r !== "overscroll-behavior" ? !1 : t6.js === "ms" ? t6.css + "scroll-chaining" : r;
    }
}, J11 = {
    "flex-grow": "flex-positive",
    "flex-shrink": "flex-negative",
    "flex-basis": "flex-preferred-size",
    "justify-content": "flex-pack",
    order: "flex-order",
    "align-items": "flex-align",
    "align-content": "flex-line-pack"
}, Q16 = {
    supportedProperty: function(r, n) {
        var i = J11[r];
        return i && t6.js + a13(i) in n ? t6.css + i : !1;
    }
}, N9 = {
    flex: "box-flex",
    "flex-grow": "box-flex",
    "flex-direction": [
        "box-orient",
        "box-direction"
    ],
    order: "box-ordinal-group",
    "align-items": "box-align",
    "flex-flow": [
        "box-orient",
        "box-direction"
    ],
    "justify-content": "box-pack"
}, X17 = Object.keys(N9), Y14 = function(r) {
    return t6.css + r;
}, Z14 = {
    supportedProperty: function(r, n, i) {
        var d = i.multiple;
        if (X17.indexOf(r) > -1) {
            var u = N9[r];
            if (!Array.isArray(u)) return t6.js + a13(u) in n ? t6.css + u : !1;
            if (!d) return !1;
            for(var j = 0; j < u.length; j++)if (!(t6.js + a13(u[0]) in n)) return !1;
            return u.map(Y14);
        }
        return !1;
    }
}, O17 = [
    A13,
    C10,
    M12,
    S12,
    B15,
    I12,
    U13,
    H12,
    L14,
    R16,
    _10,
    q15,
    F10,
    G13,
    Q16,
    Z14
], w11 = O17.filter(function(e) {
    return e.supportedProperty;
}).map(function(e) {
    return e.supportedProperty;
}), $13 = O17.filter(function(e) {
    return e.noPrefill;
}).reduce(function(e, r) {
    return e.push.apply(e, k7(r.noPrefill)), e;
}, []), c12, f18 = {};
if (n6) {
    c12 = document.createElement("p"), x14 = window.getComputedStyle(document.documentElement, "");
    for(P15 in x14)isNaN(P15) || (f18[x14[P15]] = x14[P15]);
    $13.forEach(function(e) {
        return delete f18[e];
    });
}
var x14, P15;
function E9(e, r) {
    if (r === void 0 && (r = {}), !c12) return e;
    if (f18[e] != null) return f18[e];
    (e === "transition" || e === "transform") && (r[e] = e in c12.style);
    for(var n = 0; n < w11.length && (f18[e] = w11[n](e, c12.style, r), !f18[e]); n++);
    try {
        c12.style[e] = "";
    } catch  {
        return !1;
    }
    return f18[e];
}
var o9 = {}, rr2 = {
    transition: 1,
    "transition-property": 1,
    "-webkit-transition": 1,
    "-webkit-transition-property": 1
}, er2 = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g, s13;
function tr1(e, r, n) {
    if (r === "var") return "var";
    if (r === "all") return "all";
    if (n === "all") return ", all";
    var i = r ? E9(r) : ", " + E9(n);
    return i || r || n;
}
n6 && (s13 = document.createElement("p"));
function ar(e, r) {
    var n = r;
    if (!s13 || e === "content") return r;
    if (typeof n != "string" || !isNaN(parseInt(n, 10))) return n;
    var i = e + n;
    if (o9[i] != null) return o9[i];
    try {
        s13.style[e] = n;
    } catch  {
        return o9[i] = !1, !1;
    }
    if (rr2[e]) n = n.replace(er2, tr1);
    else if (s13.style[e] === "" && (n = t6.css + n, n === "-ms-flex" && (s13.style[e] = "-ms-flexbox"), s13.style[e] = n, s13.style[e] === "")) return o9[i] = !1, !1;
    return s13.style[e] = "", o9[i] = n, o9[i];
}
function S13() {
    function u(r) {
        if (r.type === "keyframes") {
            var n = r;
            n.at = sr1(n.at);
        }
    }
    function a(r) {
        for(var n in r){
            var f = r[n];
            if (n === "fallbacks" && Array.isArray(f)) {
                r[n] = f.map(a);
                continue;
            }
            var i = !1, e = E9(n);
            e && e !== n && (i = !0);
            var o = !1, t = ar(e, R14(f));
            t && t !== f && (o = !0), (i || o) && (i && delete r[n], r[e || n] = t || f);
        }
        return r;
    }
    function m(r, n) {
        return n.type !== "style" ? r : a(r);
    }
    function y(r, n) {
        return ar(n, R14(r)) || r;
    }
    return {
        onProcessRule: u,
        onProcessStyle: m,
        onChangeValue: y
    };
}
var A14 = S13;
function l10() {
    var s = function(t, e) {
        return t.length === e.length ? t > e ? 1 : -1 : t.length - e.length;
    };
    return {
        onProcessStyle: function(t, e) {
            if (e.type !== "style") return t;
            for(var o = {}, n = Object.keys(t).sort(s), r = 0; r < n.length; r++)o[n[r]] = t[n[r]];
            return o;
        }
    };
}
var f19 = l10;
var c13 = function(r) {
    return r === void 0 && (r = {}), {
        plugins: [
            m10(),
            g16(r.observable),
            g17(),
            x13(),
            b14(),
            L13(),
            c9(),
            l8(),
            u10(r.defaultUnit),
            y9(),
            A14(),
            f19()
        ]
    };
}, w12 = c13;
function u13(t) {
    var n = {};
    return function(e) {
        return n[e] === void 0 && (n[e] = t(e)), n[e];
    };
}
var f20 = u13;
var r4 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, i21 = f20(function(e) {
    return r4.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
});
var A15 = 1e4, C11 = $e9(w12()), J12 = function(u) {
    u === void 0 && (u = C11);
    var r = new Map, E = 0, t, o = function() {
        return (!t || t.rules.index.length > A15) && (t = u.createStyleSheet().attach()), t;
    };
    function p() {
        var s = arguments, S = JSON.stringify(s), m = r.get(S);
        if (m) return m.className;
        var l = [];
        for(var N in s){
            var v = s[N];
            if (!Array.isArray(v)) {
                l.push(v);
                continue;
            }
            for(var c = 0; c < v.length; c++)l.push(v[c]);
        }
        for(var f = {}, e = [], h = 0; h < l.length; h++){
            var n = l[h];
            if (!!n) {
                var a = n;
                if (typeof n == "string") {
                    var i = r.get(n);
                    i && (i.labels.length && e.push.apply(e, i.labels), a = i.style);
                }
                a.label && e.indexOf(a.label) === -1 && e.push(a.label), Object.assign(f, a);
            }
        }
        delete f.label;
        var x = e.length === 0 ? "css" : e.join("-"), b = x + "-" + E++;
        o().addRule(b, f);
        var g = o().classes[b], d = {
            style: f,
            labels: e,
            className: g
        };
        return r.set(S, d), r.set(g, d), g;
    }
    return p.getSheet = o, p;
}, M13 = J12(), L15 = M13;
var ue6 = Number.MIN_SAFE_INTEGER || -1e9, J13 = function() {
    return ue6++;
}, D12 = Ee7({
    classNamePrefix: "",
    disableStylesGeneration: !1
}), I13 = new Map, G14 = function(e, r) {
    var t = e.managers;
    if (t) return t[r] || (t[r] = new Ye6), t[r];
    var a = I13.get(r);
    return a || (a = new Ye6, I13.set(r, a)), a;
}, fe11 = function(e) {
    var r = e.sheet, t = e.context, a = e.index, n = e.theme;
    if (!!r) {
        var s = G14(t, a);
        s.manage(n), t.registry && t.registry.add(r);
    }
}, le10 = function(e) {
    if (!!e.sheet) {
        var r = G14(e.context, e.index);
        r.unmanage(e.theme);
    }
}, ce11 = $e9(w12()), L16 = new WeakMap, U14 = function(e) {
    return L16.get(e);
}, de13 = function(e, r) {
    L16.set(e, r);
}, me12 = function(e) {
    var r = e.styles;
    return typeof r != "function" ? r : r(e.theme);
};
function ve10(i, e) {
    var r;
    i.context.id && i.context.id.minify != null && (r = i.context.id.minify);
    var t = i.context.classNamePrefix || "";
    i.name && !r && (t += i.name.replace(/\s/g, "-") + "-");
    var a = "";
    return i.name && (a = i.name + ", "), a += typeof i.styles == "function" ? "Themed" : "Unthemed", i9({}, i.sheetOptions, {
        index: i.index,
        meta: a,
        classNamePrefix: t,
        link: e,
        generateId: i.sheetOptions && i.sheetOptions.generateId ? i.sheetOptions.generateId : i.context.generateId
    });
}
var oe12 = function(e) {
    if (!e.context.disableStylesGeneration) {
        var r = G14(e.context, e.index), t = r.get(e.theme);
        if (t) return t;
        var a = e.context.jss || ce11, n = me12(e), s = Ue6(n), u = a.createStyleSheet(n, ve10(e, s !== null));
        return de13(u, {
            dynamicStyles: s,
            styles: n
        }), r.add(e.theme, u), u;
    }
}, he9 = function(e, r) {
    for(var t in r)e.deleteRule(r[t]);
}, ge10 = function(e, r, t) {
    for(var a in t)r.updateOne(t[a], e);
}, ye12 = function(e, r) {
    var t = U14(e);
    if (!!t) {
        var a = {};
        for(var n in t.dynamicStyles)for(var s = e.rules.index.length, u = e.addRule(n, t.dynamicStyles[n]), f = s; f < e.rules.index.length; f++){
            var c = e.rules.index[f];
            e.updateOne(c, r), a[u === c ? n : c.key] = c;
        }
        return a;
    }
}, xe11 = function(e, r) {
    if (!r) return e.classes;
    var t = U14(e);
    if (!t) return e.classes;
    var a = {};
    for(var n in t.styles)a[n] = e.classes[n], n in r && (a[n] += " " + e.classes[r[n].key]);
    return a;
}, C12 = n6 ? Fe6 : De6, M14 = {}, V11 = function(e, r) {
    r === void 0 && (r = {});
    var t = r, a = t.index, n = a === void 0 ? J13() : a, s = t.theming, u = t.name, f = c3(t, [
        "index",
        "theming",
        "name"
    ]), c = s && s.context || E7, m = function(d) {
        return typeof e == "function" && (d || ge8(c)) || M14;
    };
    return function(d) {
        var g = Ae6(!0), h = ge8(D12), v = m(d && d.theme), l = Ue5(function() {
            var P = oe12({
                context: h,
                styles: e,
                name: u,
                theme: v,
                index: n,
                sheetOptions: f
            }), w = P ? ye12(P, d) : null;
            return P && fe11({
                index: n,
                context: h,
                sheet: P,
                theme: v
            }), [
                P,
                w
            ];
        }, [
            h,
            v
        ]), o = l[0], y = l[1];
        C12(function() {
            o && y && !g.current && ge10(d, o, y);
        }, [
            d
        ]), C12(function() {
            return function() {
                o && le10({
                    index: n,
                    context: h,
                    sheet: o,
                    theme: v
                }), o && y && he9(o, y);
            };
        }, [
            o
        ]);
        var S = o && y ? xe11(o, y) : {};
        return Pe9(S), Pe9(v === M14 ? "No theme" : v), De6(function() {
            g.current = !1;
        }), S;
    };
};
var z15 = Symbol("react-jss-styled"), Re8 = function(e) {
    return e === void 0 && (e = L15), function(t, a) {
        var n = arguments;
        if (a && a.css) {
            var s = e(a.css), u = Object.assign({}, a);
            u.className = a.className ? a.className + " " + s : s, delete u.css, n[1] = u;
        }
        return Re6.apply(void 0, n);
    };
}, Ue7 = Re8();
var c14 = Object.create;
var r5 = Object.defineProperty;
var p13 = Object.getOwnPropertyDescriptor;
var m17 = Object.getOwnPropertyNames;
var h19 = Object.getPrototypeOf, v15 = Object.prototype.hasOwnProperty;
var _11 = (n, e)=>()=>(e || n((e = {
            exports: {}
        }).exports, e), e.exports);
var y12 = (n, e, s, f)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of m17(e))!v15.call(n, t) && t !== s && r5(n, t, {
        get: ()=>e[t],
        enumerable: !(f = p13(e, t)) || f.enumerable
    });
    return n;
};
var b17 = (n, e, s)=>(s = n != null ? c14(h19(n)) : {}, y12(e || !n || !n.__esModule ? r5(s, "default", {
        value: n,
        enumerable: !0
    }) : s, n));
var a14 = _11((O, i)=>{
    (function() {
        "use strict";
        var n = {}.hasOwnProperty;
        function e() {
            for(var s = [], f = 0; f < arguments.length; f++){
                var t = arguments[f];
                if (!!t) {
                    var o = typeof t;
                    if (o === "string" || o === "number") s.push(t);
                    else if (Array.isArray(t)) {
                        if (t.length) {
                            var l = e.apply(null, t);
                            l && s.push(l);
                        }
                    } else if (o === "object") if (t.toString === Object.prototype.toString) for(var u in t)n.call(t, u) && t[u] && s.push(u);
                    else s.push(t.toString());
                }
            }
            return s.join(" ");
        }
        typeof i < "u" && i.exports ? (e.default = e, i.exports = e) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function() {
            return e;
        }) : window.classNames = e;
    })();
});
var j18 = b17(a14()), { default: d16 , ...w13 } = j18, S14 = d16 !== void 0 ? d16 : w13;
var i22, o10, d17, N10, a15 = 0, q16 = [], l11 = [], V12 = d.__b, g22 = d.__r, b18 = d.diffed, A16 = d.__c, C13 = d.unmount;
function f21(_, t) {
    d.__h && d.__h(o10, _, a15 || t), a15 = 0;
    var u = o10.__H || (o10.__H = {
        __: [],
        __h: []
    });
    return _ >= u.__.length && u.__.push({
        __V: l11
    }), u.__[_];
}
function T7(_) {
    return a15 = 1, P16(D13, _);
}
function P16(_, t, u) {
    var n = f21(i22++, 2);
    if (n.t = _, !n.__c && (n.__ = [
        u ? u(t) : D13(void 0, t),
        function(s) {
            var h = n.__N ? n.__N[0] : n.__[0], v = n.t(h, s);
            h !== v && (n.__N = [
                v,
                n.__[1]
            ], n.__c.setState({}));
        }
    ], n.__c = o10, !o10.u)) {
        o10.u = !0;
        var r = o10.shouldComponentUpdate;
        o10.shouldComponentUpdate = function(s, h, v) {
            if (!n.__c.__H) return !0;
            var y = n.__c.__H.__.filter(function(c) {
                return c.__c;
            });
            if (y.every(function(c) {
                return !c.__N;
            })) return !r || r.call(this, s, h, v);
            var E = !1;
            return y.forEach(function(c) {
                if (c.__N) {
                    var k = c.__[0];
                    c.__ = c.__N, c.__N = void 0, k !== c.__[0] && (E = !0);
                }
            }), !(!E && n.__c.props === s) && (!r || r.call(this, s, h, v));
        };
    }
    return n.__N || n.__;
}
function U15(_, t) {
    var u = f21(i22++, 3);
    !d.__s && H13(u.__H, t) && (u.__ = _, u.i = t, o10.__H.__h.push(u));
}
function j19(_) {
    return a15 = 5, x15(function() {
        return {
            current: _
        };
    }, []);
}
function x15(_, t) {
    var u = f21(i22++, 7);
    return H13(u.__H, t) ? (u.__V = _(), u.i = t, u.__h = _, u.__V) : u.__;
}
function I14() {
    for(var _; _ = q16.shift();)if (_.__P && _.__H) try {
        _.__H.__h.forEach(m18), _.__H.__h.forEach(p14), _.__H.__h = [];
    } catch (t) {
        _.__H.__h = [], d.__e(t, _.__v);
    }
}
d.__b = function(_) {
    typeof _.type != "function" || _.__m || _.__ === null ? _.__m || (_.__m = _.__ && _.__.__m ? _.__.__m : "") : _.__m = (_.__ && _.__.__m ? _.__.__m : "") + (_.__ && _.__.__k ? _.__.__k.indexOf(_) : 0), o10 = null, V12 && V12(_);
}, d.__r = function(_) {
    g22 && g22(_), i22 = 0;
    var t = (o10 = _.__c).__H;
    t && (d17 === o10 ? (t.__h = [], o10.__h = [], t.__.forEach(function(u) {
        u.__N && (u.__ = u.__N), u.__V = l11, u.__N = u.i = void 0;
    })) : (t.__h.forEach(m18), t.__h.forEach(p14), t.__h = [])), d17 = o10;
}, d.diffed = function(_) {
    b18 && b18(_);
    var t = _.__c;
    t && t.__H && (t.__H.__h.length && (q16.push(t) !== 1 && N10 === d.requestAnimationFrame || ((N10 = d.requestAnimationFrame) || R17)(I14)), t.__H.__.forEach(function(u) {
        u.i && (u.__H = u.i), u.__V !== l11 && (u.__ = u.__V), u.i = void 0, u.__V = l11;
    })), d17 = o10 = null;
}, d.__c = function(_, t) {
    t.some(function(u) {
        try {
            u.__h.forEach(m18), u.__h = u.__h.filter(function(n) {
                return !n.__ || p14(n);
            });
        } catch (n) {
            t.some(function(r) {
                r.__h && (r.__h = []);
            }), t = [], d.__e(n, u.__v);
        }
    }), A16 && A16(_, t);
}, d.unmount = function(_) {
    C13 && C13(_);
    var t, u = _.__c;
    u && u.__H && (u.__H.__.forEach(function(n) {
        try {
            m18(n);
        } catch (r) {
            t = r;
        }
    }), u.__H = void 0, t && d.__e(t, u.__v));
};
var F11 = typeof requestAnimationFrame == "function";
function R17(_) {
    var t, u = function() {
        clearTimeout(n), F11 && cancelAnimationFrame(t), setTimeout(_);
    }, n = setTimeout(u, 100);
    F11 && (t = requestAnimationFrame(u));
}
function m18(_) {
    var t = o10, u = _.__c;
    typeof u == "function" && (_.__c = void 0, u()), o10 = t;
}
function p14(_) {
    var t = o10;
    _.__c = _.__(), o10 = t;
}
function H13(_, t) {
    return !_ || _.length !== t.length || t.some(function(u, n) {
        return u !== _[n];
    });
}
function D13(_, t) {
    return typeof t == "function" ? t(_) : t;
}
const vflex = {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center"
};
const hflex = {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center"
};
const useStyles = V11({
    root: {
        ...hflex,
        minHeight: "1em",
        fontSize: 16,
        lineHeight: 1.6
    },
    leftAlign: {
        minWidth: "14em",
        justifyContent: "flex-start",
        textAlign: "left"
    },
    rightAlign: {
        minWidth: "14em",
        justifyContent: "flex-end",
        textAlign: "right"
    },
    bold: {
        fontWeight: "bold"
    },
    italic: {
        fontStyle: "italic"
    },
    underline: {
        textDecoration: "underline"
    },
    color: (chunk)=>({
            color: "#" + chunk.style.color
        })
});
const StringChunkComponent = (props)=>{
    const { chunk  } = props;
    const styles = useStyles(chunk);
    const textStyles = [];
    switch(chunk.cell){
        case "LEFT":
            textStyles.push(styles.leftAlign);
            break;
        case "RIGHT":
            textStyles.push(styles.rightAlign);
            break;
        default:
            break;
    }
    if (chunk.style.bold) {
        textStyles.push(styles.bold);
    }
    if (chunk.style.italic) {
        textStyles.push(styles.italic);
    }
    if (chunk.style.underline) {
        textStyles.push(styles.underline);
    }
    textStyles.push(styles.color);
    return _e("span", {
        className: S14(styles.root, ...textStyles)
    }, chunk.text);
};
const useStyles1 = V11({
    root: {
        minHeight: "1em",
        fontSize: 16,
        lineHeight: 1.6,
        color: "white",
        cursor: "pointer"
    },
    leftAlign: {
        minWidth: "14em",
        justifyContent: "flex-start",
        textAlign: "left"
    },
    rightAlign: {
        minWidth: "14em",
        justifyContent: "flex-end",
        textAlign: "right"
    },
    bold: {
        fontWeight: "bold"
    },
    italic: {
        fontStyle: "italic"
    },
    underline: {
        textDecoration: "underline"
    },
    color: (chunk)=>({
            color: "#" + chunk.style.color,
            "&:hover": {
                color: "#" + chunk.style.focus
            }
        })
});
const ButtonChunkComponent = (props)=>{
    const { chunk , textified  } = props;
    const dispatch = useDispatch();
    const styles = useStyles1(chunk);
    const onClick = (event)=>{
        dispatch(pushInput({
            type: "normal",
            value: chunk.value
        }));
        dispatch(refreshTextified());
        event.stopPropagation();
    };
    const textStyles = [];
    switch(chunk.cell){
        case "LEFT":
            textStyles.push(styles.leftAlign);
            break;
        case "RIGHT":
            textStyles.push(styles.rightAlign);
            break;
        default:
            break;
    }
    if (chunk.style.bold) {
        textStyles.push(styles.bold);
    }
    if (chunk.style.italic) {
        textStyles.push(styles.italic);
    }
    if (chunk.style.underline) {
        textStyles.push(styles.underline);
    }
    textStyles.push(styles.color);
    if (textified === true) {
        return _e(StringChunkComponent, {
            chunk: {
                ...chunk,
                type: "string"
            }
        });
    } else {
        return _e("button", {
            className: S14(styles.root, ...textStyles),
            onClick: onClick
        }, chunk.text);
    }
};
const useStyles2 = V11({
    root: {
        ...hflex,
        flexShrink: 0,
        alignItems: "stretch",
        flexWrap: "wrap",
        fontSize: 16
    },
    leftAlign: {
        justifyContent: "flex-start"
    },
    centerAlign: {
        justifyContent: "center"
    },
    rightAlign: {
        justifyContent: "flex-end"
    }
});
const ContentBlock = (props)=>{
    const { block , textified  } = props;
    const styles = useStyles2();
    let alignStyle;
    switch(block.align){
        case "LEFT":
            alignStyle = styles.leftAlign;
            break;
        case "CENTER":
            alignStyle = styles.centerAlign;
            break;
        case "RIGHT":
            alignStyle = styles.rightAlign;
            break;
    }
    return _e("div", {
        className: S14(styles.root, alignStyle)
    }, block.children.map((chunk)=>{
        switch(chunk.type){
            case "button":
                return _e(ButtonChunkComponent, {
                    chunk: chunk,
                    textified: textified
                });
            case "string":
                return _e(StringChunkComponent, {
                    chunk: chunk
                });
        }
    }));
};
const useStyles3 = V11({
    root: {
        ...vflex,
        flexShrink: 0,
        width: "100%",
        height: "1em"
    },
    line: {
        width: "100%",
        height: "0px"
    },
    single: {
        borderTop: "2px solid"
    },
    double: {
        borderTop: "4px double"
    },
    dot: {
        borderTop: "2px dotted"
    },
    text: {
        maxWidth: "100%",
        minHeight: "1em",
        fontSize: 16,
        lineHeight: 1.6,
        whitespace: "nowrap",
        overflow: "hidden"
    }
});
const LineChunkComponent = (props)=>{
    const { block  } = props;
    const styles = useStyles3();
    let child;
    if (block.value == null || block.value === "-" || block.value === "") {
        child = _e("div", {
            className: S14(styles.line, styles.single)
        });
    } else if (block.value === "=") {
        child = _e("div", {
            className: S14(styles.line, styles.double)
        });
    } else if (block.value === ".") {
        child = _e("div", {
            className: S14(styles.line, styles.dot)
        });
    } else {
        child = _e("span", {
            className: styles.text
        }, block.value.repeat(1000));
    }
    return _e("div", {
        className: styles.root
    }, child);
};
const useStyles4 = V11({
    root: {
        ...vflex,
        alignItems: "stretch",
        justifyContent: "flex-start",
        fontSize: 16,
        overflowY: "scroll"
    }
});
const BlockList = (props)=>{
    const { className  } = props;
    const dispatch = useDispatch();
    const styles = useStyles4();
    const blocks = useSelector(selectBlocks);
    const textified = useSelector(selectTextified);
    const bodyRef = j19(null);
    U15(()=>{
        bodyRef.current?.scrollTo(0, bodyRef.current?.scrollHeight);
    }, [
        blocks
    ]);
    const onClick = ()=>dispatch(pushInput({
            type: "pass"
        }));
    const onContextMenu = (event)=>{
        dispatch(pushInput({
            type: "skip"
        }));
        event.preventDefault();
    };
    return _e("div", {
        className: S14([
            styles.root,
            className
        ]),
        ref: bodyRef,
        onClick: onClick,
        onContextMenu: onContextMenu
    }, blocks.map((block, i)=>{
        switch(block.type){
            case "content":
                return _e(ContentBlock, {
                    key: i,
                    textified: textified >= i,
                    block: block
                });
            case "line":
                return _e(LineChunkComponent, {
                    key: i,
                    block: block
                });
            default:
                return null;
        }
    }));
};
const useStyles5 = V11({
    root: {
        ...hflex,
        fontSize: 16
    },
    button: {
        height: "100%",
        padding: "0.5em",
        border: "1px solid white",
        backgroundColor: "transparent",
        color: "white",
        cursor: "pointer"
    },
    input: {
        flex: "1 1 auto",
        height: "100%",
        padding: "0.5em 1em",
        border: "1px solid white",
        backgroundColor: "transparent",
        color: "white",
        "&:focus": {
            outline: "none"
        }
    }
});
const Console = (props)=>{
    const { className  } = props;
    const dispatch = useDispatch();
    const styles = useStyles5();
    const [value, setValue] = T7("");
    const onSubmit = (event)=>{
        event.preventDefault();
        dispatch(refreshTextified());
        dispatch(pushInput({
            type: "normal",
            value
        }));
        setValue("");
    };
    const inputRef = j19(null);
    U15(()=>inputRef.current?.focus(), [
        inputRef
    ]);
    return _e("form", {
        className: S14(styles.root, className),
        onSubmit: onSubmit
    }, _e("button", {
        className: styles.button
    }, "Enter"), _e("input", {
        ref: inputRef,
        className: styles.input,
        type: "text",
        value: value,
        onChange: (event)=>setValue(event.target.value)
    }));
};
const useStyles6 = V11({
    root: {
        ...vflex,
        padding: "2em",
        backgroundColor: "black",
        border: "1px solid white",
        transform: "translate(-50%, -50%)"
    },
    title: {
        marginBottom: "1.5em",
        fontSize: 20,
        fontWeight: "bold",
        lineHeight: 1.2,
        textAlign: "center"
    },
    message: {
        marginBottom: "1.5em",
        fontSize: 16,
        textAlign: "center"
    },
    info: {
        marginBottom: "0.5em",
        fontSize: 14,
        textAlign: "center"
    },
    buttonList: {
        ...hflex,
        marginTop: "2em"
    },
    button: {
        padding: "0.5em",
        color: "white",
        border: "1px solid white",
        fontWeight: "bold",
        cursor: "pointer",
        "&+&": {
            marginLeft: "2em"
        }
    }
});
const ErrorPopup = (props)=>{
    const { className , error , onBack , onRetry  } = props;
    const styles = useStyles6();
    return _e("div", {
        className: S14(styles.root, className)
    }, _e("h2", {
        className: styles.title
    }, "Error detected!"), _e("span", {
        className: styles.message
    }, error.message), error instanceof EraJSError ? _e(W, null, _e("span", {
        className: styles.info
    }, "At: ", error.line.file, " line ", error.line.line), _e("span", {
        className: styles.info
    }, error.line.content), _e("span", {
        className: styles.info
    }, "Trace: ", error.trace.join(" > "))) : null, _e("div", {
        className: styles.buttonList
    }, _e("button", {
        className: styles.button,
        onClick: onBack
    }, "Go Back"), _e("button", {
        className: styles.button,
        onClick: onRetry
    }, "Retry")));
};
function useAsyncEffect(effect, deps) {
    U15(()=>{
        effect();
    }, deps);
}
const useStyles7 = V11({
    root: {
        ...vflex,
        position: "relative",
        width: "100%",
        height: "100%",
        padding: "2rem",
        backgroundColor: "black",
        color: "white"
    },
    popup: {
        position: "absolute",
        top: "50%",
        left: "50%",
        maxWidth: "50%",
        transform: "translate(-50%, -50%)"
    },
    spacer: {
        flex: "1 1 auto"
    },
    body: {
        width: "100%",
        flex: "1 1 auto"
    },
    console: {
        width: "100%"
    }
});
const Play = ()=>{
    const history = we6();
    const dispatch = useDispatch();
    const styles = useStyles7();
    const params = Oe3();
    const error = useSelector(selectError);
    useAsyncEffect(()=>dispatch(startVM(params.slot)), [
        params.slot
    ]);
    const onBack = ()=>history.push("/");
    const onRetry = ()=>dispatch(startVM(params.slot));
    return _e("div", {
        className: styles.root
    }, error != null ? _e(ErrorPopup, {
        className: styles.popup,
        error: error,
        onBack: onBack,
        onRetry: onRetry
    }) : null, _e("div", {
        className: styles.spacer
    }), _e(BlockList, {
        className: styles.body
    }), _e(Console, {
        className: styles.console
    }));
};
const AddBox = (props)=>{
    const { className , color , onClick  } = props;
    const size = props.size ?? 24;
    return _e("svg", {
        viewBox: "0 0 24 24",
        fill: color,
        class: className,
        width: size,
        height: size,
        onClick: onClick
    }, _e("path", {
        d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-8-2h2v-4h4v-2h-4V7h-2v4H7v2h4z"
    }));
};
const CheckCircle = (props)=>{
    const { className , color , onClick  } = props;
    const size = props.size ?? 24;
    return _e("svg", {
        viewBox: "0 0 24 24",
        fill: color,
        class: className,
        width: size,
        height: size,
        onClick: onClick
    }, _e("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm4.59-12.42L10 14.17l-2.59-2.58L6 13l4 4 8-8z"
    }));
};
const Sync = (props)=>{
    const { className , color , onClick  } = props;
    const size = props.size ?? 24;
    return _e("svg", {
        viewBox: "0 0 24 24",
        fill: color,
        class: className,
        width: size,
        height: size,
        onClick: onClick
    }, _e("path", {
        d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
    }));
};
const useStyles8 = V11({
    "@keyframes spin": {
        "100%": {
            transform: "rotate(-360deg)"
        }
    },
    root: {
        ...hflex,
        justifyContent: "flex-start",
        padding: "1em",
        fontSize: 16
    },
    spin: {
        animation: "$spin 2s linear infinite"
    },
    body: {
        ...vflex,
        alignItems: "flex-start",
        width: "100%",
        marginRight: "0.5em"
    },
    label: {
        ...hflex,
        width: "100%",
        marginBottom: "0.5em"
    },
    nameInput: {
        width: "100%",
        marginLeft: "0.5em",
        padding: "0.2em",
        border: "1px solid white",
        backgroundColor: "transparent",
        color: "white",
        "&:focus": {
            outline: "none"
        }
    },
    fileInput: {
        width: "100%",
        marginLeft: "2em",
        "&:focus": {
            outline: "none"
        }
    },
    error: {
        fontSize: 14,
        color: "red"
    },
    icon: {
        cursor: "pointer"
    }
});
const NewSlot = (props)=>{
    const { className , onCreate  } = props;
    const styles = useStyles8();
    const [name, setName] = T7("");
    const [error, setError] = T7(null);
    const [isSubmitting, setIsSubmitting] = T7(false);
    const slots = useSelector(selectSlots);
    const fileRef = j19(null);
    const onSubmit = async ()=>{
        if (isSubmitting) {
            return;
        }
        setIsSubmitting(true);
        const file = fileRef.current.files?.item(0);
        if (name === "") {
            setError("Please set the name of the slot");
            return;
        } else if (slots[name] != null) {
            setError(`Slot ${name} already exists`);
            return;
        } else if (file == null) {
            setError("Please specify the file for this slot");
            return;
        } else if (file.type !== "application/zip" && file.type !== "application/x-zip" && file.type !== "application/x-zip-compressed") {
            setError("Only zip files are supported");
            return;
        }
        setError(null);
        await onCreate?.({
            name
        }, file);
        setIsSubmitting(false);
    };
    return _e("div", {
        className: S14([
            styles.root,
            className
        ])
    }, _e("div", {
        className: styles.body
    }, _e("label", {
        className: styles.label
    }, "Name:", _e("input", {
        className: styles.nameInput,
        type: "text",
        value: name,
        onChange: (e)=>setName(e.target.value)
    })), _e("label", {
        className: styles.label
    }, "File:", _e("input", {
        className: styles.fileInput,
        type: "file",
        ref: fileRef
    })), error != null ? _e("span", {
        className: styles.error
    }, error) : null), isSubmitting ? _e(Sync, {
        className: S14(styles.icon, styles.spin),
        color: "white",
        size: 48
    }) : _e(CheckCircle, {
        className: styles.icon,
        color: "white",
        size: 48,
        onClick: onSubmit
    }));
};
const Delete = (props)=>{
    const { className , color , onClick  } = props;
    const size = props.size ?? 24;
    return _e("svg", {
        viewBox: "0 0 24 24",
        fill: color,
        class: className,
        width: size,
        height: size,
        onClick: onClick
    }, _e("path", {
        d: "M16 9v10H8V9h8m-1.5-6h-5l-1 1H5v2h14V4h-3.5l-1-1zM18 7H6v12c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7z"
    }));
};
const PlayCircleFilled = (props)=>{
    const { className , color , onClick  } = props;
    const size = props.size ?? 24;
    return _e("svg", {
        viewBox: "0 0 24 24",
        fill: color,
        class: className,
        width: size,
        height: size,
        onClick: onClick
    }, _e("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"
    }));
};
const useStyles9 = V11({
    root: {
        ...vflex,
        padding: "1em",
        fontSize: 16
    },
    body: {
        ...hflex,
        width: "100%"
    },
    name: {
        flexGrow: 1
    },
    icon: {
        marginLeft: "0.5em",
        cursor: "pointer"
    }
});
const ValidSlot = (props)=>{
    const { slot  } = props;
    const onPlay = ()=>props.onPlay?.(slot);
    const onDelete = ()=>props.onDelete?.(slot);
    const styles = useStyles9();
    return _e("div", {
        className: styles.root
    }, _e("div", {
        className: styles.body
    }, _e("span", {
        className: styles.name
    }, slot.name), _e(PlayCircleFilled, {
        className: styles.icon,
        color: "white",
        size: 48,
        onClick: onPlay
    }), _e(Delete, {
        className: styles.icon,
        color: "white",
        size: 48,
        onClick: onDelete
    })));
};
const useStyles10 = V11({
    root: {
        ...vflex,
        width: "100%",
        height: "100%",
        backgroundColor: "black",
        color: "white"
    },
    title: {
        fontSize: 34,
        fontWeight: "bold",
        lineHeight: "1.5em"
    },
    subtitle: {
        marginBottom: "1em",
        fontSize: 20,
        fontWeight: "normal",
        lineHeight: "1.5em"
    },
    link: {
        color: "skyblue !important",
        textDecoration: "underline !important"
    },
    slotList: {
        ...vflex,
        width: "100%",
        paddingLeft: "10rem",
        paddingRight: "10rem"
    },
    slot: {
        width: "100%",
        maxWidth: "30rem",
        marginBottom: "0.5rem",
        border: "1px solid white",
        "&:hover": {
            backgroundColor: "#0B0B0B"
        }
    },
    new: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        width: "100%",
        height: "100%",
        padding: "1em",
        cursor: "pointer"
    }
});
const Root = ()=>{
    const history = we6();
    const dispatch = useDispatch();
    const styles = useStyles10();
    const [isCreating, setIsCreating] = T7(false);
    const slotMap = useSelector(selectSlots);
    useAsyncEffect(()=>dispatch(rehydrateSlots()), []);
    const onPlay = (slot)=>history.push("/slot/" + slot.name);
    const onDelete = (slot)=>dispatch(removeSlot(slot.name));
    const onCreate = async (slot, file)=>{
        await dispatch(createSlot(slot, file));
        setIsCreating(false);
    };
    const slotKeys = Object.keys(slotMap);
    slotKeys.sort();
    return _e("div", {
        className: styles.root
    }, _e("h1", {
        className: styles.title
    }, "WebEra v2021.10.31"), _e("h2", {
        className: styles.subtitle
    }, "- Created by", " ", _e("a", {
        className: styles.link,
        href: "https://github.com/undercrow"
    }, "Undercrow"), " ", "-"), _e("ul", {
        className: styles.slotList
    }, slotKeys.map((key)=>_e("li", {
            className: styles.slot
        }, _e(ValidSlot, {
            slot: slotMap[key],
            onPlay: onPlay,
            onDelete: onDelete
        }))), _e("li", {
        className: styles.slot
    }, isCreating ? _e(NewSlot, {
        onCreate: onCreate
    }) : _e("div", {
        className: styles.new,
        onClick: ()=>setIsCreating(true)
    }, _e(AddBox, {
        color: "white",
        size: 48
    })))));
};
const App = ()=>_e(De4, null, _e(_e6, {
        path: "/"
    }, _e(Root, null)), _e(_e6, {
        path: "/slot/:slot"
    }, _e(Play, null)), _e(_e6, {
        path: "*"
    }, _e(Pe5, {
        to: "/"
    })));
ie(_e(Ke, {
    store: store
}, _e(se5, {
    hashType: "noslash"
}, _e(App, null))), document.getElementById("root"));
